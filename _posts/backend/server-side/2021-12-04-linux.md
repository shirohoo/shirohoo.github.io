---
layout: post
category:
    - backend
    - server-side
title: 리눅스 기초
description: >
    리눅스 기초 정리
image: /assets/img/common/code1.png
related_posts:
    -
---

* toc 
{:toc}

<br />

# 리눅스(Linux)

---

1991년 핀란드 헬싱키 공대 대학생이었던 `리누스 토르발스(Linus Benedict Torvalds)`가 개발한 커널이다. 혹은 이 커널을 사용하는 운영체제를 말한다.

리눅스 운영체제는 `유닉스(Unix)`에서 갈라져 나왔으며, 당시 유닉스의 가격이 막대했기에 개인이 함부로 사용할 수 없었다고 한다. (요즘 어지간한 대학의 컴퓨터과학과에는 한대정도씩 있다는듯...)

따라서 리눅스는 `Unix-like` 라고 부른다고도 한다.

<br />

`커널`이란, 컴퓨터의 하드웨어 자원을 프로세스에 할당해주거나 프로세스를 제어하거나 메모리를 제어하는 등의 전체적인 스케쥴링을 해주는 핵심적인 프로세스를 말한다.
{:.note}

<br />

여담이지만, 리누스 토르발스는 `깃(Git)`의 아버지이기도 하다... (😲)

코드와 모든 개발 과정이 완벽하게, 투명하 공개된 최초의 오픈소스 프로젝트이자, 현재 전 세계에서 가장 참여자가 많은 프로젝트이기도 하다는 듯...

<br />

![image](https://user-images.githubusercontent.com/71188307/144651900-646ca368-0be2-4f3d-95ab-b7e4a6d2bf3b.png)
> 리누스 토르발스(Linus Benedict Torvalds)

<br />

기본적으로 유닉스와 리눅스의 사용방법은 매우 유사하며, 이 말인즉슨 MacOS를 잘 다룬다면 리눅스도 큰 어려움 없이 잘 다룰 수 있음을 의미하며, 역시 그 반대도 성립한다.

`Apple`의 `MacOS`는 그 자체로 개인용 `유닉스`이므로, `Unix-like`라고 부르지 않는다고 한다.
{:.note}

<br />

리눅스는 아주 크게 `Debian`, `RedHat` 계열로 나뉘는데 대략적인 족보는 다음과 같다. (세세하게는 더 있는 것 같지만, 거기까진 몰라도 될 것 같다.)

<br />

- Debian
    - Debian
    - **Ubuntu**
    - ...

- RedHat
    - RedHat
    - Fedora
    - **CentOS**
    - ...

<br />

나도 30년 가까운 인생을 살면서 리눅스를 단 한번도 사용해보지 않았고, 오직 윈도우만 사용해봤던 사람이다.

본격적으로 개발자로 전업하며 리눅스를 처음 접했고 공부를 제대로 시작한것은 얼마 되지 않았다.

개발자 생활을 이어가다 보니 보통 개인적인 용도로는 데비안 계열의 `Ubuntu`를 사용하게 되었고, 실무에서 사용하는 서버 컴퓨터들은 모조리 `CentOS`를 사용하고있다.

근데 주변을 둘러봐도 나만 이런게 아니고 대체로 다 비슷한 것 같았다.

<br />

이 얘기를 왜 하냐면, `Debian`과 `RedHat`으로 계열이 나뉜다 한들 사실 실제로 사용하는 입장에서는 큰 차이가 없었다는 말을 하고 싶었기 때문이다.

두 계열을 일단 다 써보기는 했는데, 결국 디렉토리의 구조와 패키지 관리자가 조금 다르다 정도를 제외하면 대부분의 경우에 큰 차이를 느끼기 힘들정도였다.

즉, 아무 리눅스에 대해 잘 공부해두면 어떤 계열의 리눅스를 쓰던 별 문제 없이 사용할 수 있을 것 같다는 생각이 들었다.

<br />

# 셸(Shell)

---

![image](https://user-images.githubusercontent.com/71188307/144651841-154b4baf-10e2-493d-ba7a-9114df2fc9c2.png)

<br />

리눅스는 커널이며, 이 커널을 둘러싼 껍데기가 존재한다.

이 껍데기를 `셸(Shell, 조개껍데기)`이라고 부르며 셸은 커널과 사용자 사이에 위치해 커널을 외부에서 보호하고, 사용자들에게 조금 더 인간에게 친화적인 인터페이스를 제공하는 역할을 한다.

<br />

셸의 종류도 여러가지 존재하지만 크게 두가지만 알면 큰 문제 없을 것 같다.

<br />

- sh (Bourne Shell)
    - 유닉스에서 사용하는 슈퍼 셸. 모든 셸의 조상격.
    - 그 자체로 기능이 매우 적기 때문에, 역설적으로 정말 가볍고 빠르다.

- bash (Bourne-again Shell)
    - `csh(C Shell)`, `ksh(Korn Shell)`을 포함.
    - 즉, 기능이 많은 만큼 무겁다.
    - 셸 스크립트를 작성했을 때 `sh`에 비해 상대적으로 느리다고 한다.

<br />

리눅스에서는 대부분의 처리를 이 셸로 처리하기 때문에, 셸에 대해 알면 알수록 리눅스에 대한 모든 작업이 수월해진다.

일례로 리눅스에서 사용하는 모든 커맨드는 `셸 스크립트(Shell Script)`로 작성되어 어딘가에 위치하고 있다고 생각해도 무방하다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144703588-94f71461-7454-4be9-88b2-aaaf1508383c.png)

단, 셸 스크립트의 경우 깊게 파면 어지간한 프로그래밍 언어 수준으로 어렵다. 다만 그 시간을 투자할 가치는 충분히 있는 것 같다.
{:.note}

<br />

# 포트(Port)

---

유닉스와 리눅스는 `IANA(Internet Assigned Numbers Authority)`라는 범세계적인 기구에서 관리하는 `Well Known Ports`에 대해 알고있다.

<br />

> [📜 Service Name and Transport Protocol Port Number Registry](https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)

<br />

이것들은 그냥 <u>우리는 이 포트는 이 용도로 사용하자!</u> 라고 전 세계적으로 약속된 포트들이라고 이해하면 편하다.

굉장히 많지만 주로 자주 사용되어 알고있으면 좋을 것 같은 포트는 아래 표에 정리해뒀다.

<br />

| Port |   Protocol   |
|:----:|:------------:|
|  21  |     FTP      |
|  22  | SSH, SFTP... |
|  23  |    Telnet    |
|  25  |     SMTP     |
| 465  |    SMTPS     |
|  43  |    whois     |
|  53  |     DNS      |
|  80  |     HTTP     | 
| 443  |    HTTPS     | 
| 123  |     NTP      | 

<br />

# 파일시스템 디렉토리

---

윈도우는 보통 `C:\Windows` 하위에 존재하며, 가끔 뭔가 만질일이 생기면 `System32`폴더를 건드는 경우가 있다.

리눅스는 윈도우와 다르게 `root 경로(cd /)`에 수많은 파일시스템 디렉토리가 존재한다.

역시 매우 많지만 알고있으면 좋을만한 것들만 기록해뒀다.

<br />

| Directories |                Description                 |
|:-----------:|:------------------------------------------:|
|    /bin     |             기본 리눅스 명령어들이 위치한 곳             |
|    /sbin    |              관리자용 명령어들이 위치한 곳              |
|    /home    |                   유저들의 홈                   |
|    /etc     | 유저 비밀번호, 각종 프로그램의 설정파일, 리눅스의 설정파일 등이 위치한 곳 |
|    /lib     |      리눅스에 등록된 유저들이 공유하는 프로그램 등이 위치한 곳      |
|    /proc    |              프로세스의 정보들이 위치한 곳              |
|    /tmp     |               임시 파일들이 위치한 곳                |
|    /usr     |            각종 코드나 프로그램들이 위치한 곳             |
|    /var     |       로그, 메일처럼 점점 사이즈가 커지는 것들이 위치한 곳       |

<br />

# 명령어

---

## ls

---

`list segments`. 파일과 디렉토리의 모든 정보를 리스트로 나열한다.

여러가지 `alias`가 걸려있으며 주로 `ll`, `l`, `ls -a` 등의 명령어를 사용하게 된다.

윈도우 프롬프트를 오래 사용한 분들은 `dir`로 사용하는 경우도 있다.

<br />

## touch

---

파일을 생성한다. <u>touch testFile.txt</u> 를 입력하면 현재 위치에 testFile.txt라는 파일이 생성된다.

<br />

## cat

---

파일의 내용을 터미널에 출력하는 용도로 사용된다.

<br />

## head

---

파일의 내용중 최상단의 내용을 출력한다.

예를 들어 `head -500 testFile.txt`를 입력하면 testFile.txt의 맨 윗줄부터 500줄 까지의 내용이 출력된다.

<br />

## tail

---

`head`와 반대이다. 파일의 가장 아래쪽 부분을 터미널에 출력한다.

보통 로그파일을 볼 때 `-f` 옵션을 붙여 자주 사용하는데, 실시간으로 기록되는 로그가 계속해서 터미널에 출력되게 된다.

<br />

## pwd

---

`print work directory`의 약어로, 현재의 위치를 터미널에 출력한다.

<br />

## which

---

해당 파일의 위치를 읽어 터미널에 출력해준다.

이 경우 시스템 환경변수에 등록돼있지 않다면 알 수 없을수도 있다.

<br />

## echo

---

터미널에 내용을 출력한다.

`echo hello world` 를 입력하면 터미널에 `hello world`가 출력된다.

자바로 치면 <u>System.out.println("hello world")</u>,

자바스크립트로 치면 <u>console.log("hello world")</u>

파이썬으로 치면 <u>print("hello world")</u> 와 비슷하다.

<br />

## clear

---

터미널의 모든 내용을 지운다.

주로 명령어를 많이 입력해 터미널이 지저분할 경우 사용하며, `ls`와 같이 자주 사용하게 되는 명령어중 하나.

<br />

## cd

---

`change directory`의 약자로 말 그대로 다른 디렉토리로 접근하는 명령어.

`cd ~`를 입력하면 현재 로그인한 사용자의 홈(/home/{사용자})으로 이동한다.

`cd ..`를 입력하면 현재 위치의 상위 디렉토리로 이동한다.

`cd -`를 입력하면 이전 위치로 이동한다.

<br />

## mkdir

---

`make directory`의 약자. 새로운 디렉토리를 생성한다.

<br />

## rmdir

---

`remove directory`의 약자. 디렉토리를 제거한다.

사용할 때 매우 주의하자.

<br />

## cp

---

`copy`의 약자. 주로 파일이나 디렉토리를 옮기거나 복사할 때 사용한다.

<br />

## mv

---

`move`의 약자. 나는 보통 `cp`를 사용해서 잘 사용하지 않게 되는 명령어였다.

<br />

## rm

---

`remove`의 약자. 파일이나 디렉토리를 제거한다.

역시 사용할 때 매우 주의해야 한다.

`rm -rf` 와 관련한 여러가지 밈이 있다.

<br />

## find

---

위치를 기준으로 특정 조건을 만족하는 파일을 찾는다.

<br />

## grep

---

`find`와 자주 헷갈리는데, `grep`은 파일에서 원하는 단어를 찾는 명령어이다.

검색할때 이 명령어를 자주 사용하게 된다.

혹은 다른 명령어에 옵션으로 끼워넣어 사용하는 경우도 많다.

예를 들어 현재 실행중인 프로세스 중 특정 정보를 포함하는 프로세스가 찾고싶다면 다음과 같은 명령어를 입력한다.

`ps -ef | grep java` - 현재 실행중인 프로세스 중 `java`라는 단어가 들어있는 프로세스를 출력해라.

<br />

## whoami

---

현재 로그인한 유저가 누구인지 알고싶을 때 입력.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704659-ebfae18b-9447-48fe-964d-2aa16b1ab30c.png)

<br />

## passwd

---

현재 로그인한 유저의 비밀번호를 바꾸고 싶을 경우 입력. (pwd와 헷갈리지 말자!)

<br />

## df

---

현재 서버의 파일시스템 사용 정보를 출력한다.

비슷한 유형의 명령어들에 `-h (human의 약자로 추정)` 옵션을 추가하면 조금 더 사람이 읽기 쉽게 포매팅되어 출력된다.

`df -h`를 입력하면 다음과 같다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704672-1a996fa0-da41-4c2b-914e-c2c3a749f838.png)

<br />

## free

---

현재 서버의 메모리 사용 정보를 출력한다.

역시 `free -h`를 입력하면 다음과 같은 정보를 볼 수 있다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704728-7720383c-bc7d-43d6-8eb7-a80aef8638be.png)

<br />

## top

---

현재 서버의 전체적인 시스템 자원 사용 현황을 볼 수 있다.

주로 장애상황이나 평소 모니터링시 사용하며, 이 명령어를 입력 후 키보드의 `1`을 누르면 CPU의 현황을 코어별로 나눠서 볼 수도 있다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704741-622c331f-5f7f-464e-8b2c-55e25a164ef0.png)

<br />

## vmstat

---

`top`을 조금 더 편하게 쓰는 느낌이라고 해야할 까? 뭐라 정의하기 힘들다.

`vmstat 1`을 입력하면 현재 서버의 상태를 1초주기로 업데이트해서 계속 보여준다.

역시 서버의 상태를 모니터링할 때 사용한다. 주로 이쪽을 사용하는 듯.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704783-0ed968e2-5505-48d3-aea7-1861c18b2833.png)

<br />

## ps

---

현재 실행중인 프로세스의 정보를 모두 출력한다.

주로 `ps -ef`를 자주 사용한다.

`PID`는 프로세스의 아이디, `PPID`는 프로세스의 부모 아이디(parent)를 의미한다.

즉, 일반적으로 프로세스 하나를 제거하면 자식 프로세스도 모두 종료된다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704805-77ef393e-a4d4-4e23-9017-6ae97952c7f0.png)

<br />

## chmod

---

파일의 읽기(read), 쓰기(write), 실행(execute)에 대한 권한을 조정한다.

`ls -a` 같은 명령어를 입력하면 현재 위치한 디렉토리에 존재하는 파일들의 상세 정보를 알려주는데 대략 다음과 같은 뜻이 있다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144704936-ccf08a6d-9e64-406a-a130-55accd1c9afe.png)

<br />

`chmod +x file.txt`를 입력하면 모든 유저들에게 해당 파일에 대한 실행(execute) 권한을 허용(+)하는 것을 의미하며, `chmod -x file.txt`를 입력하면 실행 권한을 제거하는 것이 된다.

혹은 `chmod 755 file.txt`를 입력하면 자신에게 읽기, 쓰기, 실행 권한을 주고, 그룹과 타인에게는 읽기와 실행권한만 주라는 의미이다.

이는 이진수에 대한 이해가 필요한데, 10진수 7은 2진수로 111를 의미하며, 111은 각각 읽기, 쓰기, 실행 권한이 참(true)임을 의미하기도 하기 때문이다.

즉, 10진수 5는 2진수로 101이기 때문에, 읽기에 대한 권한이 1, 쓰기에 대한 권한이 0, 실행에 대한 권한이 1임을 의미한다.

<br />

## chown

---

파일에 대한 소유권을 변경하는데 사용된다.

소유권은 개인과 그룹이 존재하며 둘 모두를 변경하거나 하나만 변경할수도 있다.

하지만 이쪽은 chmod와 다르게 생각보다 자주 사용되지는 않는것 같다.

<br />

# 유저 생성, 제거

---

몇가지 방법이 있지만, 가장 편리한 것은 `adduser` 명령어를 사용하는 것이다.

이 명령어를 통해 유저를 생성하면 관련된 모든 폴더를 자동으로 함께 생성해주기 때문이다.

`adduser {유저이름}`을 입력하면 몇가지 설정에 대한 질문이 출력되는데, 잘 모르겠으면 그냥 엔터를 마구 눌러도 괜찮다.

어차피 크게 중요하지도 않고 나중에 바꿀수도 있다.

![image](https://user-images.githubusercontent.com/71188307/144704122-301c36be-f30d-46be-a577-e9965d45d942.png)

<br />

유저를 생성한 후 `/home` 폴더로 들어가 `ls -a`를 입력하면 새로 생성 된 것을 확인할 수 있다.

<br />

![image](https://user-images.githubusercontent.com/71188307/144705109-13983099-2e67-464e-baf7-8b7e008ab895.png)

<br />

유저를 제거하고 싶다면 `deluser {유저명}` 명령어를 이용하면 손쉽게 제거된다.

<br />
