<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>돈 받고 일하면 프로</title>
		<description>우리는 직장에서 훈련을 하기 때문에 매번 실수를 반복한다
</description>
		<link>https://shirohoo.github.io</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
		<pubDate>Sun, 24 Mar 2024 17:42:53 +0000</pubDate>
		<lastBuildDate>Sun, 24 Mar 2024 17:42:53 +0000</lastBuildDate>
		<generator>Jekyll v4.2.1</generator>
		
		<item>
			<title>전자지급결제서비스</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#지급결제&quot; id=&quot;markdown-toc-지급결제&quot;&gt;지급결제&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#지급결제서비스&quot; id=&quot;markdown-toc-지급결제서비스&quot;&gt;지급결제서비스&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#부가가치통신망-van-value-added-network&quot; id=&quot;markdown-toc-부가가치통신망-van-value-added-network&quot;&gt;부가가치통신망 (VAN, Value Added Network)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#신용카드-결제-과정&quot; id=&quot;markdown-toc-신용카드-결제-과정&quot;&gt;신용카드 결제 과정&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#인증&quot; id=&quot;markdown-toc-인증&quot;&gt;인증&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#승인&quot; id=&quot;markdown-toc-승인&quot;&gt;승인&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#카드전표매입&quot; id=&quot;markdown-toc-카드전표매입&quot;&gt;카드전표매입&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#전자지급결제대행pg-payment-gateway&quot; id=&quot;markdown-toc-전자지급결제대행pg-payment-gateway&quot;&gt;전자지급결제대행(PG, Payment Gateway)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#재미있는-자료&quot; id=&quot;markdown-toc-재미있는-자료&quot;&gt;재미있는 자료&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;지급결제&quot;&gt;지급결제&lt;/h2&gt;
&lt;p&gt;우리가 쿠팡과 같은 온라인 이커머스 플랫폼에서 상품을 구매하는 과정을 떠올려보면, 항상 마지막에는 결제가 일어납니다.
이 일련의 결제 과정을 지급결제라고 부르고, 지급결제는 내부적으로 굉장히 복잡한 과정을 거치게 되는데요.
우리가 개발자로서 결제 시스템을 개발하기 위해 결제가 어떤 방식으로 이뤄지는지 잘 알아야 할 필요가 있습니다.&lt;/p&gt;

&lt;p&gt;지급결제는 크게 &lt;strong&gt;지급&lt;/strong&gt;, &lt;strong&gt;청산&lt;/strong&gt;, &lt;strong&gt;결제&lt;/strong&gt;라는 3가지 과정을 거치는데 이 3가지의 과정은 각각 다음과 같은 의미를 갖습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지급
    &lt;ul&gt;
      &lt;li&gt;지급인이 채무의 변제를 위해 수취인에게 은행권이나 예금등의 화폐적인 청구권을 이전하는 행위&lt;/li&gt;
      &lt;li&gt;결제까지의 모든 과정이 끝나면 지급이 완료됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;청산
    &lt;ul&gt;
      &lt;li&gt;지급지시의 전송, 확인 혹은 지급지시 간 차감을 통한 포지션을 산정하는 행위를 통해 최종적으로 수취하거나 지급해야 할 차액이 얼마인지를 산정하는 과정&lt;/li&gt;
      &lt;li&gt;우리가 일상생활에서 흔히 사용하는 &lt;strong&gt;정산&lt;/strong&gt; 이라는 용어로 이해해도 큰 문제가 없는 과정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결제
    &lt;ul&gt;
      &lt;li&gt;청산 과정이 끝난 후 마지막으로 한국은행의 거액 결제망인 한은금융망을 통해 지급이 완료되는 단계&lt;/li&gt;
      &lt;li&gt;한국은행에 개설된 지급은행의 당좌예금계좌에서 수취은행의 당좌예금예좌로 화폐가 실제로 이동하면서 경제주체간 채권, 채무의 해소가 완결 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;용어가 생소하고 어려울 수 있는데요, 지금부터 쉬운 예시를 통해 한번 이해해 봅시다.
채권과 채무라는 용어부터 짚고 넘어갈게요. 우리가 미용실에서 머리를 자르면 미용실은 우리에 대한 채권이 생기고 우리는 미용실에 채무를 지게 됩니다.
채권과 채무는 어려운게 아니고 각각 &lt;strong&gt;돈을 받을 수 있는 권리&lt;/strong&gt;와 &lt;strong&gt;돈을 지불해야 할 의무&lt;/strong&gt;를 뜻합니다.
그리고 이것들은 법적으로 보장되게 됩니다.&lt;/p&gt;

&lt;p&gt;온라인 결제 시장, 그러니까 위의 예시인 쿠팡을 들어보면 우리가 쿠팡에서 물건을 장바구니에 담고 결제창에 진입해 결제를 하게 되면 쿠팡은 우리에 대한 채권이 생기고 우리는 쿠팡에 대한 채무가 생기게 되는 것이죠.
이 채무관계를 청산하는 일련의 과정, 그러니까 우리의 계좌에서 돈이 빠져나가고 쿠팡의 계좌에 돈이 입금되는 과정이라고 볼 수 있겠죠? 이 과정을 바로 &lt;strong&gt;지급결제&lt;/strong&gt;라고 부르게 됩니다.&lt;/p&gt;

&lt;p&gt;이제 다음 그림을 한번 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/shirohoo/shirohoo.github.io/assets/71188307/554bc203-aac7-45f0-9a45-6b3e800adcfd&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;지급인은 우리가 되겠고, 수취인은 쿠팡이 되겠죠? 내부적으로는 위와 같은 과정을 통해 화폐의 이동이 이뤄집니다.
여기서 당좌예금계좌는 수표나 어음 등을 발행할 수 있는 특수한 계좌를 의미하는데, 기업마다 하나씩 가지고 있는 대표 계좌라고 생각하시면 됩니다.
개인적으로 개발자로서 굳이 깊게 팔만한 내용은 아니라고 생각되는데, 만약 파봤는데 너무 복잡하다면 우리가 일상생활에서 흔히 볼 수 있는 마이너스 통장과 유사한 개념이라고 이해하고 넘어가도 개발하는데 큰 문제는 없을거에요.&lt;/p&gt;

&lt;h2 id=&quot;지급결제서비스&quot;&gt;지급결제서비스&lt;/h2&gt;

&lt;p class=&quot;figcaption&quot;&gt;&lt;img src=&quot;https://github.com/shirohoo/shirohoo.github.io/assets/71188307/85513c84-b267-4239-9a07-7da04dd528af&quot; alt=&quot;image&quot; /&gt;
잘 안보인다면 화면을 확대해주세요&lt;/p&gt;

&lt;p&gt;지급결제서비스는 위와 같은 흐름으로 이뤄집니다. 그리고 가장 마지막의 금융기관 항목에서 바로 처음 언급한 지급결제가 실질적으로 이뤄지는 것이죠.
모든 흐름을 완벽하게 알면 너무 좋겠지만 가성비가 떨어지니 차치하고, 여기서 오프라인 결제와 온라인 결제로 나뉘는데 개발자들은 당연히 온라인 결제를 개발하게 될 테니 개발자들이 가장 많이 접하게 되는 부분은 바로 &lt;strong&gt;전자지급결제대행&lt;/strong&gt;, 즉 &lt;strong&gt;PG사&lt;/strong&gt;가 되겠습니다. 그리고 추가로 &lt;strong&gt;부가가치통신망&lt;/strong&gt;, 즉 &lt;strong&gt;VAN사&lt;/strong&gt;를 함께 알아두면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;그리고, 이제부터 &lt;strong&gt;사장님들&lt;/strong&gt;과 &lt;strong&gt;가맹점&lt;/strong&gt;은 같은 의미로 사용되는 점을 알아주세요.&lt;/p&gt;

&lt;h2 id=&quot;부가가치통신망-van-value-added-network&quot;&gt;부가가치통신망 (VAN, Value Added Network)&lt;/h2&gt;

&lt;p&gt;VAN사가 없던 옛날에는 각 카드사별로 카드단말기가 상이했기 때문에, 사장님들이 각 카드사에 별도로 가맹하여 직접 가맹점이 되어야 했습니다.
그래서 옛날에는 각 가게마다 가게 정문에 &lt;strong&gt;국민카드 결제 됩니다&lt;/strong&gt; 라는 문구와 함께 &lt;strong&gt;국민카드 스티커&lt;/strong&gt;가 붙어있다던가 하는 경우가 많았습니다.
상황이 이렇다 보니 사장님들은 여러 카드사의 단말기를 모두 관리해야 하는 문제가 있었죠.
그리고, 사장님들이 직접 카드전표 제출까지 해야 하다 보니 카드사로부터 상품대금을 정산받는 것도 오래 걸렸다고 합니다. (10년 가까이 자영업을 하고 있는 친동생 피셜입니다)&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;카드전표매입&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;채권자(여기서는 사장님)가 카드사에 채무이행을 하라는 의미로 카드전표(카드영수증, 채권)를 카드사(채무자)에 제출하는데, 카드사에서는 카드전표를 받는다 하여 이 업무를 카드전표매입이라 부릅니다. 카드사는 자신들의 돈으로 우선 사장님에게 화폐를 지불하고, 이후 금융기관에 지급요청을하여 사장님에게서 물건을 사간 고객의 계좌에서 돈을 인출해옵니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;VAN사는 이런 문제를 해결하기 위해 등장했습니다. 그림으로 보면 다음과 같을 것 같아요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/shirohoo/shirohoo.github.io/assets/71188307/ecb15847-1bb1-4c7b-8e83-aa9bfd635177&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VAN사&lt;/strong&gt;는 다음과 같은 일을 합니다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;카드사를 대신해 가맹점을 모집합니다&lt;/li&gt;
  &lt;li&gt;가맹점에 &lt;strong&gt;통합단말기&lt;/strong&gt;를 설치해줍니다&lt;/li&gt;
  &lt;li&gt;통합단말기를 통해 가맹점과 카드사간의 카드승인중계를 해줍니다&lt;/li&gt;
  &lt;li&gt;카드전표매입을 해줍니다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;또 어려운 용어들이 튀어나오는데, 실생활 예시를 통해 이해해봅시다.&lt;/p&gt;

&lt;h3 id=&quot;신용카드-결제-과정&quot;&gt;신용카드 결제 과정&lt;/h3&gt;

&lt;h4 id=&quot;인증&quot;&gt;인증&lt;/h4&gt;
&lt;p&gt;아래에 후술할 승인이 이뤄지기 위해서는 인증이라는 과정을 거칩니다.
뭐 별다를게 없고 카드가 유효한지, 한도가 남아있는지 등을 판단하는 것이죠.&lt;/p&gt;

&lt;h4 id=&quot;승인&quot;&gt;승인&lt;/h4&gt;
&lt;p&gt;우리가 점심시간에 분식집에 가서 점심을 먹고 카드를 카드단말기에 대 결제를 하고 나오면 휴대폰으로 카드결제가 되었다는 알림이 옵니다.
이를 승인이 완료됐다고 표현하는데요, 실제로 이 시점에서는 화폐가 단 하나도 이동하지 않았습니다. 채무관계가 발생했고, 채권만 여기저기 오간 상황이죠.&lt;/p&gt;

&lt;h4 id=&quot;카드전표매입&quot;&gt;카드전표매입&lt;/h4&gt;
&lt;p&gt;손님은 이미 결제를 하고 떠났지만 분식집 사장님은 아직 돈을 한푼도 받지 못한 상황입니다. 단지 채권만 가진 상태이죠.
사장님은 카드사 가맹점으로서 이제 카드전표를 카드사에 보내고 카드사에서 카드전표에 대한 검토가 완료되고 나서야 돈을 정산받을 수 있습니다.
옛날에는 사장님들이 이 작업을 수기로 하나하나 하셨다고 해요.&lt;/p&gt;

&lt;p&gt;카드사에서는 카드전표를 매입한 후에 카드가 도난된게 아닌지, 이중결제가 되었는지 등의 유효성 검증을 마친 후에 아무런 문제가 없다면 거래를 확정시키고 대금을 사장님들에게 정산해주게 됩니다.&lt;/p&gt;

&lt;p&gt;이렇게 복잡한 과정을 거치는 이유는 결국 리스크 관리 차원이 가장 크다고 볼 수 있겠습니다. 이러한 복잡한 절차를 사이에 둠으로써 잘못된 자금 운용이 발생할 리스크를 줄이는것이죠.&lt;/p&gt;

&lt;p&gt;하지만 이런 상황은 손님, 사장님들과 카드사 모두에게 좋지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어떤 점이 안 좋을까요?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;손님
    &lt;ul&gt;
      &lt;li&gt;국민카드만 가지고 있다면 국민카드를 취급하는 가게를 찾아야 합니다&lt;/li&gt;
      &lt;li&gt;위의 상황이 싫다면 각 카드사별로 카드를 여러개 소지하고 다녀야 합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사장님
    &lt;ul&gt;
      &lt;li&gt;가맹중인 카드사가 다섯군데라면 다섯개의 카드단말기를 관리해야 합니다&lt;/li&gt;
      &lt;li&gt;가맹중인 카드사가 다섯군데라면 카드전표를 정리해서 다섯군데의 카드사에 카드전표를 제출해야 합니다&lt;/li&gt;
      &lt;li&gt;상품을 팔았지만 상품대금을 정산받는게 늦어집니다 (일련의 과정이 복잡하므로)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카드사
    &lt;ul&gt;
      &lt;li&gt;업무가 많고 복잡해집니다&lt;/li&gt;
      &lt;li&gt;일련의 과정이 복잡해지기 때문에 비용이 커지고, 더 많은 가맹점을 유치하기가 어려워집니다&lt;/li&gt;
      &lt;li&gt;결제가 쉽지 않기 때문에 유입이 적어집니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;VAN사&lt;/strong&gt;는 사장님들과 카드사 사이에서 이러한 문제들을 해결해주고, 카드사에게 직접 수수료를 받습니다.
이제 손님과 사장님들, 카드사, VAN사가모두 윈윈하게 되는 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어떤 점이 좋아졌을까요?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;손님
    &lt;ul&gt;
      &lt;li&gt;기존에는 국민카드를 들고 있다면 국민카드 결제가 가능한 가게만 찾아다녀야 했는데, 이제는 아무데나 가도 국민카드로 결제가 됩니다&lt;/li&gt;
      &lt;li&gt;더 이상 여러개의 카드를 들고 다닐 필요가 없습니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사장님
    &lt;ul&gt;
      &lt;li&gt;이젠 통합단말기(주로 POS기) 하나만 관리하면 됩니다&lt;/li&gt;
      &lt;li&gt;통합단말기에서 카드전표제출 버튼을 한번만 누르면 모든 카드전표제출이 완료됩니다&lt;/li&gt;
      &lt;li&gt;상품대금을 정산받는게 빨라집니다 (23년 기준 빠르면 하루, 늦으면 3일이내)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;카드사
    &lt;ul&gt;
      &lt;li&gt;VAN사에서 모든 카드전표를 정리해주니 업무가 확 줄어듭니다&lt;/li&gt;
      &lt;li&gt;업무가 확 줄어드니 정산이 빨리빨리 이뤄지고, 자금 흐름이 빨라집니다&lt;/li&gt;
      &lt;li&gt;VAN사에서 가맹점 유치까지 해줍니다&lt;/li&gt;
      &lt;li&gt;고객 입장에서는 결제하기가 편해지니 유입이 많아지고 카드 결제가 더 많이 일어나게 되어 수수료를 많이 받을 수 있게 됩니다&lt;/li&gt;
      &lt;li&gt;위의 과정을 인력을 채용해 처리하는것보다 VAN사에 약간의 수수료를 지불하고 끝내는것이 더 경제적입니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;VAN사&lt;/strong&gt;는 카드사로부터 수수료를 받으니 역시 좋겠죠?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;POS기&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;흔히 카드단말기라 하면 그냥 카드를 대는곳만 있는 장치를 떠올릴 수 있는데, POS기는 이 카드단말기에 모니터가 달린 제품을 의미합니다.
즉, POS기도 카드단말기의 범주에 들어가는 것이죠. 단, POS기는 카드단말기의 역할을 모두 포함하면서, 사용자 친화적인 UI/UX로 사용자의 실수를 줄여주기에
사장님들이 POS기를 선호하시는 경향이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;전자지급결제대행pg-payment-gateway&quot;&gt;전자지급결제대행(PG, Payment Gateway)&lt;/h2&gt;

&lt;p&gt;흔히 PG사라고 부릅니다. 영문명에 Gateway(관문)라는 이름이 들어가죠? 이 용어가 PG사의 핵심을 나타내는 용어라고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;위의 내용들을 통해 카드결제가 이뤄지는 흐름을 어느정도 이해했을겁니다.
위에서는 언급을 하지 않았지만, 사실 카드사는 카드결제를 많이 일으키는 가맹점에는 수수료를 깎아주고 카드결제가 많지 않은 영세한 사장님들에게는 높은 수수료를 받는데요, 이렇다 보니 영세한 사장님들은 높은 카드 수수료의 부담이 있었던 거죠.&lt;/p&gt;

&lt;p&gt;이 문제를 해결하기 위해 탄생하는 개념이 바로 PG사입니다. 한 마디로 설명하자면 PG사는 모든 카드 가맹점들의 대표 가맹점이라고 할 수 있습니다.
카드사가 수수료를 깎아주는 메커니즘을 이용하면 PG사가 많은 가맹점을 유치할수록 가맹점들이 부담해야 할 수수료가 적어지기 때문에, 영세한 가맹점들은 PG사 밑으로 들어가 &lt;strong&gt;“우리 대신 대표로 결제해주세요”&lt;/strong&gt; 를 시전하게 되는 것이죠.
그리고 이렇게 되면 VAN사와 카드사 입장에서는 모든 결제가 이 대표 가맹점(PG사)에 의해 이뤄진것처럼 보여지기 때문에 PG사에 대한 카드사의 수수료가 대폭 깎여나가게 됩니다.
서버 개발로 비유하면 &lt;strong&gt;리버스 프록시(Reverse Proxy)&lt;/strong&gt;와 아주 유사한 개념이라고 볼 수 있겠습니다.&lt;/p&gt;

&lt;p&gt;하지만 PG사는 결국 가맹점이라는 포지션에서 벗어나지 않기 때문에 PG사 역시 VAN사 혹은 카드사와 직접 가맹하게 되며, PG사는 카드사에게 직접 수수료를 받아내는 VAN사와 다르게 오히려 카드사에 수수료를 지불하는 입장이 됩니다. 그래서 하위 가맹점들에게 소정의 수수료를 받게 되죠.
그런데 이게 사장님들 입장에서는 VAN사랑 거래할때와 다르게PG사랑 거래하니 추가적인 수수료가 생기네? 가 되기 때문에 (그럼에도 불구하고 더 쌉니다!), PG사는 VAN사와 다르게 고객들에게 여러 편의기능들을 더 제공해주게 됩니다. (물론 다른 이유들도 있습니다!)&lt;/p&gt;

&lt;p&gt;아무튼 우리 개발자들이 주로 PG사를 접하게 되는 이유도 이 맥락에서 나오는데, 대부분의 PG사가 바로 온라인 결제(전자지급결제서비스)를 지원해주기 때문입니다.
개발자들 입장에서는 원래라면 각 결제 수단, 결제 채널 등을 모두 고려하여 코드를 작성해야 했을 일이 PG사 하나만 연동하면 모두 끝나게 되는 것이니 제품 개발 기간이 획기적으로 줄어들고, 유지보수도 편리해지게 됩니다.&lt;/p&gt;

&lt;p&gt;하지만 위에서 언급한 PG사의 특수성으로 인해 사장님들 입장에서는 VAN사가 아닌 PG사를 거치게 되면 PG사에 수수료를 추가로 지불해야 하기 때문에 업장의 상황에 따라서 오히려 PG사를 거치는것이 손해가 될수도 있게 됩니다. 
이미 카드결제를 많이 일으키고 있어서 카드사로부터 수수료 할인을 많이 받는 입장이라면 굳이 PG사를 거칠 이유가 없는 것이죠. 
오히려 이런 경우에는 본인들이 PG사를 차리는 경우도 있게 됩니다. 왜냐하면, 하위 가맹점들로부터 추가적인 수수료를 더 받을 수 있으니까요. 대표적으로 빅테크들이 자회사로 운용하는 PG사들이 있을 수 있겠죠?&lt;/p&gt;

&lt;p&gt;즉, 업장이나 회사의 규모, 거래매출 상황 등에 따라 VAN사와 거래할 것인지 PG사와 거래할 것인지를 잘 따져봐야 할 필요가 있는데요.
PG사가 태어나게 된 계기가 계기이다 보니 시장의 대부분을 차지하는 영세한 업장의 입장에서는 사실 PG사를 이용하는게 이익일 때가 많겠죠?&lt;/p&gt;

&lt;h2 id=&quot;재미있는-자료&quot;&gt;재미있는 자료&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://youtu.be/BjY4OVxFDuU&quot;&gt;페이(Pay)와 신용카드의 동상이몽. 전면전이냐, 공존이냐? (feat. Visa의 전략)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
			<pubDate>Sun, 17 Sep 2023 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/financial/2023-09-17-financial-1/</link>
			<guid isPermaLink="true">/financial/2023-09-17-financial-1/</guid>
			
			
			<category>financial</category>
			
		</item>
		
		<item>
			<title>C 레벨의 경이로운 결정과 어이없고 화나는 장애</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#c-레벨의-경이로운-결정&quot; id=&quot;markdown-toc-c-레벨의-경이로운-결정&quot;&gt;C 레벨의 경이로운 결정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#어이없고-화나는-장애&quot; id=&quot;markdown-toc-어이없고-화나는-장애&quot;&gt;어이없고 화나는 장애&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;c-레벨의-경이로운-결정&quot;&gt;C 레벨의 경이로운 결정&lt;/h2&gt;

&lt;p&gt;우리 회사에 와서 느낀 가장 큰 문제는 시리즈 B에 도달하기까지 6년의 시간동안 회사는 엄청난 기술부채를 축적했다는 것이다.&lt;/p&gt;

&lt;p&gt;그래서, 일년동안 기술부채 청산에 대해 노래를 부르고 다니고, 여기저기 많은 설득을 시도했었다.
일개 팀원이지만 리드 미팅까지 쳐들어가서 우리 회사는 기술부채를 청산하는 게 가장 시급하다는 주장을 펼치기도 했었다.&lt;/p&gt;

&lt;p&gt;그러고 있던 와중 최근에 C 레벨에서 믿기 힘든 결정이 내려졌다. 이게 정말 될지는 몰랐는데, 이제부터는 비즈니스를 모두 접고 내실을 다지는 데 총력을 다한다고 한다. 🥺&lt;/p&gt;

&lt;p&gt;그동안은 우리 플랫폼 개발팀의 개발자들은 기술부채를 청산하는 데 주력하고 다른 팀의 개발자들은 비즈니스를 진행했는데, 이렇다 보니 많은 혼란이 있었다. 
우리는 하위호환성 문제로 구조를 시원시원하게 갈아엎지 못하고 찔끔찔끔 개선작업을 진행했으며, 다른 팀은 더러운 시스템에 새로운 비즈니스를 진행하면서 기술부채를 계속 늘려갔다. 시스템이 더러우니 아주 당연한 결과다. 그들의 잘못은 절대 없다.
이제는 수십 명의 개발자를 모두 개발부채 청산에 몰빵한다고 한다. 우리도 이제 기술부채 청산에 온전히 몰두할 수 있는 환경이 조성됐다.&lt;/p&gt;

&lt;p&gt;기술부채 청산이 가장 시급하다고 노래를 부르고 다닌 이유는 다름 아니다.
이제는 개발자들조차 우리 코드를 이해하는 게 불가능에 가까워졌기 때문이다. 개발 일정을 전혀 예상할 수 없으며, 시도때도없이 발생하는 버그들 탓에 원인을 분석하고, 데이터베이스에 쿼리를 수동으로 입력하느라 우리가 해야 할 일을 아예 못하고 있다. 
새로운 개발을 진행하고 나면 다음 개발은 배 이상 느려진다.
기회는 준비된 자가 잡을 수 있는 법인데, 우리는 준비가 전혀 되지 않은 상태였다. 
이 상태로 미래는 꿈조차 꾸기 어렵다고 생각했다.&lt;/p&gt;

&lt;p&gt;그럼에도 불구하고, 사업이란 굉장히 현실적인 문제들이 많이 얽혀있기 때문에 나는 C 레벨에서 이런 결정이 내려질 거라고는 정말 상상도 하지 못했다.
C 레벨이 이런 결정을 내린다는 것은 그들이 투자자와 주주들의 비판과 비난을 온몸으로 감내해가며 방패막이가 되어주겠다는 결정이라고 생각했기 때문이다.
나는 C 레벨이 이런 결정을 내린 상황에 대해 굉장히 열렬한 지지를 보낸다. 
아주 옳은 결정이고, 어떻게 보면 생존을 위한 어쩔 수 없는 선택이라고 볼 수도 있겠지만, 엄청난 고난이 예상되는 결정이기 때문에 엄청나게 어려운 선택이었음을 아주 잘 알고 있고, 그 용기가 존경스럽기마저 하다.&lt;/p&gt;

&lt;h2 id=&quot;어이없고-화나는-장애&quot;&gt;어이없고 화나는 장애&lt;/h2&gt;

&lt;p&gt;데이터베이스가 워낙에 막장이다 보니, 주로 데이터 무결성이 보장되지 않음으로 인한 장애들이 하루에도 수십번씩 발생한다.&lt;/p&gt;

&lt;p&gt;고객의 주소와 좌표를 핵심으로 다루는 테이블이 있는데, 주소는 있지만, 좌표가 없는 사례가 아주 많았다.
그래서 8월 초에 애플리케이션 코드에서 주소는 있는데 좌표가 없다면 좌표를 계산해 데이터베이스에 채워넣는 코드를 작성했었다.
아주 단순한 코드였고, 메인이 되는 쿼리도 대략 다음과 같이 아주 간단했다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lng&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address_guid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이게 한 달여가 지난 후인 최근에 굉장히 어이없는 장애를 일으켰는데, 약 34만여 개의 고객 좌표가 엉뚱한 좌표로 변경된 것이다.
아무리 봐도 딱히 문제가 될게 없어 보여 원인을 알아내는데 약 2시간 정도가 걸렸는데, 알고 보니 이유는 아주 간단했다.&lt;/p&gt;

&lt;p&gt;address_guid가 고유한 값이 아니었던 것이다.
address_guid 컬럼에 ＂home＂이라는 문자열이 저장된 데이터가 30만 개 이상 존재했고, 그동안은 위 쿼리의 where 절에 guid가 바인딩 되어 문제가 없다가 어느 날 ＂home＂이 바인딩 되며 30만 개 이상의 데이터가 모두 변경된 것이다.&lt;/p&gt;

&lt;p&gt;한참동안 코드를 보며 원인을 찾던 중 설마? 하며 address_guid를 기준으로 group by 쿼리를 입력해본 후 나는 뒤통수를 세게 맞은 느낌과 함께 곧바로 좌절할 수밖에 없었다.&lt;/p&gt;

&lt;p&gt;30만개의 데이터를 복구하는데 약 7시간이 소요되었는데, 이 시간 동안 회사의 핵심 시스템이 중단될 수밖에 없었다.&lt;/p&gt;

&lt;p&gt;그동안 코드의 함수명이 get~인데, 동작이 이상해 구현을 모조리 까 뒤집어 보니, 실제로 데이터베이스에 update 쿼리를 보낸다거나 하는 식의 함정 카드가 많아 코드의 모든 이름을 믿지 못하고 모든 코드를 DFS하는 상황에 와 있었는데, 이제는 테이블의 스키마조차 믿기 힘든 상황이 되었다.&lt;/p&gt;

&lt;p&gt;정말 쉽지 않다.&lt;/p&gt;
</description>
			<pubDate>Thu, 14 Sep 2023 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2023-09-14-diary-51/</link>
			<guid isPermaLink="true">/diary/2023-09-14-diary-51/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>MySQL 5.7 테이블 리팩토링중 varchar 길이 제한 문제 해결</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#현재-상황과-정규화의-중요성&quot; id=&quot;markdown-toc-현재-상황과-정규화의-중요성&quot;&gt;현재 상황과 정규화의 중요성&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#tf-상황&quot; id=&quot;markdown-toc-tf-상황&quot;&gt;TF 상황&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#테이블-정규화&quot; id=&quot;markdown-toc-테이블-정규화&quot;&gt;테이블 정규화&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;현재-상황과-정규화의-중요성&quot;&gt;현재 상황과 정규화의 중요성&lt;/h1&gt;

&lt;p&gt;현재 운영 중인 TF에 참여하면서 백오피스(혹은 콘솔 또는 어드민)을 개선하고 있는 애플리케이션에 대해 데이터베이스 읽기에 대한 요구사항이 대부분입니다.
우리 회사의 레거시 시스템도 데이터베이스에서 시작하며(MySQL 5.7을 사용하고 있습니다), 현재 우리의 데이터베이스에는 큰 문제가 있습니다.
그 문제는 대부분의 테이블이 제1 정규화도 제대로 되어있지 않다는 것입니다.
예를 들어 고객, 주문, 결제, 결제내역이라는 도메인이 있다고 가정해봅시다. 이 모든 도메인을 하나의 테이블 A에 몰아넣고, type이라는 열을 추가하고 0(고객), 1(주문), 2(결제), 3(결제내역)과 같이 정의합니다. 그리고 하나의 열에 여러 개의 데이터가 파이프문자(|)로 구분되어 저장됩니다.
이런 상황에서는 인덱스를 제대로 활용할 수 없어 대부분의 쿼리가 비효율적일 수밖에 없게 됩니다. 특히, 고객 데이터를 조회하기 위해서는 다음과 같은 쿼리를 작성해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 상황에서는 type 열에 인덱스를 걸어도 의미가 없습니다. 왜냐하면 type 열에는 0, 1, 2, 3 이렇게 4개의 값만 들어가기 때문에, 인덱스를 걸어 정렬을 해두어도 type이 0인 모든 데이터를 조회하려면 결국 테이블의 25%를 반드시 읽어야 하기 때문입니다. 이러면 옵티마이저는 테이블 풀스캔이나 인덱스 풀스캔을 선택할 수밖에 없게 됩니다.&lt;/p&gt;

&lt;p&gt;API의 지연시간을 최소화하기 위해서는 테이블에 액세스했을 때 가져오는 데이터가 최소화되어야 합니다. 그러나 원하는 데이터를 조회하기 위해서는 모든 데이터가 짬뽕되어 있는 특정 테이블을 반드시 조회해야 하고, 액세스 조건이 테이블 풀스캔 또는 인덱스 풀스캔으로 시작되어버리면 가져오는 데이터를 최소화시킬 수 없게 됩니다.&lt;/p&gt;

&lt;p&gt;예를 들어, 가입일이 2020-12-31 이후인 고객의 목록을 조회하고 싶다면 다음과 같은 쿼리를 작성해야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;AND&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2020-12-31'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 쿼리는 액세스 조건인 type = 0이 테이블 풀스캔이나 인덱스 풀스캔으로 시작되어버리기 때문에, 결국 테이블의 25%를 읽어야 합니다. (상황에 따라 옵티마이저가 created_at을 액세스 조건으로 변경할 수도 있습니다.) 이후 created_at 조건이 평가되며, 가입일이 2020-12-31 이후인 데이터를 분류하게 됩니다.&lt;/p&gt;

&lt;p&gt;반면, 테이블이 고객, 주문, 결제, 결제내역으로 나뉘어 있었다면(정규화 되어 있었다면), 위 쿼리는 다음과 같이 작성되었을 것이며 성능이 훨씬 더 좋았을 것입니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;고객&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2020-12-31'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이러한 방식의 테이블 설계는 현재 우리 회사에서 다음과 같은 문제들을 일으키고 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;인덱스를 활용한 고성능 쿼리 작성이 어렵습니다. (API의 지연 시간이 느려지는 가장 큰 이유 중 하나)&lt;/li&gt;
  &lt;li&gt;정규화가 되어 있지 않기 때문에 각 테이블의 행렬이 비대해집니다. (코드가 더러워지는 가장 큰 이유 중 하나)&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;확장이 어렵습니다. 예를 들면 고객이 여러 개의 권한을 가질 필요가 있을 때, 고객과 권한이 하나의 테이블로 구성되어 있다면 새로운 권한을 추가하는 것이 불가능합니다. (이런 문제로 파이프문자(&lt;/td&gt;
          &lt;td&gt;)로 여러 개의 데이터가 들어있거나, JSON 열을 추가한 히스토리가 있음)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;tf-상황&quot;&gt;TF 상황&lt;/h1&gt;

&lt;p&gt;현재 운영 중인 TF에서는 위의 상황으로 인해 단순한 데이터베이스 읽기 요구사항들이 굉장히 어려움을 겪고 있습니다. 단순한 목록을 출력하는 데에도 5초 이상의 시간이 소요되는 경우가 많습니다.&lt;/p&gt;

&lt;p&gt;기존 테이블 구조를 변경하지 않고도 쿼리 튜닝으로 해결할 수 있는 부분들은 해결하고 있지만, 도저히 해결할 수 없는 경우도 발생하고 있습니다.&lt;/p&gt;

&lt;p&gt;회사 내에는 message라는 이름의 테이블이 있는데, 이 테이블에는 이메일, SMS, 알림톡 등 각종 타입의 코멘트들이 혼재되어 있습니다. 즉, 문자열로 이루어진 콘텐츠가 대부분 혼재되어 있는 행의 수가 4천만 건 이상인 테이블입니다.&lt;/p&gt;

&lt;p&gt;특정 데이터를 조회하여 목록에 같이 보여주어야 하는데, 어떻게 해도 만족스러운 성능을 얻을 수 없었습니다.&lt;/p&gt;

&lt;h1 id=&quot;테이블-정규화&quot;&gt;테이블 정규화&lt;/h1&gt;

&lt;p&gt;문제가 너무 커지기 때문에 정말로 손대고 싶지 않았지만, 결국 message 테이블에서 관리자들이 작성한 코멘트들을 분리해 별도의 테이블로 정규화하기로 결정했습니다.&lt;/p&gt;

&lt;p&gt;새로운 테이블의 DDL은 다음과 같습니다. (이름들이 마음에 들지는 않지만, 기존 시스템과 위화감이 없도록 최대한 그대로 가져갔습니다.)&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DATETIME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;CONSTRAINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo_ibfk_1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;CONSTRAINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo_ibfk_2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'관리자들이 정보를 공유하기 위해 수업신청서에 작성한 메모'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx_created_at&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 데이터 이관을 위해 다음 쿼리를 실행했습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_system_sid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender_account_sid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sent_at&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender_account_sid&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_system_sid&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;content의 길이가 너무 길어 varchar(500)에 넣지 못한다는 에러가 발생했습니다.&lt;/p&gt;

&lt;p&gt;대체 메모가 얼마나 길길래 500자를 넘어서는지 궁금하여 아래의 쿼리를 실행해보았습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;LENGTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender_account_sid&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_system_sid&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/118342500/235295539-41a2e2e8-b4f5-4dfe-a397-ee4d74e51880.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;많이 놀랐으나 어쨋든 데이터 이관은 해야하니 DDL의 varchar(500)을 varchar(18000)으로 변경하려 하니 이번엔 다음과 같은 에러가 발생했습니다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;42000][1074] Column length too big &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;column &lt;span class=&quot;s1&quot;&gt;'content'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;max &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 16383&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; use BLOB or TEXT instead
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;varchar의 최대 길이는 65,536 정도라고 알고 있었는데, 이러한 결과가 나와서 결국 MySQL 5.7의 공식 문서를 찾아봤습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/string-functions.html&quot;&gt;String Functions and Operators&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/char.html&quot;&gt;The CHAR and VARCHAR Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문서를 대충 요약하자면, varchar 타입은 65,535 바이트까지 허용되며, length 함수는 문자열의 바이트를 반환한다는 내용입니다.&lt;/p&gt;

&lt;p&gt;우리 테이블의 collation은 utf8mb4로 설정되어 있으므로 문자 한개당 4 바이트로 계산됩니다. 에러 메시지의 max값인 16,383이라는 수치에 4를 곱하면 65,532 바이트가 나오죠.
하지만 16,383을 초과하는 16,384라는 수치에 4를 곱하면 65,536 바이트이기 때문에 varchar 타입이 허용하는 65,535 바이트를 넘어가게 됩니다.
이쯤에서 varchar 뒤 소괄호에 넣는 값은 단순히 문자열의 길이(문자의 수)를 의미함을 알 수 있었습니다. 즉, varchar(16383)이라는 의미는 16383개의 문자를 넣을 수 있다는 의미죠.&lt;/p&gt;

&lt;p&gt;이제 위 length 함수를 사용한 쿼리의 결과인 17,995는 17,995 바이트를 의미함을 알 수 있습니다. 여기서 단순히 4로 나눠 나온 값인 약 4500을 varchar에 적용해 varchar(4500)으로 설정하려고 할 수 있는데요, 맹점이 하나 있습니다.
length 함수는 한글, 이모지등의 멀티바이트 문자에 대해서는 정확한 바이트 계산이 되지 않는다는 겁니다. (&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_length&quot;&gt;공식문서&lt;/a&gt;) 
관리자들이 작성한 메모는 대부분이 한글이기 때문에, varchar(4500)으로 해도 역시 똑같은 에러가 발생하며 insert 쿼리가 실패하게 됩니다.&lt;/p&gt;

&lt;p&gt;관리자들이 작성한 메모들중 가장 긴 메모의 진짜 길이를 알기 위해서는 다음과 같은 쿼리를 작성해야 했습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;CHARACTER_LENGTH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sender_account_sid&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;requested_system_sid&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/118342500/235295911-73a40bdf-ba02-45a1-af73-5bb0c474487a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;함수가 length에서 character_length로 바뀌었습니다. 이 함수가 문자의 수를 알려주는 함수입니다.
이제 content의 타입을 varchar(500)에서 varchar(7691) 이상으로 변경하고 insert 쿼리를 실행해보니 성공적으로 데이터 이관이 완료되었음을 확인할 수 있었습니다.&lt;/p&gt;

&lt;p&gt;최종적으로 실행된 DDL은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;DATETIME&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;CONSTRAINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo_ibfk_1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;CONSTRAINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo_ibfk_2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;FOREIGN&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;REFERENCES&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'관리자들이 정보를 공유하기 위해 수업신청서에 작성한 메모'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx_created_at&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;created_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recommendation_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recommendation_admin_memo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writer_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;최초에 생각했던 varchar(500)과는 큰 차이가 있는 수치이지만, 기존의 비정상적으로 긴 관리자 메모들을 제거하자니 혹시 모를 꺼림칙함이 있었습니다. 또한, text 타입을 사용하자니 문제가 발생했습니다.
text 타입은 기본적으로 char(16383)과 같기 때문에(중간과 큰 크기의 text는 더 큽니다) 실제 문자가 10개라면 이후를 모두 패딩처리하여 저장하므로 메모리가 과도하게 낭비될 수 있는 문제가 있고, 인덱싱이 제한되는 등의 문제가 발생할 수 있습니다.
그리고 데이터가 과하게 커지게 되면 off-page라고 하는 외부 공간에 저장할수도 있는 위험이 생기게 됩니다.&lt;/p&gt;

&lt;p&gt;결국 다른 선택지를 고를 수 없어, 난생 처음으로 varchar에 이렇게 큰 수치의 값을 적용해보는 것을 선택하게 되었습니다. 처음에는 정말로 이렇게 해도 되는 건지 의심스러웠지만, 결국 수행하게 되었습니다.&lt;/p&gt;

&lt;p&gt;또한, varchar 숫자의 의미와 length 함수의 맹점에 대해서 더 알아보고, 잘못 알고 있던 정보를 업데이트하게 된 계기가 되었습니다.&lt;/p&gt;
</description>
			<pubDate>Tue, 25 Apr 2023 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/backend/database/2023-04-25-db-4/</link>
			<guid isPermaLink="true">/backend/database/2023-04-25-db-4/</guid>
			
			
			<category>backend</category>
			
			<category>database</category>
			
		</item>
		
		<item>
			<title>모 기업 대표님의 파이낸셜 모델링에 대한 이야기를 듣고...</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#방문-기업의-상황&quot; id=&quot;markdown-toc-방문-기업의-상황&quot;&gt;방문 기업의 상황&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#직원들은-바보가-아니다&quot; id=&quot;markdown-toc-직원들은-바보가-아니다&quot;&gt;직원들은 바보가 아니다&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#제품-주도-성장&quot; id=&quot;markdown-toc-제품-주도-성장&quot;&gt;제품 주도 성장&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#항상-burn-rate와-roi에-대해-고민할-것&quot; id=&quot;markdown-toc-항상-burn-rate와-roi에-대해-고민할-것&quot;&gt;항상 Burn Rate와 ROI에 대해 고민할 것&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#단기적인-지표만을-위한-업무를-하지-말-것&quot; id=&quot;markdown-toc-단기적인-지표만을-위한-업무를-하지-말-것&quot;&gt;단기적인 지표만을 위한 업무를 하지 말 것&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#기본적으로-개인이-스스로-동기를-부여할-줄-알아야-한다&quot; id=&quot;markdown-toc-기본적으로-개인이-스스로-동기를-부여할-줄-알아야-한다&quot;&gt;기본적으로, 개인이 스스로 동기를 부여할 줄 알아야 한다.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;CTO님, 개발팀 인원 세명과 함께 모 기업에 방문했다. 이후 설탕 가득한 꽈배기를 집어먹으며 나누었던 이야기를 토대로 개인적으로 생각했던 내용들을 정리 및 기록한다. 
각 회사의 상황과 맥락이 다르니 다른 잘나가는(?) 회사의 방식이 무조건 옳다고 보기는 어렵다. 하지만 많은 내용이 공감되었다.&lt;/p&gt;

&lt;h2 id=&quot;방문-기업의-상황&quot;&gt;방문 기업의 상황&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;처음 몇달간 아예 제품을 개발하지 않고 기획과 VoC에만 집중했다.&lt;/li&gt;
  &lt;li&gt;어느정도 동기부여가 되어있는 소수 정예로 팀을 구성했다&lt;/li&gt;
  &lt;li&gt;팀에 회사의 지표를 투명하게 공개했다
    &lt;ul&gt;
      &lt;li&gt;내부 앱을 개발해 앱을 열면 회사의 런웨이가 얼마나 남았는지, ARR이 얼마나 늘었는지 등이 모두 한눈에 파악된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가장 근간이 되는 제품의 퀄리티에 가장 많이 투자했다
    &lt;ul&gt;
      &lt;li&gt;결과적으로 매출 원가가 약 20%내외로 아주 낮아 수익률이 굉장히 좋다&lt;/li&gt;
      &lt;li&gt;매출 원가가 낮아져 수익률이 증대되니 런웨이가 계속해서 늘어난다&lt;/li&gt;
      &lt;li&gt;회사에 돈이 많아지니 여유가 생겨 더 많은 시도를 해볼 수 있어졌다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수익을 직원들에게 공유한다
    &lt;ul&gt;
      &lt;li&gt;소수정예인 만큼 직원 한명 한명이 너무 소중하다&lt;/li&gt;
      &lt;li&gt;연봉, 복지등을 최대한 지원한다
        &lt;ul&gt;
          &lt;li&gt;ARR이 10% 증가했다면 전 직원들의 연봉을 10% 인상하고, 20%가 올랐다면 20% 인상한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;자진 퇴사율이 0%에 가깝고, 직원들의 사기가 매우 높다&lt;/li&gt;
      &lt;li&gt;직원들이 강한 동기와 회사의 제품이 내 제품이라는 오너십을 가진채 업무에 임한다
        &lt;ul&gt;
          &lt;li&gt;회식에서 메뉴 하나를 고를때조차도 이 메뉴하나 시키면 ARR 얼마다 라는식으로 생각하게 된다&lt;/li&gt;
          &lt;li&gt;회사의 ARR이 증대되면 본인들의 처우가 그대로 좋아지니 야근, 주말근무도 자발적이고 적극적으로 진행한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;선순환이 일어난다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;직원들은-바보가-아니다&quot;&gt;직원들은 바보가 아니다&lt;/h2&gt;
&lt;p&gt;회사의 상황을 투명하게 공개하고 모두의 동의를 이끌어내야한다. 헤게모니를 쥔다고 표현할 수 있겠다. 
특정 집단의 동의를 이끌어내 집단의 대변자가 된다면 그것은 강력한 힘이 된다. 
독일 국민들은 하나된 독일, 강한 독일을 원했고 히틀러는 독일 국민들의 이러한 염원과 지지를 얻어냈다.&lt;/p&gt;

&lt;p&gt;이러한 동의 없이 리드급 이상에서 모든 업무가 결정되고 진행된다면 리드급 미만의 직원들은 함께 일하고 있다는 느낌을 받기 어렵다.
그리고 이런 현상이 일어나기 시작하면 직원들의 사기와 동기는 점점 떨어질 것이다.&lt;/p&gt;

&lt;p&gt;엔젤 언저리일때 기업의 대표가 70% 이상의 지분을 들고 있어야 하는 이유를 다음과 같이 직원들에게 설명해보자.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;IPO까지 가기 위해 최소 5번 이상의 라운드를 거쳐야 한다&lt;/li&gt;
  &lt;li&gt;매 라운드마다 투자자들에게 10% 내외의 지분을 주어야 한다&lt;/li&gt;
  &lt;li&gt;IPO 직전까지 갔을 때 대표에게 남은 지분이 없다면 모럴헤저드가 일어나 IPO가 수월하게 진행되지 않을 수 있다&lt;/li&gt;
  &lt;li&gt;IPO가 되지 않는다면 결국 경영진, 직원, 투자자들 모두에게 좋을 게 없다&lt;/li&gt;
  &lt;li&gt;모두가 윈윈하려면 사공이 많아 더이상의 진척이 이뤄지지 않는 상황을 막기 위해 대표가 지분을 많이 들고 있어야 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;직원들이 이러한 맥락을 듣는다면 대표가 많은 지분을 들고 있다고 부정적으로 생각하는 사람이 과연 있을까?&lt;/p&gt;

&lt;h2 id=&quot;제품-주도-성장&quot;&gt;제품 주도 성장&lt;/h2&gt;
&lt;p&gt;가장 전통적인 마케팅은 세일즈맨이 직접 발로뛰며 영업을 하는것이었으나, 이제는 한계가 보이기 시작하고 있다. 영업과 운영에 인력이 많이 투입될수록 판관비로 인한 매출 원가가 높아져 결국 회사의 수익률이 떨어지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img width=&quot;1159&quot; alt=&quot;image&quot; src=&quot;https://user-images.githubusercontent.com/118342500/226691186-f8425e1b-df08-43a3-9c7f-590dd39b96b9.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제는 그냥 제품의 퀄리티가 너무 좋아 고객들이 자발적으로 지갑을 열기 시작하는것이 가장 이상적인 형태가 될 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어보자면, 직접 가게에 전화를 하거나 직접 가게로 가 테이크 아웃을 하면 배달비와 수수료가 더 저렴해지거나 아예 없어질수도 있음에도 불구하고 많은 고객들이 배달앱을 통해 주문을하고 배달료와 수수료를 지불한다. 
왜? 편하기 때문이다. 배달앱을 통해 배달주문을 하는것이 번거로웠다면 사람들은 요금을 지불하고 배달앱을 사용했을까?&lt;/p&gt;

&lt;p&gt;요즘 돌풍을 일으키고 있는 Chat-GPT를 보면 많은 사람들이 자발적으로 매월 20달러를 결제하고 Chat-GPT Plus로 업그레이드를 하고 있다. 
왜? 이 서비스에 돈을 지불할 가치가 충분하다고 느꼈기 때문이다. 
그리고 Chat-GPT를 사용해본 사람들은 주변 사람들에게 이를 권한다. 즉, 고객들의 입소문을 통해 영업과 마케팅이 진행된다.&lt;/p&gt;

&lt;p&gt;제품의 품질을 기반으로 유입과 리텐션이 일어나면 원가가 최적화된다.&lt;/p&gt;

&lt;h2 id=&quot;항상-burn-rate와-roi에-대해-고민할-것&quot;&gt;항상 Burn Rate와 ROI에 대해 고민할 것&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://www.theteams.kr/teams/1014/post/64775&quot;&gt;성공하는 스타트업은 “번 레이트(Burn Rate)”에 예민하다.&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;개발자는 기본적으로 회사에서 개발 업무를 하지만, 그 근본은 비즈니스다. 
그리고 비즈니스는 항상 Cost vs Benefit이다. 개발자의 인건비, 서버비, 사무실 임대료 등 그냥 시간이 흐르는 것만으로도 회사는 막대한 비용을 지불하고 있다.&lt;/p&gt;

&lt;p&gt;한 팀에 연봉 3천만원을 받는 직원이 5명 있으면, 아무것도 하지 않고 하루가 지나는 것 만으로 회사는 하루에 약 52만 원 정도의 지출을 하는 셈이다. 
이런 상황에서 어떠한 기능 하나를 개발하기 위해 5일이 걸렸다면 회사는 약 260만원+@의 비용을 지불한 셈이다. 
이렇게 막대한 비용을 들여 기능을 개발했는데 막상 돈은 벌리지 않고, 오히려 해당 기능을 유지보수하기 위해  소중한 인력과 시간이 투입되기 시작하면 손실은 배가되기 시작한다.&lt;/p&gt;

&lt;p&gt;그러니까, 때로는 기능을 개발하지 않는 게 더 이득일 때도 있다.&lt;/p&gt;

&lt;p&gt;ROI를 아주 쉽게 풀어 얘기하면 어떤 업무를 진행했을 때 이 업무의 결과가 과연 우리의 인건비라도 건져줄 수 있는지를 따져보는 것이다.&lt;/p&gt;

&lt;p&gt;새로운 수익 아이템을 찾는 것도 물론 매우 중요하지만, 회사의 근간이 되는 제품의 PMF를 먼저 찾고, 그것을 기반으로 수익을 창출하는 것이 스타트업에게는 더 중요하다. 
즉, 스타트업에는 아주 잘 만들어진 제품 하나가 가장 중요하다.&lt;/p&gt;

&lt;p&gt;기본이 없는 상태에서 계속 새로운 시도를 해 돈이 부족해지기 시작하면 여유가 없어지고, 여유가 없어지면 올바른 판단을 내리기 어려워진다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://brunch.co.kr/@kyugeng/46&quot;&gt;13명의 직원, 1조 원의 가치&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;단기적인-지표만을-위한-업무를-하지-말-것&quot;&gt;단기적인 지표만을 위한 업무를 하지 말 것&lt;/h2&gt;
&lt;p&gt;기준금리가 낮아 시장에 돈이 많이 풀려있었던 최근까지의 시장의 룰은 규모의 경제였다. 
막대한 자금을 집행해 매출을 크게 일으키면 더 많은 투자를 받는다. 
그리고 다시 모든 자금을 사업에 재 투자하여 더 큰 매출을 일으키고, 다시 더 큰 투자를 받는다. 
이를 반복하며 회사의 몸집을 키우고 BEP를 넘긴다. 
성공하면 IPO를 진행한다.&lt;/p&gt;

&lt;p&gt;유니콘이라 불리던 몇몇 기업들은 이러한 방식을 통해 막차를 타는데 성공했다. 하지만 기준금리가 급격하게 오르며 시장의 룰이 바뀌었고, 이제는 투자를 받기 위해서는 실질적인 영업이익을 내고 있는지가 중요해졌다. 그리고 역시 유니콘이라 불리던 몇몇 회사들은 막차를 놓친 상황이기도 하다.&lt;/p&gt;

&lt;p&gt;하지만 역설적으로 시장의 룰이 바뀌었으므로 변경 된 룰에 적응해내는 기업들은 더 큰 기회를 얻을 수 있는 상황이다. 이제는 개인과 기업 모두 옥석가리기에 들어갔다.&lt;/p&gt;

&lt;p&gt;이러한 상황에 굳이 지표를 보고 일을 한다면, 회사의 모든 구성원이 최종적으로 집중해야 할 지표는 이제는 매출이 아닌 영업이익이다.
예를 들자면 마케팅팀이 매출을 KPI로 정하고 업무를 진행한다고 가정해보자. 
매출은 비용+이익이므로 비용에 해당하는 마케팅비를 크게 집행하면 매출이 당연히 증대된다. 
하지만 근본적으로 영업이익이 늘어날까? 마케팅비를 줄이면 그 즉시 매출이 떨어질 것이다. 
이러면 마케팅팀은 KPI를 쉽게 달성할 수 있을것이나, 회사 차원에서 보면 이는 유의미한 이득이 되기 어렵다.&lt;/p&gt;

&lt;p&gt;즉, 목표와 이니셔티브가 건강한지 고민해봐야 한다.&lt;/p&gt;

&lt;h2 id=&quot;기본적으로-개인이-스스로-동기를-부여할-줄-알아야-한다&quot;&gt;기본적으로, 개인이 스스로 동기를 부여할 줄 알아야 한다.&lt;/h2&gt;

&lt;p&gt;경영진이 직원들에게 동기부여를 제공하는 것도 한계가 있기 때문에, 임직원들은 개개인이 확실한 목표를 가지고 자발적인 동기부여를 발휘해야 한다. 
“회사가 더 많은 연봉을 주면 더 열심히 일하겠다”가 아니라 “내가 성장하고 성과를 달성했기 때문에 회사는 나에게 더 투자해야 한다”는 마음가짐이 필요하다.&lt;/p&gt;

&lt;p&gt;회사가 나를 연봉 3천만원에 고용했다면, 회사는 내가 1년 동안 3천만원 이상의 이익을 가져다 줄 것을 바랄 것이다. 
그렇지 않다면, 회사는 나를 고용할 이유가 없다. 
연봉이 오르면, 회사의 기대치도 높아진다. 
대부분의 초년생과 일부 경력직들은 이러한 맥락을 이해하지 못한 채, 회사에 입사하여 높은 연봉만을 원한다. 
이런 태도로 스타트업에 입사한다면, 상황이 악화되고, 조직 구조가 조금이라도 변화할 때 구조조정의 대상이 될 가능성이 높아진다.&lt;/p&gt;

&lt;p&gt;단순히 돈을 받기 위해 회사를 다니고, 상급자로부터 받은 업무만 처리하는 업무 방식은 스타트업에 적합하지 않다. 
이런 방식은 공무원, 공기업, 은행, 대기업과 같은 보수적인 조직에 어울린다. 
스타트업에 있을 때는 나이, 직급, 직책, 경력, 실력 등에 연연하지 않고 적극적으로 아이디어를 제시하고 주도해야 한다. 
프로페셔널이 되어야 한다. 나의 마음가짐, 실력, 성과가 인정되면 연봉, 스톡옵션, 대우가 따라올 것이다. 
단지 경력만 쌓아서 처우가 좋아지길 원한다면, 호봉제를 실시하는 회사로 가는 것이 좋다. 
이런 맥락을 모르고 스타트업에 입사한다면 처우에 대한 기대는 포기하는 것이 좋다.&lt;/p&gt;

&lt;p&gt;스타트업의 가장 큰 장단점 중 하나는 규모가 작고 조직 구조가 명확하지 않다는 것이다(속된말로 체계가 없다). 
역설적으로 이런 특성 덕분에 원하는 일을 자유롭게 할 수 있으며, 수행한 일의 영향이 명확하게 보이고, 그에 대한 피드백이 즉시 이루어진다는 장점도 있다. 
능동적이고 주도적으로 일하는 사람들에게는 이러한 환경이 적합할 수 있다.&lt;/p&gt;

&lt;p&gt;솔직히 말하면, 스타트업의 연봉과 복지 등은 대기업에 비해 상대적으로 떨어지는 부분이 많다는 것이 사실이다. 
그러나 급격하게 성장하는 기업에서만 얻을 수 있는 경험, 시장에 대한 통찰력과 민첩함, 그리고 더 나은 미래를 위한 노력이라는 가치를 얻을 수 있다. 
그리고 만약 정말 성공한다면, 스톡옵션을 통해 상당한 차익을 얻을 수도 있다(비록 낮은 확률이지만!). 
이것이 바로 내가 생각하는 스타트업의 가장 큰 장점들이다.&lt;/p&gt;

&lt;p&gt;스타트업에서 일하는 동안에는 시장 상황에 주목하면서, 각자가 스타트업에서 얻고자 하는 것이 무엇인지 명확한 목적과 명확한 목표를 세워야 한다. 
그리고 그 목표를 달성하기 위해 강력한 동기부여를 갖춘 채 끊임없이 노력해야 한다.&lt;/p&gt;
</description>
			<pubDate>Fri, 17 Mar 2023 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2023-03-17-diary-50/</link>
			<guid isPermaLink="true">/diary/2023-03-17-diary-50/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>좋은 코드, 나쁜 코드</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-1-코드-품질&quot; id=&quot;markdown-toc-chapter-1-코드-품질&quot;&gt;Chapter 1. 코드 품질&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#코드-품질의-핵심-요소&quot; id=&quot;markdown-toc-코드-품질의-핵심-요소&quot;&gt;코드 품질의 핵심 요소&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드는-읽기-쉬워야-한다&quot; id=&quot;markdown-toc-코드는-읽기-쉬워야-한다&quot;&gt;코드는 읽기 쉬워야 한다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드는-예측-가능해야-한다&quot; id=&quot;markdown-toc-코드는-예측-가능해야-한다&quot;&gt;코드는 예측 가능해야 한다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드를-오용하기-어렵게-만들라&quot; id=&quot;markdown-toc-코드를-오용하기-어렵게-만들라&quot;&gt;코드를 오용하기 어렵게 만들라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드를-모듈화하라&quot; id=&quot;markdown-toc-코드를-모듈화하라&quot;&gt;코드를 모듈화하라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드를-재사용-가능하고-일반화할-수-있게-작성하라&quot; id=&quot;markdown-toc-코드를-재사용-가능하고-일반화할-수-있게-작성하라&quot;&gt;코드를 재사용 가능하고 일반화할 수 있게 작성하라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#테스트가-용이한-코드를-작성하고-제대로-테스트하라&quot; id=&quot;markdown-toc-테스트가-용이한-코드를-작성하고-제대로-테스트하라&quot;&gt;테스트가 용이한 코드를 작성하고, 제대로 테스트하라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#고품질-코드-작성은-일정을-지연시키는가-&quot; id=&quot;markdown-toc-고품질-코드-작성은-일정을-지연시키는가-&quot;&gt;고품질 코드 작성은 일정을 지연시키는가 ?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-2-추상화-계층&quot; id=&quot;markdown-toc-chapter-2-추상화-계층&quot;&gt;Chapter 2. 추상화 계층&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#인터페이스를-통해-패키지의-의존성을-관리하는-예&quot; id=&quot;markdown-toc-인터페이스를-통해-패키지의-의존성을-관리하는-예&quot;&gt;인터페이스를 통해 패키지의 의존성을 관리하는 예&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#클래스-레벨에서-추상화를-구현&quot; id=&quot;markdown-toc-클래스-레벨에서-추상화를-구현&quot;&gt;클래스 레벨에서 추상화를 구현&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#함수는-한-가지-일만-해야-한다&quot; id=&quot;markdown-toc-함수는-한-가지-일만-해야-한다&quot;&gt;함수는 한 가지 일만 해야 한다&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-3-다른-개발자와-코드-계약&quot; id=&quot;markdown-toc-chapter-3-다른-개발자와-코드-계약&quot;&gt;Chapter 3. 다른 개발자와 코드 계약&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#자신에게-분명하다고-해서-다른-사람에게도-분명한-것은-아니다&quot; id=&quot;markdown-toc-자신에게-분명하다고-해서-다른-사람에게도-분명한-것은-아니다&quot;&gt;자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#다른-개발자는-무의식중에-여러분의-코드를-망가뜨릴-수-있다&quot; id=&quot;markdown-toc-다른-개발자는-무의식중에-여러분의-코드를-망가뜨릴-수-있다&quot;&gt;다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#시간이-지나면-자신의-코드를-기억하지-못한다&quot; id=&quot;markdown-toc-시간이-지나면-자신의-코드를-기억하지-못한다&quot;&gt;시간이 지나면 자신의 코드를 기억하지 못한다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드-계약&quot; id=&quot;markdown-toc-코드-계약&quot;&gt;코드 계약&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-4-오류&quot; id=&quot;markdown-toc-chapter-4-오류&quot;&gt;Chapter 4. 오류&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#복구-가능한-오류&quot; id=&quot;markdown-toc-복구-가능한-오류&quot;&gt;복구 가능한 오류&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#실패는-빠르고-요란할수록-좋다&quot; id=&quot;markdown-toc-실패는-빠르고-요란할수록-좋다&quot;&gt;실패는 빠르고, 요란할수록 좋다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#오류-처리는-고수준에서-한다&quot; id=&quot;markdown-toc-오류-처리는-고수준에서-한다&quot;&gt;오류 처리는 고수준에서 한다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#오류를-먹지-마라&quot; id=&quot;markdown-toc-오류를-먹지-마라&quot;&gt;오류를 먹지 마라&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-5-가독성-높은-코드를-작성하라&quot; id=&quot;markdown-toc-chapter-5-가독성-높은-코드를-작성하라&quot;&gt;Chapter 5. 가독성 높은 코드를 작성하라&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#서술적이지-않은-이름은-코드를-읽기-어렵게-만든다&quot; id=&quot;markdown-toc-서술적이지-않은-이름은-코드를-읽기-어렵게-만든다&quot;&gt;서술적이지 않은 이름은 코드를 읽기 어렵게 만든다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#적절한-주석문을-사용하는게-좋다&quot; id=&quot;markdown-toc-적절한-주석문을-사용하는게-좋다&quot;&gt;적절한 주석문을 사용하는게 좋다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드-라인이-짧고-간결하다고-좋은-코드는-아니다&quot; id=&quot;markdown-toc-코드-라인이-짧고-간결하다고-좋은-코드는-아니다&quot;&gt;코드 라인이 짧고 간결하다고 좋은 코드는 아니다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#일관된-코딩-스타일을-고수해라&quot; id=&quot;markdown-toc-일관된-코딩-스타일을-고수해라&quot;&gt;일관된 코딩 스타일을 고수해라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#언어의-새로운-기능을-적절하게-활용해라&quot; id=&quot;markdown-toc-언어의-새로운-기능을-적절하게-활용해라&quot;&gt;언어의 새로운 기능을 적절하게 활용해라&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-6-예측-가능한-코드를-작성하라&quot; id=&quot;markdown-toc-chapter-6-예측-가능한-코드를-작성하라&quot;&gt;Chapter 6. 예측 가능한 코드를 작성하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-7-코드를-오용하기-어렵게-만들라&quot; id=&quot;markdown-toc-chapter-7-코드를-오용하기-어렵게-만들라&quot;&gt;Chapter 7. 코드를 오용하기 어렵게 만들라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-8-코드를-모듈화하라&quot; id=&quot;markdown-toc-chapter-8-코드를-모듈화하라&quot;&gt;Chapter 8. 코드를 모듈화하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-9-코드를-재사용하고-일반화할-수-있도록-해라&quot; id=&quot;markdown-toc-chapter-9-코드를-재사용하고-일반화할-수-있도록-해라&quot;&gt;Chapter 9. 코드를 재사용하고 일반화할 수 있도록 해라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-10-단위-테스트의-원칙&quot; id=&quot;markdown-toc-chapter-10-단위-테스트의-원칙&quot;&gt;Chapter 10. 단위 테스트의 원칙&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#블랙박스-테스트&quot; id=&quot;markdown-toc-블랙박스-테스트&quot;&gt;블랙박스 테스트&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#테스트-더블&quot; id=&quot;markdown-toc-테스트-더블&quot;&gt;테스트 더블&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#좋은-단위-테스트는-어떻게-작성-할-수-있는가&quot; id=&quot;markdown-toc-좋은-단위-테스트는-어떻게-작성-할-수-있는가&quot;&gt;좋은 단위 테스트는 어떻게 작성 할 수 있는가?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#chapter-11-단위-테스트의-실제&quot; id=&quot;markdown-toc-chapter-11-단위-테스트의-실제&quot;&gt;Chapter 11. 단위 테스트의 실제&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#기능뿐만-아니라-동작을-시험하라&quot; id=&quot;markdown-toc-기능뿐만-아니라-동작을-시험하라&quot;&gt;기능뿐만 아니라 동작을 시험하라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#테스트만을-위해-퍼블릭으로-만들지-말라&quot; id=&quot;markdown-toc-테스트만을-위해-퍼블릭으로-만들지-말라&quot;&gt;테스트만을 위해 퍼블릭으로 만들지 말라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#퍼블릭-api를-통해-테스트하라&quot; id=&quot;markdown-toc-퍼블릭-api를-통해-테스트하라&quot;&gt;퍼블릭 API를 통해 테스트하라&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#코드를-더-작은-단위로-분할하라&quot; id=&quot;markdown-toc-코드를-더-작은-단위로-분할하라&quot;&gt;코드를 더 작은 단위로 분할하라&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-1-코드-품질&quot;&gt;Chapter 1. 코드 품질&lt;/h2&gt;

&lt;h3 id=&quot;코드-품질의-핵심-요소&quot;&gt;코드 품질의 핵심 요소&lt;/h3&gt;

&lt;p&gt;엔지니어들이 코드를 작성할 때 내리는 일상적인 결정은 그것만 보면 작고 때로는 보잘것없어 보일 수도 있지만, 좋은 소프트웨어인지 그렇지 않은지는 그 모든 작은 결정들이 모여서 이루어진다&lt;/p&gt;

&lt;h3 id=&quot;코드는-읽기-쉬워야-한다&quot;&gt;코드는 읽기 쉬워야 한다&lt;/h3&gt;

&lt;p&gt;코드의 가독성이 떨어진다면 다른 개발자가 그 코드를 이해하는데 많은 시간을 들여야 한다. 또한 코드의 기능에 대해 잘못 이해하거나 몇 가지 중요한 세부 사항을 놓칠 가능성 역시 크다&lt;/p&gt;

&lt;h3 id=&quot;코드는-예측-가능해야-한다&quot;&gt;코드는 예측 가능해야 한다&lt;/h3&gt;

&lt;p&gt;함수 이름이 A를 읽는다 라면 그 함수는 정말 A를 읽는 일만 해야 한다&lt;/p&gt;

&lt;h3 id=&quot;코드를-오용하기-어렵게-만들라&quot;&gt;코드를 오용하기 어렵게 만들라&lt;/h3&gt;

&lt;p&gt;TV 제조업체들은 HDMI 소켓에 전원 코드를 꽂지 못하도록 HDMI 소켓과 전원 코드의 모양이 서로 다르도록 만든다&lt;/p&gt;

&lt;p&gt;근데 언어 자체가 타입을 강제하지 못한다면 이 문제는 어떻게 해결할 것인가 ? 🤔&lt;/p&gt;

&lt;h3 id=&quot;코드를-모듈화하라&quot;&gt;코드를 모듈화하라&lt;/h3&gt;

&lt;p&gt;코드가 잘 모듈화되어 있다면 코드를 재사용하기 쉬워지고, 코드의 유연성이 극대화된다. 이는 곧 요구사항의 변경에 민첩하게 대응할 수 있다는 말과 같다.&lt;/p&gt;

&lt;h3 id=&quot;코드를-재사용-가능하고-일반화할-수-있게-작성하라&quot;&gt;코드를 재사용 가능하고 일반화할 수 있게 작성하라&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;재사용성(reusablility): 어떤 문제를 해결하기 위한 무언가가 여러 가지 다른 상황에서도 사용될 수 있음을 의미한다. 핸드 드릴은 벽, 바닥 판 및 천장에 구멍을 뚫는데 사용할 수 있기 때문에 재사용 가능한 도구다. 문제는 동일하지만(드릴로 구멍을 뚫어야 한다), 상황은 다르다(벽을 뚫는 것과 바닥을 뚫는 것과 천장을 뚫는 것)&lt;/li&gt;
  &lt;li&gt;일반화성(generalizability): 개념적으로는 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미한다. 핸드 드릴은 구멍을 뚫는 데 사용될 뿐만 아니라 나사를 박을 때도 사용될 수 있어서 일반화성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;테스트가-용이한-코드를-작성하고-제대로-테스트하라&quot;&gt;테스트가 용이한 코드를 작성하고, 제대로 테스트하라&lt;/h3&gt;

&lt;p&gt;테스트 코드가 필요한 이유는 다음과 같다&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;버그나 제대로 동작하지 않는 기능을 갖는 코드가 코드베이스에 병합되지 않도록 방지&lt;/li&gt;
  &lt;li&gt;버그나 제대로 동작하지 않는 기능을 갖는 코드가 배포되지 않도록 막고 서비스 환경에서 실행되지 않도록 보장&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;고품질-코드-작성은-일정을-지연시키는가-&quot;&gt;고품질 코드 작성은 일정을 지연시키는가 ?&lt;/h3&gt;

&lt;p&gt;단기적으로는 고품질의 코드를 작성하기 위해 시간이 더 걸릴수 있다. 하지만 고품질 코드를 계속 작성해나간다면 중장기적으로는 개발 시간을 단축시켜준다.&lt;/p&gt;

&lt;h2 id=&quot;chapter-2-추상화-계층&quot;&gt;Chapter 2. 추상화 계층&lt;/h2&gt;

&lt;h3 id=&quot;인터페이스를-통해-패키지의-의존성을-관리하는-예&quot;&gt;인터페이스를 통해 패키지의 의존성을 관리하는 예&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/226674031-5e964ea2-fe6f-4aba-8505-40919f274230.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;클래스-레벨에서-추상화를-구현&quot;&gt;클래스 레벨에서 추상화를 구현&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/226674231-56e936b3-bdd6-402f-9330-ed43f722db0f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;함수는-한-가지-일만-해야-한다&quot;&gt;함수는 한 가지 일만 해야 한다&lt;/h3&gt;

&lt;p&gt;함수가 한 가지 일만 하기 어렵다면 더 큰 개념으로 추상화하고 함수로 구현한다. 상위 개념의 추상화는 하위 개념의 여러 추상화로 이루어진다.
예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;라면을 끓인다&lt;/code&gt;의 하위 개념은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;물을 끓인다&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;라면을 넣는다&lt;/code&gt;이다. 그리고 이 두 개념은 역시 또 다시 하위 개념으로 나뉠 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;chapter-3-다른-개발자와-코드-계약&quot;&gt;Chapter 3. 다른 개발자와 코드 계약&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/226674718-31364d2d-0dd2-47e3-b7a2-01ad5ef446f1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;자신에게-분명하다고-해서-다른-사람에게도-분명한-것은-아니다&quot;&gt;자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다&lt;/h3&gt;

&lt;p&gt;다른 개발자가 작성한 코드와 상호작용하거나, 코드를 변경하거나, 의존하고 있는 코드를 변경할 수 있다는 것을 기억해야 한다. 코드를 작성할 당시에 너무도 분명해 보였던 것들이 그들에게는 분명하지 않을 것이다.&lt;/p&gt;

&lt;h3 id=&quot;다른-개발자는-무의식중에-여러분의-코드를-망가뜨릴-수-있다&quot;&gt;다른 개발자는 무의식중에 여러분의 코드를 망가뜨릴 수 있다&lt;/h3&gt;

&lt;p&gt;작성한 코드는 다른 코드로부터 전혀 영향을 받지 않은 채 독립적으로 있는 것이 아니라, 끊임없이 변화하는 코드 위에 놓여 있고, 여러분의 코드를 기반으로 계속해서 변화하는 코드 역시 끊임없이 작성된다. 
코드 베이스가 작동되지 않거나 오용되는 결과를 막기 위해서 코드 컴파일이 중지되거나 테스트가 실패하도록 만든다.&lt;/p&gt;

&lt;h3 id=&quot;시간이-지나면-자신의-코드를-기억하지-못한다&quot;&gt;시간이 지나면 자신의 코드를 기억하지 못한다&lt;/h3&gt;

&lt;p&gt;배경지식이 거의 없거나 전혀 없는 사람에게도 자신의 코드가 이해하기 쉬워야 하고 잘 작동하던 코드에 버그가 발생하는 것이 어려워야 한다.&lt;/p&gt;

&lt;h3 id=&quot;코드-계약&quot;&gt;코드 계약&lt;/h3&gt;

&lt;p&gt;서로 다른 코드 간의 상호작용을 마치 계약처럼 생각한다. 어떤 코드를 호출하는 코드는 특정 요건을 충족해야 하며 호출되는 코드는 원하는 값을 반환하거나 일부 상태를 수정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선결 조건: 코드를 호출하기 전에 사실이어야 하는 것&lt;/li&gt;
  &lt;li&gt;사후 조건: 코드가 호출된 후에 사실이어야 하는 것&lt;/li&gt;
  &lt;li&gt;불변 사항: 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-4-오류&quot;&gt;Chapter 4. 오류&lt;/h2&gt;

&lt;h3 id=&quot;복구-가능한-오류&quot;&gt;복구 가능한 오류&lt;/h3&gt;

&lt;p&gt;많은 소프트웨어 오류는 치명적이지 않으며, 오류가 발생하더라도 사용자는 알아채지 못하도록 적절하게 처리한다면 작동을 계속할 수 있는 합리적인 방법이 있다. 
한 가지 예로 사용자가 잘못된 입력을 제공하는 경우가 있다. 
예를 들어 사용자가 유효하지 않은 전화번호를 입력할 때 저장되지 않은 이전의 작업들을 잃어버리면서 전체 시스템이 작동을 멈춘다면 훌륭한 사용자 경험은 아니다. 대신 사용자에게 전화번호가 유효하지 않다는 오류 메시지를 제공하고 올바른 번호를 입력하도록 재요청하는 것이 더 낫다.&lt;/p&gt;

&lt;h3 id=&quot;실패는-빠르고-요란할수록-좋다&quot;&gt;실패는 빠르고, 요란할수록 좋다&lt;/h3&gt;

&lt;p&gt;복구할 수 없는 오류도 존재한다. 예를 들자면 개발자가 코드를 명확하게 잘못 작성한 경우를 들 수 있다. 
이러한 경우는 절대적으로 코드를 수정하여 다시 배포를 해야만 하는데, 이러한 오류로 인한 피해를 최소화 하기 위해서는 최대한 빠르게 코드가 수정되고 배포가 진행되어야만 한다. 
빠르게 실패하고 최대한 요란하게 실패할수록 이러한 문제들이 빨리 발견될 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빠르게 실패
    &lt;ul&gt;
      &lt;li&gt;빠르게 실패할수록 실패 위치가 원인에서 가까워진다. 느리게 실패한다면 실질적으로 문제가 되는 코드보다 수백라인 이후, 아예 다른 코드 파일에서 실패가 발생할 수 있다. 이러면 근본 원인을 찾는게 더 어려워진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;요란하게 실패
    &lt;ul&gt;
      &lt;li&gt;극단적인 예이지만, 실패하는 순간 애플리케이션이 작동을 멈춰버린다면 그 누구라도 뭔가 문제가 생겼다는 것을 인지할 수 있을 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;오류-처리는-고수준에서-한다&quot;&gt;오류 처리는 고수준에서 한다&lt;/h3&gt;

&lt;p&gt;예를 들어 사용자가 웹 페이지에서 전화번호를 입력했다고 가정하면, 웹 페이지는 서버로 전화번호를 보낼 것이고, 서버는 전화번호의 유효성 검사를 진행할 것이다. 
이때 전화번호가 유효하지 않다면 서버는 어떤 결과를 응답해주어야 할까? 서버에서 이러한 잘못된 입력을 자체적으로 처리하기는 불가능하다.
서버에서 할 수 있는 최선은 입력된 전화번호가 유효하지 않다는 응답을 보내주고, 웹 페이지에서 전화번호를 다시 입력하라는 UI를 노출시키는게 합리적일것이다.
이렇게 저수준에서는 고수준으로 예외를 던지고, 고수준에서 예외처리를 진행하는게 좋다.&lt;/p&gt;

&lt;h3 id=&quot;오류를-먹지-마라&quot;&gt;오류를 먹지 마라&lt;/h3&gt;

&lt;p&gt;다음과 같은 코드가 있다. 무엇이 문제인가?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// do nothing&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;최상위 예외인 Exception을 통해 예외를 받으므로 저수준에서 정확히 어떤 예외가 발생하는지 명확하지 않다.&lt;/li&gt;
  &lt;li&gt;예외를 잡았으나, 아무런 처리도 하지 않고 있다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이런 코드가 있다면 로그가 없기 때문에 예외가 발생했을 때 어떤 문제가 발생했는지 인지하는것조차 어려우며, 어떻게 어떻게 문제를 인지하더라도 이후 어떤 처리들이 진행될지 명확하지 않다.&lt;/p&gt;

&lt;p&gt;위의 코드를 개선하면 다음과 같을 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IllegalArgumentException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;IOException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;chapter-5-가독성-높은-코드를-작성하라&quot;&gt;Chapter 5. 가독성 높은 코드를 작성하라&lt;/h2&gt;

&lt;h3 id=&quot;서술적이지-않은-이름은-코드를-읽기-어렵게-만든다&quot;&gt;서술적이지 않은 이름은 코드를 읽기 어렵게 만든다&lt;/h3&gt;

&lt;p&gt;변수나 함수등의 이름을 지을 때 서술적인 이름을 짓기 위한 노력을 충분히 기울이지 않는다면 코드가 어떻게 보일지 보여주는 다소 극단적인 예다. 
다음 코드를 30초정도 살펴보고 이 코드가 무슨일을 하고 있는지 맞춰보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    
    &lt;span class=&quot;nc&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;nc&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;적절한-주석문을-사용하는게-좋다&quot;&gt;적절한 주석문을 사용하는게 좋다&lt;/h3&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// &quot;{이름}.{성}&quot;의 형태로 ID를 생성한다&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;${firstName}.${lastName}&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 주석문이 유의미한가? 이미 함수 시그니처와 함수의 세부 구현으로 모든게 명확하게 설명되고 있다고 생각되지 않는가? 
주석이 없다면 코드가 잘 이해되지 않는지 주석을 지우고 다시 보자.&lt;/p&gt;

&lt;div class=&quot;language-kotlin highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generateId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;firstName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lastName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;${firstName}.${lastName}&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반대로 주석이 유용한 경우도 확실히 존재한다.&lt;/p&gt;

&lt;p&gt;아래의 코드는 어떤 객체의 유효시간을 의미한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EXPIRY_TIME_IN_MS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;691200000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변수명을 통해 단위가 ms임을 명시하긴 하였으나 691,200,200이 정확히 앞으로 얼마의 시간동안 유효한지가 직관적으로 떠오르지 않는다. 일단 가독성을 좋게 하기 위해 다음과 같은 절차들을 밟을 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EXPIRY_TIME_IN_MS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;691_200_000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 3자리 단위로 끊어볼 수 있다. 하지만 여전히 얼마의 시간인지는 명확하지 않다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EXPIRY_TIME_IN_MS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1_000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 단위를 구분지어 표현할수도 있다. 이 경우엔 상당히 명확해진다. 1,000ms는 1초이며, 60초는 1분, 60분은 1시간, 24시간은 하루이므로 위의 691,200,00ms 라는 값이 총 8일을 의미함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;그래도 여전히 개발자가 코드를 보며 계산을 하기는 해야 한다. 다음과 같다면 어떨까?&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;EXPIRY_TIME_IN_MS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1_000&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 8 days&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이외에도 해당 코드가 작성되어야만 했던 맥락이 담긴 문서등은 주석으로 작성할 가치가 충분하다. 
이렇게 가독성 높은 코드와 함께 적절히 사용된 주석은 분명 유의미한 가치가 있다. 
하지만 근본적으로 주석문만으로 가독성 높은 코드를 대체할수는 없다.&lt;/p&gt;

&lt;h3 id=&quot;코드-라인이-짧고-간결하다고-좋은-코드는-아니다&quot;&gt;코드 라인이 짧고 간결하다고 좋은 코드는 아니다&lt;/h3&gt;

&lt;p&gt;다음의 간결한 코드가 정확히 어떤것을 하고 있는지 파악해보자.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;isIdValid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;UInt16&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;countSetBits&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7FFF&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드라인이 한줄밖에 되지 않는 간결한 함수다. 파악이 되는가?
대부분의 개발자가 위 함수가 어떤것을 하고 있는지 제대로 파악하지 못할거라 생각한다. 
대부분의 코드는 작성되는 시간보다 이후 읽히는 시간이 압도적으로 많기 때문에, 가독성을 위해 코드 라인이 길어지는게 오히려 더 좋은 경우가 많다. (단, 컴퓨팅 리소스가 한정된 상황에서 개발을 진행하고 있다면 이 조언이 맞지 않을 수 있다. (예: 임베디드 프로그래밍 등))&lt;/p&gt;

&lt;h3 id=&quot;일관된-코딩-스타일을-고수해라&quot;&gt;일관된 코딩 스타일을 고수해라&lt;/h3&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GroupChat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connectionManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;terminateAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 코드가 실패했다. 이유가 무엇일까?
위 코드를 보는 대부분의 자바개발자는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;connectionManager&lt;/code&gt; 가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GroupChat&lt;/code&gt;의 인스턴스 변수일것으로 예상했을 것이다. 
하지만 실제로 connectionManager는 클래스였으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terminateAll()&lt;/code&gt;은 connectionManager의 static 함수였다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;connectionManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;terminateAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이와 같이 절대 다수의 개발자들이 준수하고 있는 특정 생태계의 스타일 가이드를 따르는것은 매우 중요하다. 
다른 개발자들이 동의하고 따르고 있는 스타일 가이드를 지키지 않고 혼자 다른 스타일의 코드를 작성한다면 다른 개발자들에게 혼동을 줄 여지가 매우 높다.
모든 사람들이 하늘에 떠있는 해를 바라보며 해라고 부르는데, 혼자 달이라고 부른다면 다른 사람들과의 의사소통에 많은 문제가 생기지 않을까?&lt;/p&gt;

&lt;h3 id=&quot;언어의-새로운-기능을-적절하게-활용해라&quot;&gt;언어의 새로운 기능을 적절하게 활용해라&lt;/h3&gt;

&lt;p&gt;다음 코드는 문자열 리스트를 입력받아 빈 문자를 걸러내는 작업을 수행하는 전통적인 자바 함수이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNoneEmptyStrings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonEmptyStrings&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isBlank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nonEmptyStrings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nonEmptyStrings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바8부터 도입된 람다와 스트림 API를 사용한다면 다음과 같이 간결하고 직관적이게 표현할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getNoneEmptyStrings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;stream&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isBlank&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
           &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Collectors&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;새로운 기능들은 코드를 더 유지보수하기 쉽게 개발하는데 큰 도움을 줄 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;chapter-6-예측-가능한-코드를-작성하라&quot;&gt;Chapter 6. 예측 가능한 코드를 작성하라&lt;/h2&gt;

&lt;p&gt;다른 개발자가 작성하는 코드는 종종 우리가 작성하는 코드에 의존한다. 
다른 개발자가 우리 코드의 기능을 잘못 해석하거나 처리해야 하는 특수한 경우를 발견하지 못하면, 우리가 작성한 코드에 기반한 그 코드에서 버그가 발생할 가능성이 크다. 
코드를 호출하는 쪽에서 예상한대로 동작하기 위한 좋은 방법 중 하나는 중요한 세부 사항이 코드 계약의 명백한 부분에 포함되도록 하는 것이다.&lt;/p&gt;

&lt;p&gt;우리가 사용하는 코드에 대해 허술하게 가정을 하면 예상을 벗어나는 또 다른 결과를 볼 수 있다.
예를 들어 열거형에 추가되는 새 값을 예상하지 못한 경우다.
의존해서 사용 중인 코드가 가정을 벗어날 경우, 코드 컴파일을 중지하거나 테스트가 실패하도록 하는 것이 중요하다.&lt;/p&gt;

&lt;p&gt;테스트만으로는 예측을 벗어나는 코드의 문제를 해결할 수 없다. 
다른 개발자가 코드를 잘못 해석하면 테스트해야 할 시나리오도 잘못 이해할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;chapter-7-코드를-오용하기-어렵게-만들라&quot;&gt;Chapter 7. 코드를 오용하기 어렵게 만들라&lt;/h2&gt;

&lt;p&gt;코드가 오용되기 쉽게 작성되고 나면 어느 시점에선가는 오용될 가능성이 크고 이것은 버그로 이어질 수 있다.&lt;/p&gt;

&lt;p&gt;코드가 오용되는 몇 가지 일반적인 사례는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;호출하는 쪽에서 잘못된 입력을 제공&lt;/li&gt;
  &lt;li&gt;다른 코드에서 일어나는 부수 효과&lt;/li&gt;
  &lt;li&gt;함수 호출 시점이 잘못되거나 올바른 순서로 호출되지 않은 경우&lt;/li&gt;
  &lt;li&gt;원래의 코드에 연관된 코드를 수정할 때 원래의 코드가 내포한 가정과 어긋나게 수정하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오용이 어렵거나 불가능하도록 코드를 설계하고 구조화하는 것이 종종 가능하다. 
이를 통해 버그 발생 가능성이 크게 줄어들고 중장기적으로 개발자의 시간을 많이 절약할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;chapter-8-코드를-모듈화하라&quot;&gt;Chapter 8. 코드를 모듈화하라&lt;/h2&gt;

&lt;p&gt;코드가 모듈화되어 있으면 변경된 요구 사항을 적용하기 위한 코드를 작성하기가 쉽다. 
모듈화의 주요 목표 중 하나는 요구 사항의 변경이 해당 요구 사항과 직접 관련된 코드에만 영향을 미치도록 하는 것이다.
코드를 모듈식으로 만드는 것은 간결한 추상화 계층을 만드는 것과 깊은 관련이 있다.&lt;/p&gt;

&lt;p&gt;다음의 기술을 사용하여 코드를 모듈화 할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;의존성 주입&lt;/li&gt;
  &lt;li&gt;구체적인 클래스가 아닌 인터페이스에 의존&lt;/li&gt;
  &lt;li&gt;클래스 상속 대신 인터페이스 및 구성의 활용&lt;/li&gt;
  &lt;li&gt;클래스는 자신의 기능만 처리&lt;/li&gt;
  &lt;li&gt;관련된 데이터의 캡슐화&lt;/li&gt;
  &lt;li&gt;반환 유형 및 예외 처리 시 구현 세부 정보 유출 방지&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-9-코드를-재사용하고-일반화할-수-있도록-해라&quot;&gt;Chapter 9. 코드를 재사용하고 일반화할 수 있도록 해라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;동일한 하위 문제가 자주 발생하므로 코드를 재사용하면 미래의 자신과 팀 동료의 시간과 노력을 절약할 수 있다.&lt;/li&gt;
  &lt;li&gt;다른 개발자가 여러분이 해결하려는 문제와는 다른 상위 수준의 문제를 해결하더라도 특정 하위 문제에 대해서는 여러분이 작성한 해결책을 재사용할 수 있도록 근본적인 하위 문제를 식별하고 코드를 구성하도록 노력해야 한다.&lt;/li&gt;
  &lt;li&gt;간결한 추상화 계층을 만들고 코드를 모듈식으로 만들면 코드를 재사용하고 일반화하기가 훨씬 쉽고 안전해진다.&lt;/li&gt;
  &lt;li&gt;가정을 하게 되면 코드는 종종 더 취약해지고 재사용하기 어렵다는 측면에서 비용이 발생한다.&lt;/li&gt;
  &lt;li&gt;가정을 하는 경우의 이점이 비용보다 큰지 확인하라.&lt;/li&gt;
  &lt;li&gt;가정을 해야 할 경우 그 가정이 코드의 적절한 계층에 대해 이루어지는 것인지 확인하고 가능하다면 가정을 강제적으로 적용하라.&lt;/li&gt;
  &lt;li&gt;전역 상태를 사용하면 특히 비용이 많이 발생하는 가정을 하는 것이 되고 재사용하기에 전혀 안전하지 않은 코드가 된다. 대부분의 경우 전역 상태를 피하는 것이 가장 바람직하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-10-단위-테스트의-원칙&quot;&gt;Chapter 10. 단위 테스트의 원칙&lt;/h2&gt;

&lt;h3 id=&quot;블랙박스-테스트&quot;&gt;블랙박스 테스트&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;테스트&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;동치 분할 테스트(Equivalence Partitioning Test)&lt;/td&gt;
      &lt;td&gt;프로그램의 입력 데이터를 여러 분류로 나누어 검사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;경계값 분석  (Boundary Value Analysis)&lt;/td&gt;
      &lt;td&gt;입력값의 경계값을 중심으로 예외 발생 검사&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;원인-결과 그래프 기법(Cause-effect Graphing)&lt;/td&gt;
      &lt;td&gt;입력데이터 간의 관계, 출력에 미치는 영향의 분석 그래프 이용&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;오류 예측검사 (Fault Based Testing)&lt;/td&gt;
      &lt;td&gt;테스터의 감각이나 경험, 지식을 통해 에러케이스를 예측&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;비교 검사 (Comparison Testing)&lt;/td&gt;
      &lt;td&gt;테스트 대상과 비교 대상 프로그램에 같은 입력값을 넣어 데이터를 비교&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;테스트-더블&quot;&gt;테스트 더블&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://martinfowler.com/bliki/TestDouble.html&quot;&gt;TestDouble - 마틴 파울러&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;제라드 메스자로스는 다양한 Xunit 프레임워크를 사용하는 패턴을 모아 놓은 책을 만드는 중입니다. 
그가 부딪힌 문제 중 하나는 시스템의 일부를 테스트하기 위해 대체하는데 사용되는 스텁(stubs), 목(mock), 페이크(fake), 더미(dummy) 등의 다양한 이름들입니다. 
이를 해결하기 위해 그는 자신만의 용어를 만들었으며, 이는 더욱 널리 알리면 좋을 것이라 생각됩니다.&lt;/p&gt;

  &lt;p&gt;그가 사용하는 일반적인 용어는 ‘테스트 더블’(stunt double을 생각하면 됩니다)입니다. 
‘테스트 더블’은 테스트 목적으로 제작 객체를 대체하는 일반적인 용어입니다. 제라드가 나열한 여러 종류의 더블은 다음과 같습니다. 
더미 객체는 전달되지만 실제로 사용되지는 않습니다. 보통 매개변수 목록을 채우기 위해 사용됩니다.&lt;/p&gt;

  &lt;p&gt;페이크 객체는 실제 구현을 가지고 있지만, 일반적으로 프로덕션에 적합하지 않은 지름길을 사용합니다.(InMemoryTestDatabase가 좋은 예임)
스텁은 테스트 중에 호출된 호출에 대한 canned answer(일정한 대답)을 제공하며, 테스트에 프로그래밍된 것 이외의 것에는 대응하지 않습니다.
스파이는 호출된 방식에 따라 일부 정보를 기록하는 스텁입니다. 이 중 하나는 얼마나 많은 메시지가 전송되었는지를 기록하는 이메일 서비스일 수 있습니다.
목(mock)은 호출되기를 기대하는 명세를 형성하는 기대치로 미리 프로그래밍됩니다. 기대하지 않은 호출을 받으면 예외를 던질 수 있으며, 확인 중에 확인하여 예상했던 모든 호출을 받았는지 확인할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 코드로 보면 다음과 같을 수 있다. (sut는 system under test의 약자로, 테스트중인 시스템을 의미한다.)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@ExtendWith&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MockitoExtension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleServiceTests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withMock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Mock&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// given&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;thenReturn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Example&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// when&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsExactly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withStub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// given&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// do nothing&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt; 
        
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stub&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;c1&quot;&gt;// when&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsExactly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;withFake&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// given&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FakeExampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// when&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sut&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;containsExactly&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ExampleService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exampleRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;exampleRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FakeExampleRepository&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;save&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;좋은-단위-테스트는-어떻게-작성-할-수-있는가&quot;&gt;좋은 단위 테스트는 어떻게 작성 할 수 있는가?&lt;/h3&gt;

&lt;p&gt;액면 그대로의 단위 테스트는 매우 간단해 보일지 모른다. 
실제 코드가 작동하는지 확인하기 위해 테스트 코드를 작성하기만 하면된다. 
안타깝게도 이는 기만적인것이며, 수 년 동안 많은 개발자가 쉽게 단위 테스트를 잘못된 방식으로 작성해왔다.&lt;/p&gt;

&lt;p&gt;단위 테스트에서 문제가 발생하면 유지 관리가 매우 어렵고, 버그가 테스트 코드에서 발견되지 못하고 배포한 뒤에 발생 할 수도 있다. 
그러므로 어떻게해야 좋은 단위 테스트가 되는지 생각해 보는것이 중요하다. 
이를 위해 좋은 단위 테스트가 가져야 할 5가지 주요 기능을 정의한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;훼손의 정확한 감지: 코드가 훼손되면 테스트가 실패한다. 그리고 테스트는 코드가 실제로 훼손 된 경우에만 실패해야 한다.&lt;/li&gt;
  &lt;li&gt;세부 구현 사항에 독립적: 세부 구현 사항을 변경하더라도 테스트 코드는 변경하지 않는것이 이상적이다.&lt;/li&gt;
  &lt;li&gt;잘 설명되는 실패: 코드가 잘못되면 테스트는 실패의 원인과 문제점을 명확하게 설명해야한다.&lt;/li&gt;
  &lt;li&gt;이해 할 수 있는 테스트 코드: 다른 개발자들이 테스트 코드가 정확히 무엇을 테스트하기 위한 것이고 테스트가 어떻게 수행 되는지 이해할 수 있어야 한다.&lt;/li&gt;
  &lt;li&gt;쉽고 빠르게 실행: 개발자는 일상 작업 중에 단위 테스트를 자주 실행한다. 단위 테스트가 느리거나 실행이 어려우면 개발 시간이 낭비된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-11-단위-테스트의-실제&quot;&gt;Chapter 11. 단위 테스트의 실제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드의 모든 동작을 효과적으고 신뢰성 있게 테스트하기&lt;/li&gt;
  &lt;li&gt;이해하기 쉽고 실패가 잘 설명되는 테스트 코드의 작성&lt;/li&gt;
  &lt;li&gt;의존성 주입을 사용하여 테스트가 용이한 코드의 작성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;기능뿐만-아니라-동작을-시험하라&quot;&gt;기능뿐만 아니라 동작을 시험하라&lt;/h3&gt;

&lt;p&gt;코드를 테스트하는 것은 할 일 목록을 만들어 작업하는 것과 약간 비슷하다. 
그러나 다른 할 일 목록과 마찬가지로 성공적인 결과는 실제로 목록에 있는 것들이 얼마나 올바른지 달려 있다.&lt;/p&gt;

&lt;h3 id=&quot;테스트만을-위해-퍼블릭으로-만들지-말라&quot;&gt;테스트만을 위해 퍼블릭으로 만들지 말라&lt;/h3&gt;

&lt;p&gt;프라이빗 함수는 구현 세부 사항이며 클래스 외부 코드가 인지하거나 직접 사용하는 것이 아니다.
구현 세부 사항과 밀접하게 연관된 테스트가 될 수 있고 궁극적으로 우리가 신경써야 하는 코드의 동작을 테스트하지 않을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;퍼블릭-api를-통해-테스트하라&quot;&gt;퍼블릭 API를 통해 테스트하라&lt;/h3&gt;

&lt;p&gt;비교적 간단한 클래스의 경우 퍼블릭 API만을 사용하여 모든 동작을 테스트하기가 매우 쉽다. 
그러나 클래스가 더 복잡하거나 많은 논리를 포장하면 퍼블릭 API를 통해 모든 동작을 테스트하는 것이 까다로울 수 있다.
이 경우는 코드를 더 작은 단위로 분할하는 것이 유익하다.&lt;/p&gt;

&lt;h3 id=&quot;코드를-더-작은-단위로-분할하라&quot;&gt;코드를 더 작은 단위로 분할하라&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/226680949-151a22ef-5b41-476a-9a10-64d13089f1ce.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 함수를 테스트하는 것에 집중하다 보면 테스트가 충분히 되지 못하기 쉽다. 보통은 모든 중요한 행동을 파악하고 각각의 테스트 케이스를 작성하는 것이 더 효과적이다.&lt;/li&gt;
  &lt;li&gt;결과적으로 중요한 동작을 테스트 해야 한다. 프라이빗 함수를 테스트하는 것은 거의 대부분 결과적으로 중요한 사항을 테스트하는 것이 아니다.&lt;/li&gt;
  &lt;li&gt;한 번에 한 가지씩만 테스트하면 테스트 실패의 이유를 더 잘 알 수 있고 테스트 코드를 이해하기가 더 쉽다.&lt;/li&gt;
  &lt;li&gt;테스트 설정 공유는 양날의 검이 될 수 있다. 코드 반복이나 비용이 큰 설정을 피할 수 있지만 부적절하게 사용할 경우 효과적이지 못하거나 신뢰할 수 없는 결과를 초래할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존성 주입을 사용하면 코드의 테스트 용이성이 상당히 향상될 수 있다.&lt;/li&gt;
  &lt;li&gt;단위 테스트는 개발자들이 가장 자주 다루는 테스트 수준이지만 이것만이 유일한 테스트는 아니다. 높은 품질의 소프트웨어를 작성하고 유지하려면 여러가지 테스트 기술을 함께 사용해야 할 때가 많다.&lt;/li&gt;
&lt;/ul&gt;
</description>
			<pubDate>Thu, 16 Mar 2023 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2023-03-16-diary-49/</link>
			<guid isPermaLink="true">/diary/2023-03-16-diary-49/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>2022년 회고</title>
			<description>&lt;p&gt;이제 사회생활 11년 차다.&lt;/p&gt;

&lt;p&gt;개발자로서는 이제 경력이 만 2년이니 3년 차다.&lt;/p&gt;

&lt;p&gt;그동안의 행적을 정리하고 앞으로의 목표를 정하며 2022년 회고를 한번 작성해본다.&lt;/p&gt;

&lt;h1 id=&quot;정말-천직을-찾았구나&quot;&gt;정말 천직을 찾았구나!&lt;/h1&gt;

&lt;p&gt;집이 정말 가난해서 중학생 때 군대에 가지 않고 돈을 벌겠다고 생각했고, 방법을 알아보던 중 산업기능요원, 그러니까 병역특례 혹은 병특이라고 알려진 제도를 알게 됐다.
이 제도를 이용하기 위해 준비했고, 산업기능요원으로서 20살에 사회생활을 시작할 수 있게 되었다. 직장에선 쉴 틈 없이 일해 돈을 벌고, 퇴근 후엔 취미를 즐겼다.
나에게 직장은 단순히 생활을 영위하기 위해 돈을 벌러 가는 곳이었을 뿐이다. 이 시기의 나는 워라밸을 추구했었다.&lt;/p&gt;

&lt;p&gt;20대 중후반에는 내 평생의 꿈 중 하나를 성취할 수 있었다.
어릴 때부터 이사를 워낙 많이 다녔기에 이사를 하는 게 정말 지긋지긋해서 내 집을 갖는 게 평생의 소원 중 하나가 되었는데, 다행히 사회생활을 일찍 시작한 만큼 돈을 차곡차곡 모아서 대출을 끼고 내 집을 마련할 수 있었다.
언젠가 등본을 뗐는데, 장표가 많이 나오길래 뭔가 하여 보니 모두 이사기록이었고, 내가 이사를 한 횟수가 20번 가까이 되었던 기억이 난다… 😩&lt;/p&gt;

&lt;p&gt;2020년에 갑자기 어머니가 장의 1/3가량을 절제하는 큰 수술을 하게 되셨다. 다니던 직장을 그만두고 서울로 올라왔다.
당시는 코로나가 한참 난리였던 시기여서 보호자 신분으로 어머니와 함께 병원에 들어간 후 2개월 가까이 밖으로 잘 나오질 못했다.&lt;/p&gt;

&lt;p&gt;그리고 이 사건은 내가 개발자로 직종 전환을 하게 된 가장 큰 계기가 되었다.&lt;/p&gt;

&lt;p&gt;병원에서 갑자기 큰 수술을 하게 되어 누워계신 어머니와, 아픈 많은 사람을 보면서 정말 많은 생각이 들었다.
병실의 밤은 마치 온 세상에 죽음이 깔린 느낌이었으며, 이런 상황에 쳐해지니 돈만 보고 살아온 그동안의 10년 가까운 내 세월이 덧없게 느껴졌다.
막말로 나도 출퇴근하다 갑자기 교통사고를 당해 죽으면 내 수중에 돈이 얼마가 있던 아무런 의미가 없지 않겠는가?&lt;/p&gt;

&lt;p&gt;병원에서 퇴원한 후 나는 다시 직장을 구해야 했는데, 이때 내 관심사는 단 하나였다.
“내가 즐겁게 할 수 있는 일을 내 직업으로 가져야겠다.”
나는 평생을 취미생활이 직업이 되면 그조차 재미가 없어지고 말 것이라고 생각을 해온 사람이었는데, 이 시기의 나는 이 생각을 뒤집고 재미있는 일을 하고 싶었다.
근데 진심으로 내가 뭘 좋아하는지 나조차도 알 수가 없어서 어떤 직업을 골라야 할지 알 수 없었다.
그래서 한참을 궁리한 끝에 여러 가지 검사들을 해봤다. 심리검사, 적성검사, 직무검사 등을… 내 스스로를 모르겠다면 검사를 받으면 된다고 생각했다.
모든 검사 결과의 교집합에 추천 직업으로 개발자라는 직종이 있었고, 나는 그 즉시 C언어 책을 하나 사 들고 공부를 시작했다.
사실 모든 과정이 굉장히 미심쩍었는데, 막상 코딩을 시작해보니 정말 재미있어서 금방 결정할 수 있었다.&lt;/p&gt;

&lt;h1 id=&quot;공부는-어떻게&quot;&gt;공부는 어떻게?&lt;/h1&gt;

&lt;p&gt;학원은 다 사짜였다. 딱 봐도 제대로 아는 게 없어 보이는 사람들이 강의하고 있는 곳이 많았다.
나는 사회생활을 오래 한 만큼 사기꾼(?) 같아 보이는 사람들을 보는 즉시 알 수 있었다.&lt;/p&gt;

&lt;p&gt;그래서 그냥 독학했다. 책, 인터넷 강의의 도움을 많이 받았다. 개발 관련 자료들은 인터넷에 무료로 모두 풀려있었고, 이를 제대로 이해할 수 있는 기본기만 갖출 수 있으면 되었다.
책이나 강의를 보면서 내가 보고 들은 한 문장에 내가 제대로 이해하지 못하는 단어가 단 하나라도 있으면 그 단어부터 다시 찾아보러 갔다.
내가 생각하기에 공부할 때 가장 중요한 것은 메타인지다. 자기 객관화, 내가 알고 있는 게 제대로 알고 있는 게 맞는 것인지 등을 객관적인 시선으로 바라볼 수 있어야 한다.
그리고 사실 공부고 자시고 할 것도 없는 게 그냥 엄청 재미있어서 이것저것 닥치는 대로 다 보고 닥치는 대로 다 코딩했다.&lt;/p&gt;

&lt;p&gt;돌이켜보면 이때 한 공부량을 고등학생 때 했으면 최소 서성한 라인 정도는 그냥 갔지 않았을까 싶긴 하다. 물론 나는 수능이란걸 봐본적이 없는 녀석이기 때문에 헛된 망상에 가까울 것이다. (ㅋㅋ)
아무튼 이때 제일 어려운 건 영어였고, 영어로 된 문서들은 번역기의 도움을 받아 가면서 봤다.
영어를 더럽게 못 하니 굉장히 지루하고 어렵고 힘든 일이었는데 그래도 피하지 않으려고 했다.
당장 힘들어도 영어에 익숙해지는 게 장기적으로 좋다고 생각했다. 이 생각과 행동원칙은 아직도 계속 유효하다.&lt;/p&gt;

&lt;h1 id=&quot;첫직장-회고&quot;&gt;첫직장 회고&lt;/h1&gt;

&lt;p&gt;21년 2월 1일에 개발자로서 첫 회사에 취업하게 되었다.
회사는 굉장히 안정적이고 보수적이었다.
사실 개발팀은 그렇게 보수적이라고 느끼진 않았는데, C 레벨의 성향이 보수적이었고, 이게 회사의 운영방침이 되었다.
워라밸은 칼같이 지켜졌고, 업무는 한가했다. 그래서 자기 계발에 많은 시간을 할애할 수 있었다.&lt;/p&gt;

&lt;p&gt;이때 내가 가장 크게 성장을 했다고 생각하는 것은 내가 한가한 시간에 계속 진행한 코드 카타다.
코딩을 훈련처럼 하는 것인데, 간단한 주제와 무지막지하게 빡빡한 코딩 규약을 정하고 이에 맞게 코딩을 진행한다.
그리고 코딩을 마치면 작성한 모든 코드를 폐기하고 처음부터 다시 작성한다. 단, 이전에 진행했던 방식과는 차별화된 방식을 생각하고 적용해야 했다.
위의 순서를 계속 반복한다.&lt;/p&gt;

&lt;p&gt;나는 이 훈련을 몇 달 동안 반복하면서 간단한 CRUD를 할 수 있는 게시판 API와 테스트 코드를 10분 이내에 모조리 구현할 수 있을 정도로 자바 코딩에 능숙해질 수 있었고, 실패에 대한 두려움을 없앨 수 있었다.
실패에 대한 두려움이란 이런 거다. 내가 아무것도 없는 빈 프로젝트에서 어떤 것을 개발해야 한다고 상상해보자. 나는 아무런 부담감 없이, 거리낌 없이 개발을 즉시 진행할 수 있을까?
나는 더 아름다운 코드를 작성하고 싶은 욕심에 코딩을 시작조차 못 하는 상황을 많이 겪어왔고, 훈련 끝에 이 욕심을 버릴 수 있게 되었다. 아름다운 코드는 테스트 코드와 리팩토링으로 추구할 수 있다는 것을 알 수 있게 되었다.
그리고 테스트 코드를 작성할 수 있는 코드란 것은 이미 그 자체로 훌륭한 설계가 뒷받침된 것임도 알 수 있게 되었다.&lt;/p&gt;

&lt;p&gt;그리고 비전공자인 만큼(사실 전공이랄게 없다. 고졸이니까.) KOCW와 책을 통해 운영체제, 네트워크, 데이터베이스, 자료구조 등의 컴퓨터 과학 기본기에 계속 시간을 투자했다. 겸사겸사 이때 정보처리기사도 취득했다.
정보처리기사의 경우 막 개편된 시점이었는데 이때 합격률이 3%였다. 목적이 자격증을 취득하는데 있지 않았고, 그냥 기사 자격증(조건이 4년제 졸업인 자격증이므로)의 필기과목을 다 씹어먹으면 전공자 뒤꽁무니에라도 비벼볼 수준은 되지 않을까? 였다. 
그리고 이 정도 되면 자격증은 그냥 따라오는거라고 생각했고, 이 생각은 유효했다. 정보처리기사 필기 과목을 빡세게 공부한 후 적어도 내가 뭘 모르는지 정도는 아는 상태가 됐다고 생각한다. 막히면 어떤 키워드로 검색해봐야 하는지 알게 됐다.
이 시기의 나는 회사에서는 회사 업무에 충실하고(이때 리팩토링, 디자인패턴을 실무에서 많이 연습해볼 수 있었다), 퇴근 후에는 CS와 코드 카타를 병행하는 삶의 나날이었다. 재미가 없었다면 계속할 수 없었을 거다.&lt;/p&gt;

&lt;h1 id=&quot;첫번째-이직&quot;&gt;첫번째 이직&lt;/h1&gt;

&lt;p&gt;그동안 쌓아온 개발 실력과 업무 능력을 팀장님께 인정받아 연봉이 천만원 이상 올랐다.
우리 회사에서 굉장히 이례적인 일이었고 이때 회사에 여러 가지 말이 많았던 걸로 안다.&lt;/p&gt;

&lt;p&gt;근데 결국 작년 중순에 현 직장으로 이직했다. 이유는 아주 단순했다.
다니고 있던 회사는 성장에 대한 열망이 없다고 느꼈기 때문이다.
돈은 물론 중요하고 다다익선이지만, 나한테 이제 돈은 사실 내가 먹고 싶은 거 먹고, 사고 싶은 거 부담 없이 살 수 있을 정도만 받으면 더 욕심을 부릴만한 가치가 없는 그런 것이였다.&lt;/p&gt;

&lt;p&gt;나는 오늘의 나보다 내일의 내가 조금이라도 더 나아질 거라 믿고, 성장에서 오는 재미에 중독되어있었다.
이제 직장은 나한테 자아실현, 지적성장의 장이었다.&lt;/p&gt;

&lt;p&gt;근데 내가 아무리 성장을 해도 회사의 성장이 정체되면 나의 성장도 둔화될 수밖에 없다.
내가 다니던 회사는 안정적이었고, 보수적이었다. 대부분의 임직원이 공무원처럼 일하는 곳이었다. 업무는 치열하지 않았고, 워라밸은 철저하게 지켜졌다.&lt;/p&gt;

&lt;p&gt;즉, 도전의 기회가 없었다.&lt;/p&gt;

&lt;p&gt;이게 나쁘다는 게 아니다.&lt;/p&gt;

&lt;p&gt;단지 나한테 잘 맞지 않았을 뿐.
도전이 없다면 실패도 없고, 실패가 없다면 성장도 없다.
개개인이 성장하지 못하는데, 회사가 성장할 수 있을까?&lt;/p&gt;

&lt;p&gt;지금 다니는 회사에 오게 된 계기는 사실 별것 없었다.
오픈 카톡방에 HR 직군에 종사하시는 어떤 분이 주기적으로 채용 홍보를 했는데, 마침 이직 생각을 하고 있었어서 그냥 별생각 없이 지원서를 넣어봤었다.
어떻게 어떻게 프로세스가 진행되고 첫 면접을 보게 됐는데, 애초에 아무 생각 없이 지원했기에 첫 면접도 사실 준비를 아예 하지 않았다. 면접도 그날 퇴근 후 회사 근처 카페에 가서 대충 노트북 열고 봤다.
애초에 그냥 면접이나 한번 봐보자는 생각이었기 때문에…
그리고 이때 첫 면접관으로 들어오신 분이 쿠팡을 다니시던 시니어 개발자분이셨다. 현재는 함께 일하고 계신 동료 개발자중 한분이시다.&lt;/p&gt;

&lt;p&gt;나는 사실 여태 시니어 개발자라는 존재에 대해 아무런 의미를 두지 않고 살아왔다.
내가 나를 잘 통제해내면 내가 잘하는 건 상수지만, 다른 사람이 나에게 어떤 도움을 준다거나 하는 것은 내가 통제할 수 없는 변수기 때문에 애초에 남의 도움이란 없는 거다 라는 게 내 가치관이었고 그렇게 살아왔기 때문이다.
그러니까, 어차피 성장은 결국 내가 노력해야 이뤄지는 것이라 생각해왔고, 시니어 개발자가 주변에 있건 없건 결국 나만 잘하면 성장은 지속할 수 있는 것이라고 생각했다.&lt;/p&gt;

&lt;p&gt;이런 생각을 갖고 있었는데 첫 면접에서의 임팩트가 대단히 컸다.
그러니까, 주변에 시니어 개발자가 있건 없건 사실 아무런 의미가 없다는 마인드였는데, 이 시기를 기점으로 훌륭한 시니어 개발자가 주변에 있다면 그것은 아주 좋은것이라고 생각이 바뀐 셈이다.&lt;/p&gt;

&lt;p&gt;첫 면접을 마치고 최종면접이 남았는데 CTO님과 첫 면접에서 만난 개발자분이 들어온다고 하셨다.
나도 이 최종 면접은 준비를 꽤 많이 했다. 첫 면접에서의 임팩트가 강렬했고, 첫 면접에 나오셨던 분도 CTO님과 면접을 보고 쿠팡을 나와 여기로 오게 되셨다고 하여서 회사와 개발팀에 관심이 많이 생겼기 때문이다.
결국 최종면접도 굉장히 느낌이 좋았다. 다행히 사측도 생각이 비슷했는지 가부가 금방 나왔고 나도 입사하기로 결정하였다.&lt;/p&gt;

&lt;h1 id=&quot;근황&quot;&gt;근황&lt;/h1&gt;

&lt;p&gt;현재 회사에 근무한 지 이제 5개월이 지났는데, 정말 많은 도전을 하고 있다.
내가 작업한 것 하나하나가 내 눈에 보이고 내가 체감할 수 있을 정도의 임팩트를 만들어내고 있다.
하루하루가 즐겁다 보니 요즘은 아예 워라블을 추구하고 있다.&lt;/p&gt;

&lt;p&gt;워라블이 무엇이냐? Work Life Blending, 즉 일과 삶의 경계가 없어지는 거다. 이렇게 말하면 그냥 일만 하는 것처럼 느껴질 수도 있겠다 싶긴 한데 전혀 그렇지 않다.
왜냐하면 그냥 개발 자체가 재미있기 때문이다.&lt;/p&gt;

&lt;p&gt;오히려 근무 시간에도 쉬거나 놀고 싶으면 즉시 일에서 손을 떼고 카페에 가서 쉬다 온다거나 산책한다거나 한다. 회사에서도 아무런 터치를 하지 않는다.
어디 놀러 가서도 개발이 하고 싶으면 그냥 그 자리에서 노트북을 열고 개발한다. 밤이든 주말이든 새벽이든 개발이 하고 싶으면 그냥 개발하고, 놀고 싶다면 놀고, 쉬고 싶다면 쉰다.
원래는 내가 관심 있는 분야에 관한 공부를 하거나 코드 카타를 하고 깃허브에 코드를 올렸는데, 이제는 회사 코드를 개선하고 Pull Request를 연다. 훈련은 충분히 해왔고, 이제 훈련의 성과를 실무에서 보일 차례다.&lt;/p&gt;

&lt;p&gt;일과 삶이 분리된 생활, 즉 워라밸을 추구할 때는 일하는 시간이 그저 시간을 낭비하는 것이라고 생각했었다. 회사는 출근하자마자 퇴근이 하고 싶어지는 곳이었다. 햄스터가 매일매일 쳇바퀴를 돌듯이, 직장은 나에게 이와 같았다.&lt;/p&gt;

&lt;p&gt;하지만 지금은 전혀 그렇지 않다. 덕업일치가 이뤄지고 나니 워라블을 추구하는 삶이 지금 나한테는 아주 잘 맞는 것 같다.&lt;/p&gt;

&lt;h1 id=&quot;올해의-목표&quot;&gt;올해의 목표&lt;/h1&gt;

&lt;p&gt;우선 회사의 기술 부채를 청산하는 작업을 올해 안에 마무리는 못 하겠지만 그래도 끝이 보일 정도까지는 진행하고 싶다.
회사가 시리즈 B까지 쉴 틈 없이 달려온 만큼 그동안 쌓아온 기술 부채가 굉장하긴 하다.
기술 부채가 어느 정도냐면, 내가 입사 후 2개월 동안 손댄 것만으로 월 서버비가 2천만원이 넘게 줄었다.
내가 뭐 대단한걸 한 게 아니다. 그냥 깨진 유리창 위에 쌓여있는 쓰레기들을 좀 치웠을 뿐이다.
단지 그 쓰레기가 워낙 많아 쓰레기를 좀 치운 것만으로도 굉장한 임팩트를 냈을 뿐이고.
그리고 사실 이 기술 부채를 개선하는 건 내 기술적인 역량으로나 멘탈적인 측면으로나 전혀 힘들고 고된 일이 아니었다.
오히려 내가 오를 산이 있음이 좋고, 산을 올랐을 때 느낄 성취감이 기대마저 된다. 역경과 고난이 큰 만큼 성취감도 비례해서 커지는법 아니겠는가?&lt;/p&gt;

&lt;p&gt;두번째로는 개발팀을 정상으로 되돌리는것이다.
현재 CTO님 입사 시기를 기준으로 이전에 계시던 개발자분들과 이후에 입사하신 개발자분들간의 괴리감이 상당히 크게 느껴지는데, 심적으로 나를 괴롭히는것은 타성에 젖어온 기존 개발팀의 개발문화다.
깨진 유리창 하나를 고쳐도 다른데서 여러개의 유리창이 또 깨진다면 그만큼 지치는게 없다.
빠르게 개발을 해야하는것과 코드 퀄리티를 지키는것. 이 사이의 밸런스를 잡는다는게 물론 굉장히 어려운 일임은 너무 잘 알고 있다. 하지만 여지껏 빠르게 개발을 하는데만 치중해왔기 때문에 이제는 더 이상 빠르게 개발을 할 수 없는 상태다. 일정조차 예측할 수 없다. 코드를 이해할 수 없으니까.
그리고 빠르게 개발을 하는 데에만 집중해왔기 때문에 이에 대한 타성에 젖어있다.
요즘은 “빠르게 개발하려면 퀄리티 포기하는 게 너무 당연한 거 아니냐? 시간을 더 주던가!” 라는 느낌마저 들 정도긴 하다.
어느정도 이해되는 입장이긴 한데, 기본적으로 개발자는 자신의 코드에 프라이드가 있어야 한다고 생각한다.
당연하게 여기는 것과 어쩔 수 없이 선택하는 것은 아예 다른 차원의 얘기라고 생각한다.
본인이 유리창을 계속 깨왔고 계속 깨고 있으면서 막상 개발해야 할 때가 오면 “유리창이 너무 많이 깨져있어 개발이 오래 걸릴 것 같습니다. 개발이 언제 끝날지 알 수 없습니다.”라고 하는 것은 굉장히 무책임한 행동과 발언들이라고 생각한다.&lt;/p&gt;

&lt;p&gt;개발자는 기본적으로 회사에서 개발 업무를 하지만, 그 근본은 비즈니스다. 그리고 비즈니스는 항상 Cost vs Benefit이다. 개발자의 인건비, 서버비, 사무실 임대료 등 그냥 자연스레 흐르는 시간의 흐름만으로도 회사는 막대한 비용을 지불하고 있다. 한 팀에 연봉 3천만원을 받는 직원이 5명만 있어도 하루에 약 52만 원 정도의 지출이 발생한다. 어떤 기능 하나를 개발하기 위해 5일이 걸렸다면 회사는 약 260만원+@의 비용을 지불한 셈이다.
그러니까, 때로는 기능을 개발하지 않는 게 더 이득일 수도 있다는 소리이다. 왜? 이렇게 막대한 비용을 들여 기능을 개발했는데 막상 돈은 벌지 못하는데도 불구하고 오히려 해당 기능을 유지보수하기 위해 인력이 투입되는 경우도 많기 때문이다.&lt;/p&gt;

&lt;p&gt;개발자라고 마냥 개발만 하지 말고 비즈니스를 알아야 한다. 정말 개발할만한 가치가 있는 것인지, 이것을 개발하면 최소 내 인건비라도 건질 수 있는 일인 것인지, 그럼에도 불구하고 개발해야 한다면 최대한 빠른 기간 안에 정말 필요한 스펙만을 정의해 개발에 들어가야 한다. 일정이 부족하다고 느낀다면 왜 일정이 부족한 것인지 동료들을 설득할 수 있어야 한다. 이러한 고민 없이 그냥 “일정이 촉박해요. 불가능해요.” 혹은 “일정이 부족하니까 돌아가게 만이라도 개발해야지” 같은 태도가 즉시 나온다면 그것은 일을 제대로 잘못하고 있는 것이다. 경력이 쌓일수록 이러한 자세와 스킬이 더더욱 중요해진다고 생각한다.&lt;/p&gt;

&lt;p&gt;큰 목표는 이정도들이고, 요즘은 테스트코드를 작성하고 코드리뷰를 잘 할 수 있게끔 시스템을 구축하고 개발 문화를 정착시키고 있다.
VCS 플랫폼을 깃허브로 통째로 이전해왔고, 각종 자동화를 추가하고 있다. 그리고 깨져있던 모든 테스트를 고치고 코드 스타일을 통일시켰다. 
이제 PR을 열면 PR의 제목이 형식에 맞는지, 신규 개발로 인해 테스트가 깨지진 않았는지, 코드 스타일이 안맞지는 않는지, 앱이 제대로 실행이 되기는 하는건지 등을 모두 자동으로 체크한다.&lt;/p&gt;

&lt;p&gt;그리고 방치되어있던 젠킨스를 청소하고 버전을 LTS로 올리고 각종 job을 작성하고 젠킨스 유저들의 권한을 재정립했다.&lt;/p&gt;

&lt;p&gt;마지막으로, 모든 데이터베이스의 쿼리 통계를 기록하도록 변경하고, 슬로우 쿼리를 모니터링하며 쿼리 튜닝을 꾸준히 진행하고 있다.&lt;/p&gt;

&lt;p&gt;그동안 해왔던대로, 누군가가 또 다시 별 생각없이 유리창을 깨지 않게끔, 그게 깨서는 안되는 유리창임을 인지할 수 있게끔 계속 감시하고 목소리를 내고 있다. 
그래서 최종적으로 코드 레벨과 서비스 품질이 더이상 떨어지지 않게끔, 더 좋아질 수 있게끔 노력하고 있다. 
이렇게 돌이켜보니 현재 나라는 놈은 아마 현재 우리 개발팀에서 꽤 피곤한녀석으로 느껴지고 있지 않을까 싶기는 하다.
정말 그렇다면 마음 아픈 일이겠지만, 내가 인상 깊게 봤던 어떤 드라마에서 나온 대사를 되새겨본다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;내가 매일 보는 동료들이, 내 옆의 완전 보통 사람들이 이러는 게, 난 이게 더 안 돼요 이게. 받아들이는 게.
저 사람들이 죄다 처음부터 저랬겠어요? 하다 보니까, 되니까 그러는 거예요. 눈감아주고 침묵하니까.
누구 하나만 눈을 제대로 부릅뜨고 짖어주면 바꿀 수 있어요.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
			<pubDate>Sat, 28 Jan 2023 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2023-01-28-diary-48/</link>
			<guid isPermaLink="true">/diary/2023-01-28-diary-48/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>회사에서는 제발 바로바로 질문을 하세요</title>
			<description>&lt;p&gt;온라인 커뮤니티를 보다 보면 질문자의 무성의한 질문에 굉장히 공격적인 태도를 보이는 사람들이 많은 것을 흔하게 볼 수 있다.
이는 온라인 커뮤니티의 특성에서 기인했다고도 볼 수 있는데, 서로 아무런 접점이 없는 온라인 커뮤니티에서는 서로에게 지식을 공유해 생산성을 올릴 이유도 필요도 없기 때문이다.
그들은 커뮤니티에 중복된 자료가 생기지 않게 관리해야 하며, 같은 목적을 가지고 함께 시간을 사용하고 있는 관계도 아니다. 단지 각자의 시간이 귀중한 사람들일 뿐이다.
위의 내용이 잘 이해되지 않는다면 스택 오버플로에 접속해 구경도 해보고, 질문 글도 작성해보면 이해할 수 있게 될 것이다.&lt;/p&gt;

&lt;p&gt;따라서 온라인 커뮤니티에서 질문할 때는 자신의 상황이 어떻고, 어떤 문제가 있었고, 어떠한 것들을 시도해봤고, 어떤 도움이 필요한지를 상세하게 기술할 필요가 있다.
그래야 답변자가 질문자의 상황을 제대로 이해하고 올바른 답변을 줄 확률이 높아진다.
이렇게 성의있는 질문을 올렸음에도 여전히 공격적인 태도를 보이는 답변자들이 있다면 그 답변자들이 이상한 것이다.
또한, 사실 질문이 매우 무성의했더라도 거기에 대고 핑프니 뭐니 해가며 댓글을 작성할 필요조차 없기도 하다.
도와주기 위해 관련 링크를 첨부해 댓글을 작성하나, 질문자를 비난하기 위해 댓글을 작성하나 드는 시간은 비슷하지만, 전자는 질문자가 도움을 받을 확률이 조금이라도 존재하는 데 반해, 후자는 생산성조차 바닥을 치는 무의미한 행위이기 때문이다.
따라서 차라리 질문자를 비난하고 싶더라도 댓글을 달지 않고 조용히 뒤로 가기를 눌러 관심을 주지 않는 게 오히려 커뮤니티의 문화 형성에도 도움이 될 것이다. 가장 무서운것은 무관심이다.&lt;/p&gt;

&lt;p&gt;문제는 위의 문화를 회사에 들고와서 행동하는 사람들이 꽤 존재한다는 것이다.
회사에서는 아무리 사소한 것이라도 동료에게 편하게 질문할 수 있는 환경이 굉장히 중요하며, 이러한 문화가 잘 정착되어있는 팀이라면 그 팀의 생산성은 굉장히 좋을 것이 분명하다.
떠오르는 이유를 몇 가지 적어보자면,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;회사에서 발생한 문제는 함께 일하고 있는 동료들이 상세하게 알고 있을 확률이 매우 높다.&lt;/li&gt;
  &lt;li&gt;인터넷에 존재하는 솔루션은 대부분 범용적인 상황에 대한 것이며, 회사의 상황에 맞게 재해석해야 하는 과정이 필요할 확률이 높다.&lt;/li&gt;
  &lt;li&gt;회사의 동료들은 같은 목적을 가지고 함께 시간을 사용하고 있으므로 서로의 생산성을 끌어 올리는 것이 가장 중요하다.&lt;/li&gt;
  &lt;li&gt;동료가 어떤 것을 모르는지를 알아야 문서를 보강하던, 온보딩을 보강하던 어떠한 대책이라도 세울 수 있어진다.&lt;/li&gt;
  &lt;li&gt;몰입을 깨준다. 몰입의 장점도 분명히 많지만, 단점도 많다. 예시를 하나 들자면, 한 문제에 꽂혀 시야가 매우 좁아질 수 있다. 시야를 넓게 가지면 쉽게 해결될 문제가 많다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;질문자를 쉽게 비난해 질문하기를 꺼리는 문화가 팀에 정착된다면 위의 장점들을 모두 누리지 못하고 사일로 현상이 심해지며, 한번 생긴 이러한 심리적인 장벽은 다시 허물기 위해 매우 많은 시간과 노력이 필요하다.
계속해서 강조하지만, 회사에서 일할 때는 생산성이 가장 중요하다. 이러한 이유로 알아서 찾아보고 될 때까지 해보다가 안 되면 그때 질문하라는 마인드를 가진 사람들과는 함께 일하기가 꺼려진다.&lt;/p&gt;
</description>
			<pubDate>Sat, 19 Nov 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-11-19-diary-47/</link>
			<guid isPermaLink="true">/diary/2022-11-19-diary-47/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>대기업들이 시장에 MSA라는 독을 풀었다</title>
			<description>&lt;p&gt;요즘 여러 채용 공고를 보면 기업 규모도 작은데 맹목적으로 MSA, 쿠버네티스 등의 키워드를 남발하는 경향이 있습니다. 
MSA는 몇몇 대기업에게는 매우 유용한 방법론일 수 있지만, 스타트업이나 중소기업들이 그저 대기업을 흉내내기 위해 쉽게 따라하는 것은 절대적으로 지양해야 합니다.&lt;/p&gt;

&lt;p&gt;저는 현재 시리즈 B 규모의 스타트업에 근무하고 있으며, MSA를 모듈형 모놀리식 아키텍처로 전환하는 작업을 진행하고 있습니다. 
제가 입사 후 가장 큰 문제로 제기했던 것은 서버 비용인데, 당시 MSA로 인해 서버비가 매달 약 4,000만원 가량 발생하고 있었으며, 많은 마이크로서비스가 통폐합된 현재는 한달에 약 2,000만원 가량의 서버 비용이 발생하고 있는 상황입니다. 
자금 흐름이 중요한 스타트업에 이 정도의 서버 비용이 얼마나 큰 부담이 될지는 대부분 아시리라 생각합니다. 그리고 아직도 비용을 절감할 포인트는 굉장히 많이 남아있는 상황입니다.&lt;/p&gt;

&lt;p&gt;서버비 외의 다른 문제들도 많은데, 간단한 테스트를 위해 로컬 환경에 항상 다수의 마이크로서비스를 실행해야만 하는 큰 번거로움이 있으며, 각 마이크로서비스 간 의존성으로 인한 시스템 복잡도도 굉장한 수준입니다. 서비스가 많은 만큼 배포도 굉장히 복잡합니다. 
서버에서 많은 서비스들이 실행되고 있으나 트래픽이 많지 않아 서버의 컴퓨팅 리소스를 100% 효율적으로 사용하지 못하고 낭비하고 있기도 하며, 에러가 발생하면 각 마이크로서비스를 넘나들며 디버깅을 해야만 하는 일이 생기기도 합니다.&lt;/p&gt;

&lt;p&gt;관리 포인트가 이렇게 많아지니 근무중인 개발자가 적은 스타트업에서는 개발자들에게 굉장한 부담을 주고 있기도 합니다.&lt;/p&gt;

&lt;p&gt;나열된 이 모든 낭비되는 비용들은 이전 라운드에 근무하던 CTO가 합당한 근거 없이 무리하게 MSA를 도입한 바람에 발생한 문제들입니다.
시리즈 B에 진입하며 새로 입사하신(저를 포함한) 모든 개발자분들은 MSA가 문제라는데에 모두 공감하셨고 MSA를 모듈형 모놀리식 아키텍처로 전환하는데 동의하게 됐습니다.&lt;/p&gt;

&lt;p&gt;이 잘못된 단 한번의 결정으로 인해 회사는 회복하기 힘든 굉장한 손해를 입었으며, 근 1년간 이 손해를 메꾸기 위한 작업들이 진행중이고, 이 작업은 아직도 끝이 보이지 않습니다.
마지막으로, 무리하게 MSA를 도입했던 CTO는 이에 대한 책임은 하나도 지지 않고 퇴사하며 자신의 커리어에 MSA 전환 경험 한 줄을 적어갔습니다.&lt;/p&gt;

&lt;p&gt;MSA로의 전환에 성공하고 MSA를 찬양하는 기업들에는 공통점이 있습니다. 
DB가 SPOF(Single Point of Failure)가 되었다는 점입니다. 
이러한 기업들은 트래픽과 데이터가 상상할 수 없을 정도로 많기 때문에 DB 장애가 자주 발생하고, 이 장애가 모든 서비스로 전파되어 MSA 전환을 생존 과제로 여겼으며, 결국 성공했습니다. 
그래서 MSA로 전환에 성공한 기업들의 성공 이야기에는 DB를 분리하는 작업이 핵심적으로 언급됩니다.&lt;/p&gt;

&lt;p&gt;웹 애플리케이션 서버는 DB가 ACID를 보장해주기 때문에 대량의 외부 요청이 입력되어도 스케일아웃을 통해 CPU와 I/O 부하를 아주 쉽게 분산시킬 수 있습니다.
하지만 DB는 컴퓨터 부품 중 가장 느린 하드 디스크와 직접적으로 상호작용하며 읽기와 쓰기 작업을 수행하기 때문에 작업 속도가 굉장히 느리며, 데이터의 정합성을 보장해줘야하는 막중한 책임을 갖기 때문에 스케일아웃을 통한 부하 분산이 너무 어렵습니다. 
예를 들어, 스케일아웃을 해 A와 B라는 두 개의 DB가 존재한다면, A라는 DB에 데이터를 쓰는 즉시 A와 B 두 DB의 데이터가 상이해집니다. 
이러한 문제를 해결하기 위해 A와 B 두 DB의 데이터를 항상 동기화해줘야하는 기술적인 과제가 발생하며, 이 과제는 해결하기가 굉장히 어렵습니다. 
이렇게 DB를 스케일아웃하면 읽기와 쓰기 시 각 DB 간 데이터의 정합성을 맞추기가 어려워지므로 DB에서 스케일아웃은 효율적이지 않습니다.
이러한 이유로 DB에서는 스케일업을 통한 해결을 주로 시도합니다. 
메모리는 전기 신호를 통해 모든 작업을 빛의 속도로 처리할 수 있지만, HDD는 디스크 암이 대상 섹터가 위치한 실린더로 이동하고 디스크 헤드가 섹터의 위치에 도달해야 데이터를 읽거나 쓸 수 있기 때문에 빛의 속도에 비해 너무 느리게 동작합니다. 
이런 디스크 I/O 시간은 웹 애플리케이션의 API 지연 시간에 추가되며, 디스크 I/O로 인한 지연은 대체로 ms~s 이상의 아주 큰 시간입니다. 
SSD를 사용하면 메모리만큼은 아니더라도 그에 준하게 빨라질 수 있지만 대용량 스토리지를 전부 SSD로 대체하는 것은 비용이 많이 들기 때문에 아직도 많은 기업에서는 HDD를 사용하고 있습니다. 
이렇게 느린 디스크 I/O를 최소화하기 위해 메모리를 증설하고 메모리에 데이터를 적극적으로 캐싱해 디스크 I/O를 최소화합니다.&lt;/p&gt;

&lt;p&gt;추가로 DB의 성능이 충분하지 않을 경우, 테이블을 컴팩트하게, 정규화 이론에 따라 재설계하고, 인덱스를 설계하고 쿼리를 튜닝하는 등의 작업도 시도 할 수 있습니다. (이러한 작업들이 아주 잘 된다면 대체로 DB로 인한 성능 문제를 겪지 않을 겁니다.) 
예를 들어, 1억 개의 레코드가 있는 테이블에서 8바이트 크기의 컬럼 하나를 제거하는것만으로 스토리지 용량이 약 1GB 절약될 수 있습니다. 
또한, 레플리케이션과 테이블 파티셔닝을 효율적으로 적용하여 읽기 요청을 여러 슬레이브 노드에 분산시키면 각 슬레이브 노드가 특정 테이블에만 액세스할 수도 있으므로 OS 캐시도 효과적으로 활용될 수 있습니다. 
조금 더 자세히 설명하자면, 한 슬레이브 노드가 A 테이블을 스캔하고 A 테이블의 데이터를 메모리에 캐싱한 상태에서 B 테이블에 대한 액세스 요청이 들어올 경우 B 테이블의 데이터도 메모리에 캐싱하려 할 수 있습니다. 
이때, 메모리 부족으로 페이지 스왑이 발생한다면 메모리에서 A 테이블의 데이터를 비우고 B 테이블의 데이터를 캐싱하게 됩니다. 
이렇게 되면 다음 읽기시 페이지 폴트가 발생할 확률이 높아지고 결국 여러 이유로 인해 디스크 I/O가 빈번하게 발생하게 됩니다. 
그러나 해당 슬레이브 노드가 계속해서 A 테이블만 액세스한다면, 처음 액세스 이후로는 이미 필요한 데이터가 메모리에 캐싱되어 있을 확률이 높기 때문에 디스크 I/O가 최소화됩니다.&lt;/p&gt;

&lt;p&gt;하지만 위의 모든 작업을 수행해도 여전히 DB 장애가 발생한다면, 그 기업은 아주 높은 확률로 이미 많은 사용자와 트래픽, 데이터를 다루는 큰 기업일 것입니다. 당연히 개발자도 많을겁니다. 
이런 상황에서야 비로소 MSA로의 전환을 고려할 수 있는 최소한의 요건을 충족한다고 볼 수 있습니다. 
또한, MSA 전환으로 인해 레디스, 몽고DB, 엘라스틱서치 등과 같이 각 서비스에 특화된 효율적인 DB를 사용할 수 있게 될수도 있습니다. 
시간이 지난 후에 분리된 DB가 다시 커진다면 이러한 작업을 반복해 여러 개의 마이크로서비스로 다시 분리할 수 있을 겁니다. 
(전 세계적으로 유명한 MAANG 기업들의 사례를 상기해보면 그들의 마이크로서비스는 전 세계에 네트워크처럼 퍼져있습니다.)&lt;/p&gt;

&lt;p&gt;이제 도커와 쿠버네티스에 대해 생각해보겠습니다. 
도커는 대표적인 컨테이너 기술로, 프로세스를 컨테이너로 감싸고 독립적인 환경에서 동작하는 것처럼 격리해 한정된 컴퓨팅 리소스를 사용할 수 있도록 제한해줍니다.
원래 도커가 탄생하게 된 계기는 이식성이었습니다. 내 로컬에서는 되는데 배포만 하면 안되네? 라는 문제가 있었던 것이죠. 근데 이 문제는 JVM 기반의 언어들에 대해서는 해당사항이 없습니다.
그렇다면 도커를 사용함으로써 얻을 수 있는 다른 효과는 프로세스들이 한정된 컴퓨팅 리소스를 사용하도록 강제하는 것인데요, 그러나 이러한 효과를 충분히 누리기 위해서는 서버에 여러 개의 프로세스가 떠 있어야 한다는 요구사항이 있어야 합니다. 
그리고 이러한 요구사항이 생길만한 대표적인 사례는 MSA라고 볼 수 있습니다. 하나의 서버에서 여러 개의 프로세스를 운영해야 하는 경우입니다. 
하지만, 모놀리식 아키텍처로 개발하고 서버에 단일 프로세스를 유지하는 것이 컴퓨팅 리소스를 최대한 활용하는 효율적인 방법일 수 있습니다. 
왜냐하면, 서버에 필요 이상으로 많은 프로세스가 실행된다면 CPU 스케쥴링과 컨텍스트 스위칭으로 인한 오버헤드가 극대화될 수 있기 때문입니다. 
게다가 단일 프로세스였다면 메모리 내 함수 호출로 끝났을 작업들이 IPC를 통해 이뤄져야 하므로 이 또한 추가적인 오버헤드를 유발합니다. 
이러한 이유들로 컨테이너 기술은 데이터가 많지 않고 서비스가 작은 대부분의 기업에서는 필요하지 않을겁니다. 
(도커가 로컬 개발 환경 구축에 유용하다는 주장에는 이견의 여지가 없다고 생각합니다.)&lt;/p&gt;

&lt;p&gt;쿠버네티스는 왜 사용할까요? 
예를 들어, 하나의 프로세스를 두 개로 분리하여 서버에 A와 B라는 두 개의 프로세스를 컨테이너로 띄웠다고 가정해봅시다. 
A 프로세스에 트래픽이 집중되어 자신에게 주어진 컴퓨팅 리소스가 부족해진다면, 서버 관리자는 B 프로세스에서 일부 리소스를 뺏어와 A 프로세스에 할당해야 합니다. 
이러한 작업을 수동으로 수행하는 것은 번거로울 뿐만 아니라 복잡합니다. 
이런 이유로 쿠버네티스라는 기술이 등장했습니다. 
쿠버네티스는 컨테이너 오케스트레이션을 제공하여 자동으로 리소스 관리와 프로세스 간의 상호 작용을 관리합니다. 
이를 통해 프로세스 간 리소스 조정이 자동화되어 효율적으로 운영됩니다. 
그러나 쿠버네티스 역시 컨테이너를 사용하지 않으면 필요가 없는 기술입니다. 
결과적으로 MSA로의 전환이 전혀 필요하지 않은 대부분의 기업에서는 도커와 쿠버네티스는 유의미한 효과를 가져다주기 힘들겁니다.
나중에 회사가 커졌을 때, 정말 필요할 때 학습하고 도입해도 늦지 않습니다.&lt;/p&gt;

&lt;p&gt;MSA를 도입하는 결정을 내리기 전에 기업의 현재 상황과 요구사항을 신중하게 고려하고, MSA가 정말로 필요한지 신중하게 검토해야 합니다. 
데이터베이스와 서버의 성능 개선을 통해 문제를 해결할 수 있는지, 기업의 규모와 트래픽이 반드시 MSA로 전환해야 하는 수준인지 등을 고려해야 합니다. 
필요한 경우에는 MSA를 도입하되, 그 결정은 신중하게 내려야 합니다.&lt;/p&gt;
</description>
			<pubDate>Wed, 19 Oct 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-10-19-diary-46/</link>
			<guid isPermaLink="true">/diary/2022-10-19-diary-46/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>IntelliJ failed to start with code 3</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#-문제&quot; id=&quot;markdown-toc--문제&quot;&gt;🚨 문제&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#-원인&quot; id=&quot;markdown-toc--원인&quot;&gt;🚧 원인&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#-해결&quot; id=&quot;markdown-toc--해결&quot;&gt;✅ 해결&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;-문제&quot;&gt;🚨 문제&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;오늘부터 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JetBrains&lt;/code&gt; 의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Fleet&lt;/code&gt;이 공개 테스트에 돌입했다.
Fleet은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;에디터 모드&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스마트 모드&lt;/code&gt;로 나뉘는데, 처음 켜질때는 에디터 모드로 켜져 매우 빠르게 실행되고, 스마트 모드를 키게되면 IDE가 된다.
아는 동생이 윈도우 환경에서 Fleet을 설치한 후 스마트 모드를 키자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IntelliJ failed to start with code 3&lt;/code&gt; 라는 에러가 발생하며 켜지지 않았다.&lt;/p&gt;

&lt;h1 id=&quot;-원인&quot;&gt;🚧 원인&lt;/h1&gt;

&lt;p&gt;로그를 뽑아보니 다음과 같은 내용이 출력됐다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fleet.controller.ManagedProcessAbnormalExitException: Process &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;cmd, /C, fleet_backend.bat, FleetStarter, 127.0.0.1, 56803, f1trui9nu21hj7qr2inf, 9vm2eafrfakbegbp59ea] finished with &lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;code 3. Check log &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;details.
intellij backend
3
at fleet.controller/fleet.controller.ProcessHolder.start&lt;span class=&quot;nv&quot;&gt;$lambda&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;FleetController.kt:103&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.CompletableFuture.uniWhenComplete&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.CompletableFuture&lt;span class=&quot;nv&quot;&gt;$UniWhenComplete&lt;/span&gt;.tryFire&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.CompletableFuture.postComplete&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.CompletableFuture.postFire&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.CompletableFuture&lt;span class=&quot;nv&quot;&gt;$UniHandle&lt;/span&gt;.tryFire&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.CompletableFuture&lt;span class=&quot;nv&quot;&gt;$Completion&lt;/span&gt;.exec&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.ForkJoinTask.doExec&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.ForkJoinPool&lt;span class=&quot;nv&quot;&gt;$WorkQueue&lt;/span&gt;.topLevelExec&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.ForkJoinPool.scan&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.ForkJoinPool.runWorker&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
at java.base/java.util.concurrent.ForkJoinWorkerThread.run&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Unknown Source&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로그를 보아하니 스마트 모드가 백그라운드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인텔리제이&lt;/code&gt;를 켜서 써먹는 것 같은데, cmd로 인텔리제이를 킬때 제대로 켜지지 않은걸로 보인다.&lt;/p&gt;

&lt;h1 id=&quot;-해결&quot;&gt;✅ 해결&lt;/h1&gt;

&lt;p&gt;Fleet을 설치하기 위해 별도로 설치한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JetBrains ToolBox&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;관리자 권한으로 실행&lt;/code&gt;하니 해결됐다.&lt;/p&gt;
</description>
			<pubDate>Wed, 12 Oct 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/debugging/2022-10-12-debugging-17/</link>
			<guid isPermaLink="true">/debugging/2022-10-12-debugging-17/</guid>
			
			
			<category>debugging</category>
			
		</item>
		
		<item>
			<title>클린 코드, 기술 부채, 성공적인 프로젝트</title>
			<description>&lt;p&gt;프로젝트를 일정하게 예측 가능한 속도로 개발하기 위해서는 유지 보수성이 뛰어난 코드가 필수적인데, 클린 코드는 프로젝트의 유지 보수성을 향상시켜주고 이는 기술 부채를 감소시키는 선순환을 일으켜 프로젝트가 성공적으로 진행 될 수 있게 도와준다.&lt;/p&gt;

&lt;p&gt;차를 운전한다고 가정해보자. 
차에 아무런 문제가 없고, 목적지까지의 도로가 아주 깨끗하게 관리되어 있으며, 다른 차들도 거의 없어 교통정체조차 일어나지 않는다면 목적지에 도착하는 시점을 꽤 정확하게 예측할 수 있을 것이다. 
하지만 목적지까지 운전하는 도중 자연재해로 도로가 파손되어 먼 길을 돌아가야 한다거나, 차에 문제가 생겨 중간에 정비소에 들러야 한다면 도착 시점을 특정하기가 매우 어려울 것이다.&lt;/p&gt;

&lt;p&gt;소프트웨어 개발도 이와 비슷하다. 
일정하게 예측 가능한 속도로 개발하기 위해서는 기존의 코드를 최대한 짧은 시간 안에 최대한 정확하게 파악할 수 있어야 한다. 
그래서 소프트웨어 개발에서 코드의 가독성은 매우 중요한 요소 중 하나이다. 
코드를 파악하기도, 기존의 코드를 수정하기도 매우 어렵다면 새로운 요구사항이 들어올 때마다 그동안 차곡차곡 쌓아왔던 기술 부채를 해결하기 위한 추가적인 작업을 거쳐야 할 것이고, 이러면 요구사항에 대한 중요한 개발 작업은 매끄럽게 진행될 수 없을 것이다.&lt;/p&gt;

&lt;p&gt;기술 부채는 개발자의 올바르지 않았던 결정이나, trade-off를 고려한 적당한 타협의 결과로 생긴 소프트웨어의 결함을 의미한다.
대부분의 부채는 이자를 유발하는데, 코드는 지금 바꾸는 것보다 미래에 변경하는 것이 대부분 더 어려우므로 부채라는 단어가 딱 어울린다. 
기술 부채가 발생했다는 것은 내일은 코드를 수정하기가 더 어렵고 내일모레는 더더욱 어려워질 것이라는 의미이다.&lt;/p&gt;

&lt;p&gt;개발팀이 제시간에 클라이언트가 원하는 것을 제공할 수 없어 기존의 코드를 개선하기 위해 멈춘다는 것은 기술 부채에 대한 이자를 지불한다는 뜻이다. 
기술 부채는 지금 당장 정신 사납게 시끄러운 경고음을 내는 그런 문제는 아니다. 기술 부채는 프로젝트에 전역적으로 흩어져 있는 잠재적인 문제이며, 이것들은 언젠가 깨어나 프로젝트 진행에 제동을 거는 돌발 변수가 될 것이다.
현재 본인이나 동료가 마주친 문제는 과거에 잘못 작성 된 코드로 인해 발생한 문제일 수도 있다. 
그러니 코드를 작성할 때, 현재 마주친 문제를 적절하게 해결하기 위해 충분한 시간을 투자하지 않고 또 다시 지름길로 가기로 결정한다면 그 코드를 유지 보수하게 될 미래의 본인이나 동료가 어떠한 어려움을 겪게 될지 한 번쯤은 충분한 시간을 들여 고민을 해 보자.&lt;/p&gt;
</description>
			<pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-09-24-diary-45/</link>
			<guid isPermaLink="true">/diary/2022-09-24-diary-45/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>파이썬 종속성 충돌 문제 원인 및 해결</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#원인&quot; id=&quot;markdown-toc-원인&quot;&gt;원인&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#해결&quot; id=&quot;markdown-toc-해결&quot;&gt;해결&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;원인&quot;&gt;원인&lt;/h1&gt;

&lt;p&gt;다음과 같은 모듈간 의존 구조가 있다.
개발중인 프로젝트가 모듈 A를 의존하는데, 모듈 A는  모듈 B(v1.1)을 의존한다. (module A → module B(v1.1))
그리고 프로젝트가 별도로 모듈 B(v1.0)을 직접적으로 의존하는 상태이다. (PROJECT → module(v1.0))&lt;/p&gt;

&lt;p&gt;그렇다면 프로젝트는 v1.0과 v1.1의 두 모듈 B중 어떤 모듈을 사용해야 할까?
이러한 상황을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dependency conflict&lt;/code&gt; 라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/192101675-b53ba734-fd08-4be0-b38c-948365280130.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;실제로 이러한 상황이 발생하면 pip에서는 다음과 같은 에러 메시지를 출력한다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The conflict is caused by:
    The user requested google-auth&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;2.6.0
    google-api-core 2.2.2 depends on google-auth&amp;lt;3.0dev and &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;1.25.0
    google-api-python-client 2.2.0 depends on google-auth&amp;lt;2dev and &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;1.16.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;해석을 해보면, 유저가 google-auth 2.6.0을 사용하겠다고 requirements.txt에 명시해뒀으나, google-api-core와 google-api-python-client가 google-auth 2.6.0이 아닌 다른 버전을 또 의존하고 있고, 
이러한 다른 버전들을 가져오려고 하고 있기 때문에 google-auth==2.6.0 라는 구문과 충돌이 나는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;해결&quot;&gt;해결&lt;/h1&gt;

&lt;p&gt;pip는 다음과 같은 해결 방식을 제시한다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;To fix this you could try to:
1. loosen the range of package versions you&lt;span class=&quot;s1&quot;&gt;'ve specified
  (종속성 버전을 특정하지 말고 느슨하게 한다)
2. remove package versions to allow pip attempt to solve the dependency conflict
  (pip가 종속성 충돌을 해결할 수 있도록 패키지 버전을 제거한다)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/192101769-d6b72149-72bd-4c59-816b-72378a24ec1c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;requirements.txt&lt;/code&gt; 에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;google-auth==2.6.0&lt;/code&gt; 을 제거한다면 모듈 A가 2.6.0이 아닌 google-auth를 가져오려 해도 충돌날 일이 없다.&lt;/p&gt;

&lt;p&gt;혹은, == 연산자로 종속성 버전을 특정하지 말고 &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;= 등의 연산자로 느슨하게 잡는다.&lt;/p&gt;

&lt;p&gt;최근에 자바 진영에서 많이 사용되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gradle&lt;/code&gt;은 이러한 문제를 해결하기 위해 의존 구조에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가시성&lt;/code&gt;을 부여하는 방식을 도입했다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;compile&lt;/code&gt; 함수를 통해 모듈을 가져오면 하위 모듈을 모두 가져오는 셈인데(compile 함수는 최신 버전의 Gradle에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deprecated&lt;/code&gt; 되었으며, 이러한 동작을 원한다면 api 함수 사용을 권장한다), 최근 Gradle에서 강력하게 권장하는 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;implementation&lt;/code&gt; 으로 모듈 A를 가져오면, 실제로 모듈 B도 함께 가져와지지만 프로젝트는 모듈 B의 존재를 모르게 된다.
파이썬 진영에서는 이러한 방식을 사용하고 있는지 검색을 해봤으나, 이에 대해 찾지 못했다. 아마 pip의 가이드를 통해 추측하기로는 아직 가시성을 활용하는 방식이 지원되지 않고 있는게 아닐까?&lt;/p&gt;
</description>
			<pubDate>Sat, 24 Sep 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/backend/python/2022-09-24-pip-dependency-conflict/</link>
			<guid isPermaLink="true">/backend/python/2022-09-24-pip-dependency-conflict/</guid>
			
			
			<category>backend</category>
			
			<category>python</category>
			
		</item>
		
		<item>
			<title>파이썬 내장 함수 round()는 왜 생각과 다르게 동작하는가?</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#사사오입-오사오입&quot; id=&quot;markdown-toc-사사오입-오사오입&quot;&gt;사사오입? 오사오입?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;사사오입-오사오입&quot;&gt;사사오입? 오사오입?&lt;/h1&gt;

&lt;p&gt;파이썬 내장함수 학습 테스트 도중 알게 된 내용이다. 보통 round 함수는 반올림으로 사용 되는데, 파이썬에서는 생각과 다르게 동작하는 부분이 있었다.&lt;/p&gt;

&lt;p&gt;파이썬 인터프리터에 round(1.5)라는 코드를 넘기면 예상대로 반올림 된 값인 2가 반환된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/191527526-dc146bea-eeeb-4caa-9da2-793f7b01875e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 round(2.5)를 넘기면 3이 아닌 2가 반환된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/191527572-9bab1272-02e7-4502-9348-b7315752a6a9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;왜 이러한 현상이 발생하는지 문서를 찾아봤다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.python.org/3/library/functions.html#round&quot; target=&quot;_blank&quot;&gt;📜 Built-in Functions - Python 3.10.7 documentation&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;Return number rounded to ndigits precision after the decimal point. If ndigits is omitted or is None, it returns the nearest integer to its input.
For the built-in types supporting round(), values are rounded to the closest multiple of 10 to the power minus ndigits; if two multiples are equally close, rounding is done toward the even choice (so, for example, both round(0.5) and round(-0.5) are 0, and round(1.5) is 2).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;대상 값이 정확히 중간값이면 짝수가 나오는 방향으로 반올림한다는 내용이다.
즉, 2.5는 2와 3의 중간값이며 올림 할 경우 홀수인 3이 나오기 때문에, 2.5에서 내림하여 짝수인 2가 나오는 방향으로 연산이 된다는 것이다.&lt;/p&gt;

&lt;p&gt;이러한 방식을 오사오입이라고 부르는 듯하다. 
그리고 1~4면 버리고 5~9면 올리는, 흔히 우리가 생각하는 반올림을 옛날 용어로 사사오입이라고 불러왔으며, 이 용어를 대신해 사용되기 시작한 용어가 반올림이라고 한다.&lt;/p&gt;

&lt;p&gt;주변 아는 사람들 대여섯 명에게 round(2.5)를 실행하면 어떤 값이 반환될 것 같느냐고 질문했을 때, 모든 사람이 3이 반환 될 것이라고 대답했다. 물론 나도 그러했고… 
그럼 파이썬은 왜 이렇게 사람들의 직관에 반하는 이러한 연산 방식을 표준 내장 함수에 적용했을까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/191527593-558c579e-d74e-41dc-8fe9-486025b4e062.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러니까 통계학에서는 변량이 홀수보다 짝수가 많아야 오차가 더 작기 때문에 오사오입이 합리적인데, 파이썬이 수학과 통계 분야에서 많이 사용되기 때문인 듯 하다.&lt;/p&gt;

&lt;p&gt;그렇다면 대부분의 일반인들은 왜 수학과 통계 분야에서 사용되는 합리적인(?) 오사오입 방식이 아닌 사사오입 방식을 배우고 사용해왔는가?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/191527618-e16aeb4e-e9dd-40bd-8b96-0246525d4de7.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;맞는지는 잘 모르겠고, 내 주변 사람들에게 물어본 바, 단 한명의 예외도 없이 1~4는 버리고 5~9는 올린다고 답하는 것을 보면 그냥 이 방식이 사람한테 직관적이기 때문인 게 아닐까 싶기도 하다.&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/functions.html#round&quot; target=&quot;_blank&quot;&gt;📜 Built-in Functions - Python 3.10.7 documentation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.naver.com/PostView.naver?blogId=noseoul1&amp;amp;logNo=221592047071&amp;amp;redirect=Dlog&amp;amp;widgetTypeCall=true&amp;amp;directAccess=false&quot; target=&quot;_blank&quot;&gt;📜 반올림하는 두 가지 방법 (Round-off(사사오입), Round-to-nearest-even(오사오입))&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
			<pubDate>Wed, 21 Sep 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/backend/python/2022-09-21-function-round/</link>
			<guid isPermaLink="true">/backend/python/2022-09-21-function-round/</guid>
			
			
			<category>backend</category>
			
			<category>python</category>
			
		</item>
		
		<item>
			<title>두번째 직장 온보딩 회고</title>
			<description>
&lt;p&gt;원래 개발과 상관없는 일을 8년 정도 했고, 어머니 수술을 계기로 개발을 독학으로 5개월가량 공부했다.
그리고 첫 회사에서 1년 6개월 정도의 경력을 마무리하고 8월 16일부로 개발자로서 두 번째 직장에 출근을 시작했다.&lt;/p&gt;

&lt;p&gt;이번 주로 온보딩이 마무리되어 회고를 작성한다.&lt;/p&gt;

&lt;p&gt;현재 재직 중인 회사는 시리즈 B, 누적 투자 규모 약 300억원의 스타트업이며, 다음 라운드를 준비하고 있다. 
그리고 내가 이 회사에 입사하게 된 계기는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;팀 차원에서 기술 부채 청산을 생존의 관점으로 생각하고 있다
    &lt;ul&gt;
      &lt;li&gt;파이썬 2.7로 된 레거시를 자바 or 코틀린으로 갈아엎을 수 있는, 돈을 주고도 경험 해보지 못 할 값진 경험을 해볼 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;회사가 시장에서 경쟁력이 있다고 판단했다
    &lt;ul&gt;
      &lt;li&gt;새로운 투자를 받은 시기가 자이언트 스텝 이후였다&lt;/li&gt;
      &lt;li&gt;주관적으로 BM이 아주 좋다고 생각했다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기존에 다니던 회사보다 규모가 더욱 컸다
    &lt;ul&gt;
      &lt;li&gt;더 큰 규모의 IT 기업에서 일해보고 싶었다&lt;/li&gt;
      &lt;li&gt;규모가 더 큰 만큼, 대기업에서 오신 시니어 개발자분들도 다수 계셨다&lt;/li&gt;
      &lt;li&gt;도메인도 물론 중요하지만, 기술적인 역량은 도메인에 독립적이다
        &lt;ul&gt;
          &lt;li&gt;도메인 지식은 해당 분야에서 경력을 쌓으면 쌓을수록 자연스럽게 증대될 수 있다&lt;/li&gt;
          &lt;li&gt;기술적인 역량은 퇴근 후 개인의 노력이 가장 중요하지만, 경험이 풍부한 시니어들이 많으면 더욱 빠르게 증대될 수 있다&lt;/li&gt;
          &lt;li&gt;기술적인 역량은 부족한데, 도메인 지식만 풍부하면 다른 도메인으로 이직했을 때 아무것도 못하는 사람이 될 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런고로 나는 자바와 코틀린밖에 할 줄 모르지만… 최근에 파이썬(그것도 2.7이다)을 새로 학습해서 기존 시스템을 개선하는 데 심혈을 기울이는 중이다.&lt;/p&gt;

&lt;p&gt;기존 레거시가 파이썬 2.7에 자체 개발된 프레임워크(😒)라는 보기 드문 레거시라 신규 비즈니스 요구 사항을 충족시키는데 매우 많은 리소스가 점유 되고 있다. 
즉, 그린 필드였다면 5~10분이면 끝났을 작업도 이러한 브라운 필드에서는 몇 일씩 걸리는 작업이 될 수도 있는 것이다. 
아무튼, 스트레스를 꽤 많이 받을거라 예상하면서 들어왔지만, 오히려 생각보다 즐겁게 일하고 있다. 
왜 그런지 생각을 해봤는데, 일이라기보다는 전부 다 내 경험치로 보이는 상태에 더 가까운 것 같다. 
온보딩 기간이라 비중 있는 업무는 안할줄 알았지만, 생각보다 비중 있는 업무들을 맡고 있고 오히려 매우 만족스럽다. 
최근에는 퇴근 후에 하던 개인 공부 시간을 모조리 회사 레거시 개선에 쏟고 있다. 
그냥 회사에서도 일하고 집에서도 일하는데, 이게 일이라고 느껴지지는 않는다. 
이런 게 워라블인가 싶기도 하다. 🧐&lt;/p&gt;

&lt;p&gt;온보딩 기간 동안 느낀 점으로는 그동안 해온 CS 공부, 코드 카타 등이 이 정도의 브라운 필드에서도 비즈니스 요구 사항을 별 문제없이 충족시킬 수 있을 만큼 
내 하드 스킬을 확실하게 끌어 올려줬다고 생각하는 부분이 있고, 이렇게 애자일한 팀에서 일하는데 내 소프트 스킬이 생각보다 미흡하다고 느껴지는 부분도 있다. 
내 생각을 글로 풀어 쓰는 건 자주 해와서 익숙하고 편한데, 내 생각을 실시간으로 여러 사람에게 전달하는 건 생각보다 몹시 어렵다. 
컴퓨터만 붙들고 산 방구석 아싸의 한계에 봉착했다는 생각도 든다.&lt;/p&gt;

&lt;p&gt;현재는 회사 차원에서 기술 부채 청산에 많은 리소스를 투자하고 있기 때문에, 
내 작업의 상당수는 기존 레거시를 개선해서 우리 회사 임직원들의 업무 효율을 개선하는 쪽에 치중되어있다. 
이러한 작업을 하면서 역시 크게 느낀 부분은, 개발자라고 요구 사항만 넙죽넙죽 받아서 코딩만 하면 되는 게 아니라는 것이다. 
원래도 이러한 생각을 갖고 있기는 했는데, 이렇게 내 생각을 직접적으로 업무에 적용하고 그 여파를 느끼며 일해보는 건 또 처음이라 꽤 신선하다.&lt;/p&gt;

&lt;p&gt;IT 회사들은 아주 크게 보면 사업 -&amp;gt; 기획 &amp;lt;- 제품(디자인, 개발 등) 정도의 구조로 이뤄져 있다고 생각한다. 
사업은 회사가 돈을 벌어서 성장해나갈 수 있게 시장을 개척하는 사람들이다. 
그리고 이 사람들의 생각을 실제 제품으로 구현해 시장에서 임팩트를 내기 위해서는 디자이너, 개발자들이 필요한데, 문제는 이 사람들은 사업을 모르고, 사업하는 사람들은 디자인과 개발을 모른다. 
그러니 중간에서 이들을 조율해줄 수 있는 사람들이 필요한데, 이 사람들이 바로 기획이다. 
즉, 기획은 사업의 말을 제품 그룹이 잘 알아먹을 수 있게, 혹은 반대로 번역해주는 사람들에 가깝다. 
주로 요구 사항을 정리하는데 많은 시간을 쏟는 이유도 이와 일맥상통한다고 생각한다.&lt;/p&gt;

&lt;p&gt;문제는, 현재 우리가 하는 작업들의 주 목적은 우리 제품 그룹의 업무 효율을 개선하는 데 있기 때문에 중간에 기획이 없다. 
그래서 타 부서 동료들의 요구 사항이 우리에게 다이렉트로 넘어온다는 점이다. 
우리 개발자들은 타 부서 동료들이 어떻게 일하고 있는지 대체로 잘 모르며, 마찬가지로 타 부서의 동료들 또한 우리 개발자들이 어떻게 일하는지 잘 모른다. 
그러니 타 부서 동료들의 요구 사항이 딴에는 쉽다고 생각되어도 막상 개발로 넘어오면 굉장히 난해한 요구 사항이 될 수도 있는 것이다.&lt;/p&gt;

&lt;p&gt;어떻게 해결해야 할까? 답은 생각보다 간단하다. 개발자들이 직접 타 부서 동료들과 마주하고 그들이 어떻게 일하고 있는지 관심을 기울이면 된다. 
그럼 그들의 요구 사항이 더욱 명확하게 와닿기도 하고, 그들의 요구 사항보다 더욱 좋은 해결방안이 떠오르기도 한다. 
혹은 해당 요구 사항이 굳이 개발하지 않아도 되는지도 알 수 있으며(개발 자체가 비용이기 때문에, 때로는 아예 개발하지 않는 것이 더 좋은 경우도 분명 존재한다.), 혹은 해당 요구 사항이 굉장히 중요한 급 건인지도 알 수 있다. 
나 같은 경우엔 직접 요구 사항을 전해온 동료의 자리로 가 어떻게 일하고 있고, 무엇 때문에 불편한지 보여달라고 요구한다.&lt;/p&gt;

&lt;p&gt;최근에는 기억나는 작업 중 하나로는 어떤 업무를 자동화해달라는 요구를 받았는데, 티켓을 전달 받은 것이 아니고 해당 실무자분이 내 자리로 직접 와서 요구해 오셨다. 
그래서 대체 어떻길래 직접 찾아와가면서 요구를하시는지 궁금해 어떻게 일하고 계시는지 보여주실 수 있냐고 여쭤봤는데, 그 자리에서 바로 보여주시더라. 
구글 시트에서 고객의 휴대폰 번호를 복사해 우리 어드민에 붙여 넣은 다음 일부 상태를 변경하는 작업이었다. 
문제는 이걸 하루에 수백 번씩 반복하고 있다는 것이었고… 당연히 최대한 빠르게 처리해야 할 일이라는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이제 남은 문제는 어떻게 처리할 것인지였는데, 나는 우선 도메인 자체가 비효율적이기 때문에 이런 상황이 된 게 아닌가? 라는 의문을 가졌다. 
우리 모두의 업무 프로세스와 코드는 결국 도메인을 따라가기 때문에, 도메인이 명확하다면 업무 효율 개선에 큰 도움이 된다. 
하지만 나는 입사한 지 이제 2주 차였기 때문에 도메인에 대해 무지했고, 당장 이분들의 루틴한 업무를 개선해드리기 위해 도메인 파악을 먼저 하기에는 시간이 부족했다. 
아무리 봐도 나한테 하루에 수백 번씩 그 짓거리를 하라고 하면 나 같아도 지칠 것 같았다.
그러니 일단 땜질을 해서라도 빠르게 자동화부터 하고 보자는 생각이 들었고, 시스템 구조를 살펴봤는데, 또 SaaS가 너무 많이 붙어있어 모든 시스템을 자동화하기에는 공수가 굉장히 많이 들어갈 것으로 판단됐다.&lt;/p&gt;

&lt;p&gt;그래서 실무진분들과 미팅을 잡아, 이러한 상황을 설명해 드리고 생각할 시간이 약간 필요하다고 말씀을 드렸는데, 이분들이 &lt;strong&gt;“그러면 고객 휴대폰 번호만 보내드리면 쉽게 될수도 있나요?”&lt;/strong&gt; 라고 역제안을 해오시는 것이다.
내 입장에서는 그렇게 되면 그냥 어드민에 휴대폰 번호를 수신해서 상태 업데이트만 하면 끝나게 되기 때문에 매우 간단해지는 부분이었고. 
근데 나는 그게 어떻게 가능한지를 잘 몰라서 또 여쭤봤는데, 마케터분들이 쓰시는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;브레이즈(Braze)&lt;/code&gt;라는 툴이 그걸 가능하게 해줬나 보다.&lt;/p&gt;

&lt;p&gt;이 대목에서 나한테 어떤 부분이 부족한지를 또 느꼈었는데, 나는 아무래도 개발자다 보니 평소에 &lt;strong&gt;“필요하면 직접 만들지.”&lt;/strong&gt; 라는 마인드를 갖고 있는데, 그러다 보니 오히려 여러 가지 유용한 툴들을 잘 알지 못한다고 느꼈다.
오히려 개발을 모르시는 분들이기 때문에 유용한 노코드 툴들을 폭넓게 알고 활용하실 수 있는 건가? 싶기도 했고. 
내가 저런 유용한 도구들을 잘 알고 있고 이것들을 잘 활용할 수도 있고, 소통하는 데도 쓸 수 있다면 생산성이 많이 늘어날 수도 있겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이번 주 수요일에는 리팩토링 데이라 하여 CTO님과 다른 동료 개발자 한 분, 나까지 총 세 명이서 10인실을 종일 사용했다. 
알림톡 시스템을 어떻게 개선할지 계속해서 논의했고, 서로 키보드를 번갈아 잡아가며 코딩했다. 
식사는 배달을 시켜 먹었고, 그 날은 외부의 어떠한 인터럽트도 들어오지 않았다. 우리는 하루를 온전하게 리팩토링에 투자할 수 있었다.
굉장히 재미있고 유익한 시간이었다고 생각한다. 이러한 경험을 더 많이 할 수 있으면 좋겠다는 생각도 들었다.&lt;/p&gt;

&lt;p&gt;아무튼, 한 달 정도밖에 출근하지 않았지만, 현재로서는 이 회사가 굉장히 마음에 든다. 
요즘 좀 엉뚱한 생각을 하는데, 또라이 보존의 법칙이라고 직장을 좀 다니신 분들은 아실 것이다. 
근데 우리 회사에는 내가 볼 때 아무리 봐도 모난 사람이 딱히 없는 것 같은데, 이쯤 되니까 내가 또라이인 게 아닐까? 싶기도 하고…&lt;/p&gt;

&lt;p&gt;다음 달에는 회사 사무실이 역삼역 GFC로 이전한다. 
현재 사무실의 크기가 좁다는 생각은 안 드는데, 사무실 대비 인원이 많아지다 보니 사무실이 비좁게 느껴지기는 한다. 
특히 회의실… 그래서 회사 이전이 많이 기대된다.
여기서 질 좋은 많은 경험을 하고, 사업적으로나 개발적으로나 내 역량이 크게 좋아질 수 있기를 기원한다. 
물론 그만큼 내 시간과 노력도 많이 투자되어야 할 것이다.&lt;/p&gt;
</description>
			<pubDate>Sat, 10 Sep 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-09-10-diary-44/</link>
			<guid isPermaLink="true">/diary/2022-09-10-diary-44/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>인프콘 2022 - 인프런 아키텍처의 과거와 현재, 그리고 미래</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#인프런-아키텍처의-과거와-현재-그리고-미래&quot; id=&quot;markdown-toc-인프런-아키텍처의-과거와-현재-그리고-미래&quot;&gt;인프런 아키텍처의 과거와 현재, 그리고 미래&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#시즌-1&quot; id=&quot;markdown-toc-시즌-1&quot;&gt;시즌 1&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#시즌2&quot; id=&quot;markdown-toc-시즌2&quot;&gt;시즌2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#시즌3&quot; id=&quot;markdown-toc-시즌3&quot;&gt;시즌3&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#시즌4&quot; id=&quot;markdown-toc-시즌4&quot;&gt;시즌4&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#나의-qa&quot; id=&quot;markdown-toc-나의-qa&quot;&gt;나의 Q&amp;amp;A&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;인프런-아키텍처의-과거와-현재-그리고-미래&quot;&gt;인프런 아키텍처의 과거와 현재, 그리고 미래&lt;/h1&gt;

&lt;p&gt;부제: 적정 소프트웨어 아키텍처 (현실과 이상 사이 어딘가?)&lt;/p&gt;

&lt;h2 id=&quot;시즌-1&quot;&gt;시즌 1&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;자금과 동료가 없음(극초창기 스타트업) → 대표 혼자 모든걸 개발&lt;/li&gt;
  &lt;li&gt;직접 개발은 최소화하고 외부 자원을 적극활용(SaaS)&lt;/li&gt;
  &lt;li&gt;JQuery, PHP, WordPress, MySQL로 회원수 10만까지 버텼으나 한계가 느껴짐&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시즌2&quot;&gt;시즌2&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;개발자를 채용하여 SaaS를 걷어내고 모든 서비스를 다시 개발함 (BE1, FE1, DevOps1, 대표1)&lt;/li&gt;
  &lt;li&gt;BE = Java, FE = TS, DevOps = Go 등으로 기술 스택이 다양해지면 어느 분야 개발자가 단 한명이라도 빠질 경우 전체 개발 진행이 안되는 아주 큰 리스크가 존재함&lt;/li&gt;
  &lt;li&gt;따라서 모든 직군의 기술 스택을 JS로 통일하였음&lt;/li&gt;
  &lt;li&gt;3.5(0.5명은 대표님)명의 개발자가 5개월동안 전체 시스템을 워드프레스 → JS로 전환에 성공&lt;/li&gt;
  &lt;li&gt;JS로 변경 후 문제
    &lt;ul&gt;
      &lt;li&gt;코드만 봐서는 함수가 어떤 값을 반환하는지 알 수 없음&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;console.log&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디버그 모드&lt;/code&gt;를 활용해 코드를 파악해야만 함&lt;/li&gt;
      &lt;li&gt;테스트 코드를 작성하기가 불가능에 가까움&lt;/li&gt;
      &lt;li&gt;IDE의 도움을 받기가 힘듬(인터프리터 언어의 한계?)&lt;/li&gt;
      &lt;li&gt;BE와 FE가 싱글 레포에서 모두 관리되었음
        &lt;ul&gt;
          &lt;li&gt;FE를 수정해도 BE까지 영향이 감&lt;/li&gt;
          &lt;li&gt;BE를 수정해도 FE까지 영향이 감&lt;/li&gt;
          &lt;li&gt;Bundling, Reload 속도가 참을 수 없을정도로 느려짐&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;신규 입사자들이 기존의 코드를 이해하기가 점점 어려워짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시즌3&quot;&gt;시즌3&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;개발자들이 코드 수정에 자신감이 생기도록 개선해야함
    &lt;ul&gt;
      &lt;li&gt;테스트 코드, 정적분석 등을 도입&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;신규 입사자들의 진입장벽이 낮아지도록 메이저한 라이브러리, 패턴등을 사용하기로 함
    &lt;ul&gt;
      &lt;li&gt;언어를 TS로 변경&lt;/li&gt;
      &lt;li&gt;FE = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;React&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Next.js&lt;/code&gt;를 도입&lt;/li&gt;
      &lt;li&gt;BE = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nest.js&lt;/code&gt; &amp;amp; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TypeORM&lt;/code&gt; 도입&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Layered Architecture&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI&lt;/code&gt; 도입&lt;/li&gt;
      &lt;li&gt;FE, BE를 분리하여 서로 독립적으로 개발 할 수 있게끔 하기로 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어떻게 할 것인가?
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;빅뱅&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;서비스 개선을 중단하고 전체를 다시 만들어서 한번에 교체 → 약 1년 예상&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;점진적 개선&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;서비스 개선과 시스템 개편을 병행 → 약 2년 예상&lt;/li&gt;
          &lt;li&gt;서비스 성장속도가 가팔랐음(매년 약 200~300%)&lt;/li&gt;
          &lt;li&gt;회사의 압축 성장을 가속화 해야 하기 때문에 서비스를 중단 하기가 어려웠음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;교살자 패턴&lt;/code&gt;으로 서비스를 개선하기로 함. 즉, 점진적 개선 (달리는 마차의 바퀴를 갈아끼운다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;FE, BE 모노 레포를 신규로 생성하고 기존 코드를 점진적으로 이관 시키려 함
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;통합 IAM 시스템&lt;/code&gt;을 분리 개발 → &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;API Gateway&lt;/code&gt; 도입&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 계획을 짜고 코드 이관 작업을 시작
    &lt;ul&gt;
      &lt;li&gt;&lt;u&gt;3일동안 매일 2시간씩 서버가 죽는 장애가 발생&lt;/u&gt;&lt;/li&gt;
      &lt;li&gt;&lt;u&gt;한 기능의 작은 장애가 전체 시스템의 장애로 전파되기 시작함&lt;/u&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;시즌4&quot;&gt;시즌4&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;개발팀 구성
    &lt;ul&gt;
      &lt;li&gt;BE 8&lt;/li&gt;
      &lt;li&gt;FE 11&lt;/li&gt;
      &lt;li&gt;DevOps 4&lt;/li&gt;
      &lt;li&gt;CTO 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장애
    &lt;ul&gt;
      &lt;li&gt;어드민에서 ROW 50,000 정도의 엑셀을 다운받았더니 전체 시스템이 다운되는 경우도 발생&lt;/li&gt;
      &lt;li&gt;독립적으로 운영되는 서비스들을 분리하기로 결정하고 실행
        &lt;ul&gt;
          &lt;li&gt;서버의 메모리, CPU를 많이 점유하는 작업으로 인한 장애는 격리됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단일 RDB 구조&lt;/code&gt;로 인한 장애는?
        &lt;ul&gt;
          &lt;li&gt;분산 DB까지 도입하면 시스템 복잡도가 너무 크게 늘어남&lt;/li&gt;
          &lt;li&gt;트랜잭션 관리가 매우 어려워짐&lt;/li&gt;
          &lt;li&gt;기존 쿼리들도 모두 개선해야함&lt;/li&gt;
          &lt;li&gt;&lt;u&gt;지금 못하니까 시즌5에 하도록 하자&lt;/u&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;집중
    &lt;ul&gt;
      &lt;li&gt;시스템 복잡도를 극한으로 최소화&lt;/li&gt;
      &lt;li&gt;(구)인프런 레거시 개편&lt;/li&gt;
      &lt;li&gt;레거시 개편하며 발생하는 장애 트러블 슈팅&lt;/li&gt;
      &lt;li&gt;다양한 신규 요구 사항 커버&lt;/li&gt;
      &lt;li&gt;&lt;u&gt;기술 스택을 컴팩트하게 가져가 관리 포인트를 최대한 줄이자 (안 그래도 해야할게 많다)&lt;/u&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MongoDB Atlas&lt;/code&gt;로 검색엔진, Data Lake, 실시간 데이터 등을 모두 처리 &lt;u&gt;(최소 2~3년만 DB 장애 안나게 버티면서 다른거에 집중해보자)&lt;/u&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서비스 구조
    &lt;ul&gt;
      &lt;li&gt;(구)인프런&lt;/li&gt;
      &lt;li&gt;(신)인프런&lt;/li&gt;
      &lt;li&gt;통합 IAM&lt;/li&gt;
      &lt;li&gt;AWS SNS를 도입 → 멀티 구독&lt;/li&gt;
      &lt;li&gt;AWS SQS로 최종적인 일관성을 보장&lt;/li&gt;
      &lt;li&gt;Spring Boot를 도입하고 Back Pressure를 이용해 서버가 다운 되지 않게 대용량 데이터를 핸들링
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;🔔 Back Pressure ?&lt;/code&gt;: 클라이언트가 서버에 자신이 감당할 수 있는 만큼만 요청해서 처리할 수 있게 해주는 기술을 말한다. 한국어로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배압&lt;/code&gt; 또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;배압 조절&lt;/code&gt;로 번역되고 있으며 자바 진영에서 이러한 기술의 구현을 위한 스펙이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리액티브 스트림&lt;/code&gt;이다. 그리고, 이 스펙의 구현 중 하나가 그 유명한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리액터&lt;/code&gt;이고 스프링에서는 리액터를 사용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;웹 플럭스&lt;/code&gt;를 구현했다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;서버 → AWS SNS로 이벤트 발행이 실패하면?
        &lt;ul&gt;
          &lt;li&gt;이벤트 저장소를 중간에 두면 쉽게 해결할수는 있다&lt;/li&gt;
          &lt;li&gt;단, 시스템 복잡도가 너무 높아짐&lt;/li&gt;
          &lt;li&gt;&lt;u&gt;이번 시즌에는 이벤트 발행이 실패하면 로그를 확인해 수동으로 재 발행 하기로 결정&lt;/u&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;u&gt;현재는 시스템 복잡도를 최소화하고 (구)인프런을 모두 걷어내는데에 집중하고 있음&lt;/u&gt;
        &lt;ul&gt;
          &lt;li&gt;완벽한 시스템을 최초에 단번에 만들어 낼 수는 없다&lt;/li&gt;
          &lt;li&gt;시스템을 수시로 모니터링하며 점진적으로 고쳐 나간다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;나의-qa&quot;&gt;나의 Q&amp;amp;A&lt;/h2&gt;

&lt;p&gt;우리 회사는 현재 시리즈 B에서 누적 330억 규모의 투자를 받아 다음 라운드를 준비하고 있고, 파이썬 2.7로 된 레거시를 자바로 마이그레이션 하는 작업을 진행하고 있다. 하지만 서비스 개선 작업시 기존 레거시에 대부분의 리소스를 점유당하고 있다. 복잡하게 얽힌 의존성과 매우 나쁜 가독성으로인함이다. 상황이 이러하니 이 세션내내 내가 현재 재직중인 회사의 상황과 굉장히 비슷해서 매우 몰입하며 들었고, 대부분의 내용도 공감됐다.&lt;/p&gt;

&lt;p&gt;세션이 종료된 후 나는 세션 발표자인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이동욱(인프런 CTO)&lt;/code&gt;님께 다음과 같은 질문을 드렸고, 다음과 같은 답변을 들었다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Question&lt;/code&gt;: 우리 회사도 파이썬으로 된 레거시 시스템을 자바로 옮기고 있는데, 파이썬이라는 언어 자체가 잘못된 함수 호출을 막을 수가 없다. 또한 코드만 봐서는 함수에 어떤 값이 입력되고 어떤 값이 리턴되는지 알 수가 없기 때문에 코드를 파악하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print 함수&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디버그 모드&lt;/code&gt;를 활용해야만 한다. 무엇보다 테스트 코드를 작성하기가 너무 어렵다. 내가 생각하기엔 JS도 이와 크게 다르지 않을 것 같은데 어떻게 코드를 이관하고 있는지?&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Answer&lt;/code&gt;: JS역시 비슷하다. 테스트 코드를 완벽하게 작성하기가 불가능에 가깝다. 따라서 우리는 각 엔드 포인트마다 성공하는 케이스에 대해서만 테스트 코드를 작성하고 장애를 맞아가면서 강제로 코드를 옮겼다. 아마 파이썬도 크게 다르지 않을 것이라고 생각한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/187011300-d7e89161-d63d-490b-9d40-2dfc2e8e6894.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</description>
			<pubDate>Sat, 27 Aug 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-08-27-diary-43/</link>
			<guid isPermaLink="true">/diary/2022-08-27-diary-43/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>Git - HEAD &amp; Branch &amp; Tag</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#git의-구조---head--branch--tag&quot; id=&quot;markdown-toc-git의-구조---head--branch--tag&quot;&gt;Git의 구조 - HEAD &amp;amp; Branch &amp;amp; Tag&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#head&quot; id=&quot;markdown-toc-head&quot;&gt;HEAD&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#branch&quot; id=&quot;markdown-toc-branch&quot;&gt;Branch&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tag&quot; id=&quot;markdown-toc-tag&quot;&gt;Tag&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;git의-구조---head--branch--tag&quot;&gt;Git의 구조 - HEAD &amp;amp; Branch &amp;amp; Tag&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;git은 이 글을 쓰는 시점(2022년 8월), 세계에서 가장 많이 쓰이는 VCS(Version Control System)중 하나이며, 실무에서는 원활한 협업을 위해 아주 많이 쓰이고 있다.&lt;/p&gt;

&lt;p&gt;그리고 원활한 협업을 위해 보통 branching을 통해서 작업을 하게 되는데, git에 대한 이해가 부족하다면 굉장히 곤혹스러운 상황들이 많이 생길 수 있다. 그런 상황을 미연에 방지하기 위해, 혹은 이미 한번이상 겪어봤다면 이후에는 곤혹스럽지 않기 위해 git에 대한 깊은 이해가 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;head&quot;&gt;HEAD&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;우선 HEAD에 대해 알아야 한다.&lt;/p&gt;

&lt;p&gt;HEAD는 아주 단순하다. HEAD는 현재 우리가 바라보고 있는 commit을 의미한다.&lt;/p&gt;

&lt;p&gt;그냥 단순히 git checkout 명령어를 통해 특정 commit, branch, tag등으로 이동하면 HEAD가 옮겨진다고 이해하면 되겠다.&lt;/p&gt;

&lt;p&gt;다음과 같은 git history가 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184530841-6582a16f-152e-4c23-8d4a-eb7b80712426.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cd ./git&lt;/code&gt; 명령을 통해 이동하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HEAD&lt;/code&gt;라는 파일이 존재하는데, 해당 파일의 내용을 출력해보면 main branch를 가리키고 있음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184531114-bac061f1-7a82-43df-b1be-0922002fb82b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout de70330&lt;/code&gt;을 입력하여 HEAD를 옮긴 후 다시 HEAD 파일의 내용을 출력해보면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184531283-99174eb7-e251-485f-b711-0d566991b753.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이전에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;refs/heads/main&lt;/code&gt;을 가리키고 있었지만, 이제는 그냥 특정 commit을 가리키게 바뀌었음을 알 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;branch&quot;&gt;Branch&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;branch도 정말 별거 없다.&lt;/p&gt;

&lt;p&gt;git은 단순히 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;단방향 연결리스트(Singly Linked List)&lt;/code&gt;구조로 만들어져있는 commit의 나열일 뿐이며, branch는 특정 commit을 기록하고 있는 파일일 뿐이다. 최초의 commit을 제외한 모든 commit은 부모 commit이 존재하며, 모든 commit의 부모 commit은 일반적으로 1개이고, merge commit에 한해 최대 2개까지만 존재할 수 있다. (두 부모 commit을 병합(merge)하여 만들어내는 commit이기 때문)&lt;/p&gt;

&lt;p&gt;즉, 모든 commit이 가질 수 있는 최대 부모의 개수는 2개이다.&lt;/p&gt;

&lt;p&gt;또한, 모든 commit은 오직 자신의 부모만 알 수 있으며, 자식의 존재는 알지 못한다. 즉, 자식 commit으로 탐색을 해나갈 수 없기 때문에 특정 commit을 참조하는 포인터에서 history를 출력하면 실제로는 .git 디렉토리에 모두 저장돼있지만 화면에서는 자식 commit들을 볼 수 없는것이다. 그리고 우리는 이것을 작업이 날아갔다고 인식하게 된다. (실제로는 그렇지 않다. 명심하자!)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184530841-6582a16f-152e-4c23-8d4a-eb7b80712426.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 git history 이미지를 보면 HEAD가 main branch를 가리키고 있고(HEAD -&amp;gt; main), main branch가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa28560&lt;/code&gt; commit을 가리키고 있음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git reset&lt;/code&gt;명령어등을 통해 이 branch가 가리키고 있는 commit을 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git log&lt;/code&gt;명령어를 입력하면 branch가 가리키고 있는 commit의 시조(??) commit까지의 그래프를 보여주는것이다.&lt;/p&gt;

&lt;p&gt;모든 branch의 정보는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[project]/.git/refs/heads&lt;/code&gt;에 파일로 존재하며, 현재 데모 프로젝트에는 main밖에 없으므로 main 파일하나만 존재함을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184531493-4ae7eb7e-8065-4eb3-8cb9-682da08d5f4a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tag&quot;&gt;Tag&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;같이 협업을 하다가 동료와 커뮤니케이션이 잘 되지 않아 merge가 잘못 된 경우 이를 해결하기 위해서나, 본인이 commit을 잘못하여 reset등의 작업을 하는 경우가 종종있는데, 이때 실수하여 작업이 날아가는 경우가 존재한다.&lt;/p&gt;

&lt;p&gt;하지만 걱정마시라, 이전 포스팅에서 git의 가장 기본적인 요소가 되는 object들인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tree&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob&lt;/code&gt;에 대해 작성했었는데, 이전 글에서는 다음과 같이 이야기했었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위의 세 가지 오브젝트들은 사용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git&lt;/code&gt; 디렉토리를 직접적으로 조작(예: rm -rf .git)하지만 않는다면 절대 수정되거나 삭제되지 않으며, 유일하다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;즉, 이미 한번이라도 commit된 것은 .git 디렉토리를 직접적으로, 그리고 잘못된 방향으로 조작한게 아니고서야 절대 날아가지 않는다.&lt;/p&gt;

&lt;p&gt;단지, 우리의 눈에 보이지만 않고 있을 뿐이다.&lt;/p&gt;

&lt;p&gt;한마디로 commit의 해시코드만 알고있다면 언제라도 작업을 복구할 수 있음을 의미한다. 하지만, commit의 해시코드는 40자리의 랜덤한 문자열이므로 사람이 기억하는것이 불가능에 가깝다.&lt;/p&gt;

&lt;p&gt;따라서 작업을 추적하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git reflog&lt;/code&gt;를 통해 commit log를 보여주기도 하지만, 더 간편한 방법이 있다. 바로, commit에 사람이 기억하기 쉬운 이름을 박아버리는 것이다.&lt;/p&gt;

&lt;p&gt;이는 DNS와 완벽에 가까우리만큼 같은 개념인데, IP주소(ex 192.168.0.1 etc)를 사람이 기억하기 힘들기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.naver.com&lt;/code&gt;과 같은 도메인 네임을 IP에 매핑하는것이다. tag와 같지 않은가?&lt;/p&gt;

&lt;p&gt;tag는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git tag [tagname]&lt;/code&gt; 명령어를 통해 생성할 수 있다. 이 명령어를 입력하면 현재 HEAD가 바라보고 있는 commit을 바라보는 tag를 생성해낸다.&lt;/p&gt;

&lt;p&gt;나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa28560&lt;/code&gt; commit에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git tag save-point&lt;/code&gt;명령어를 통해 tag를 생성했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184531697-48630e6e-9916-40fd-a457-fc9bc983268c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[project]/.git/refs/tags&lt;/code&gt;에 진입해보면 save-point라는 파일이 생성돼있고, 내용을 확인해보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa28560&lt;/code&gt; commit을 가리키고 있음을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184531809-e292342e-a8d6-4f40-afbe-643477700548.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이제 tag를 생성했으니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git reset --hard de70330&lt;/code&gt;를 입력하여 branch의 참조를 이전 commit으로 돌린 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git log&lt;/code&gt;를 입력하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa28560&lt;/code&gt;가 삭제된것처럼 보인다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184531947-2834c4e1-0c60-4093-82ac-1108fd5d815a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;하지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aa28560&lt;/code&gt; commit에 tag를 남겨두었으니, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git reset --hard save-point&lt;/code&gt;를 입력하게 된다면 삭제된것처럼 보이는 commit을 언제든지 다시 복구(사실은 그냥 다시 보이게 한것에 불과하다)할 수 있다.&lt;/p&gt;

&lt;p&gt;혹은 해시코드를 알고 있으니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git reset --hard aa28560&lt;/code&gt;를 입력해도 똑같은 결과가 나타난다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184532011-d22c702a-57c3-4dda-91d9-00cce80f72d8.png&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/184532013-5f66ffb4-2fad-4294-8615-dc8b3cdedbf4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Git은 리눅스를 개발한 리누스 토발즈가 개발한 것인데(그것도 단 몇일만에…), 이러한 구조를 보면서 운영체제 책에서 보았던 inode-dentry가 살짝 연상됐다. 아마 리누스 토발즈가 리눅스를 개발하며 활용했던 설계를 Git에 일부 차용한게 아닐까? 라는 생각이 들었다.&lt;/p&gt;
</description>
			<pubDate>Sun, 14 Aug 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/cs/software-design/2022-08-14-git-brach-tag/</link>
			<guid isPermaLink="true">/cs/software-design/2022-08-14-git-brach-tag/</guid>
			
			
			<category>cs</category>
			
			<category>software-design</category>
			
		</item>
		
		<item>
			<title>Git의 구조 - Objects</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#git의-구조---objects&quot; id=&quot;markdown-toc-git의-구조---objects&quot;&gt;Git의 구조 - Objects&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#blob-binary-large-object&quot; id=&quot;markdown-toc-blob-binary-large-object&quot;&gt;Blob (Binary Large Object)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tree&quot; id=&quot;markdown-toc-tree&quot;&gt;Tree&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#commit&quot; id=&quot;markdown-toc-commit&quot;&gt;Commit&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#정리&quot; id=&quot;markdown-toc-정리&quot;&gt;정리&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;git의-구조---objects&quot;&gt;Git의 구조 - Objects&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git&lt;/code&gt;을 이루고 있는 가장 기본적인 단위는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tree&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;blob&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;commit은 몇가지 재료를 합성해 만들어지고, 이 commit의 재료들이 바로 tree와 blob이다.&lt;/p&gt;

&lt;p&gt;위의 세 가지 오브젝트들은 사용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git&lt;/code&gt; 디렉토리를 직접적으로 조작(예: rm -rf .git)하지만 않는다면 절대 수정되거나 삭제되지 않으며, 유일하다.&lt;/p&gt;

&lt;p&gt;또한, commit을 포함한 모든 오브젝트들은 0-9a-z로 이뤄진 40자리의 해시코드(SHA1)를 식별자로 갖는다.&lt;/p&gt;

&lt;p&gt;그리고 40자리중 맨 앞의 2자리는 오브젝트가 저장된 디렉토리의 이름이 되고 뒤의 38자리는 오브젝트 파일의 이름이 된다.&lt;/p&gt;

&lt;p&gt;다음과 같은 디렉토리가 있다.&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
└── src
    └── a.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;blob-binary-large-object&quot;&gt;Blob (Binary Large Object)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;blob은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파일&lt;/code&gt;과 매핑된 오브젝트이다.&lt;/p&gt;

&lt;p&gt;위 . 디렉토리의 최하위에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.txt&lt;/code&gt;라는 이름의 텍스트 파일이 존재하는데 git은 이 파일의 이름과 내용등을 취합하여 blob 타입의 오브젝트로 만들어 저장한다.&lt;/p&gt;

&lt;h2 id=&quot;tree&quot;&gt;Tree&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;tree는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;디렉토리&lt;/code&gt;와 매핑된 오브젝트이다.&lt;/p&gt;

&lt;p&gt;위 . 디렉토리의 하위에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt;라는 이름의 디렉토리가 하나 존재한다.&lt;/p&gt;

&lt;p&gt;git은 이러한 디렉토리들을 tree 타입의 오브젝트로 만드는데, 이때 tree의 재료는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt; 디렉토리의 하위에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.txt&lt;/code&gt;의 blob 오브젝트를 포함한다.&lt;/p&gt;

&lt;h2 id=&quot;commit&quot;&gt;Commit&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;commit은 위 계층 구조에서 . 디렉토리의 tree 오브젝트와 커미터의 정보를 포함한 오브젝트이다.&lt;/p&gt;

&lt;p&gt;commit은 tree와 blob, 커미터 정보의 집합으로 이루어져 있다.&lt;/p&gt;

&lt;h1 id=&quot;정리&quot;&gt;정리&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181572179-4536ada5-8afd-49a9-b4bd-e28249408483.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git log&lt;/code&gt;를 입력해 출력된 commit 히스토리는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181574214-e2040768-4126-4f65-a3a4-31a8e1b68887.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조금 더 보기전에 먼저 방금 생성한 commit을 눈으로 직접 확인해보기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git/objects&lt;/code&gt;로 들어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tree&lt;/code&gt; 명령어를 입력하면 다음과 같이 출력된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181575168-cc6ef9bd-8fa1-4b88-b58d-1cbca65f5dab.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위에서 모든 오브젝트는 40자리의 SHA1 해시코드로 생성되며, 가장 앞 2자리는 디렉토리명, 나머지 38자리는 파일명이 된다고 하였다.&lt;/p&gt;

&lt;p&gt;실제로 그러하다.&lt;/p&gt;

&lt;p&gt;방금 생성한 commit은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;baf09e6&lt;/code&gt;으로 시작하는 해시코드를 가지며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.git/objects/ba/f09e6...&lt;/code&gt; 이 존재함을 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;file&lt;/code&gt; 명령어를 통해 commit의 파일 정보를 출력하면 다음과 같이 출력된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181576387-4bd4da2d-cb0f-4a13-9a4f-9fff6ed1e81e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;zlib 방식으로 압축된 파일임을 알 수 있는데, 이를 해석할 수 있는 저수준 명령어를 git이 지원한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git cat-file -p baf09e6&lt;/code&gt; 를 입력하면 다음과 같은 데이터가 출력된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181576868-61e59dd4-e1f7-4503-99d0-a33572f7efcd.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;baf09e6 commit에 2092b97로 시작하는 tree 타입의 오브젝트가 포함되어 있음을 알 수 있다.&lt;/p&gt;

&lt;p&gt;위의 설명을 대입시켜보면 위의 tree 오브젝트는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt; 디렉토리일것이다.&lt;/p&gt;

&lt;p&gt;이어서 쭉쭉 파고들어가보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181577332-78e3edfa-b7cc-473a-aca7-efac24497815.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;src&lt;/code&gt; 디렉토리는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.txt&lt;/code&gt; 파일을 포함하고 있으므로, 해당 파일에 매핑된 blob 타입의 오브젝트가 존재함을 알 수 있다.&lt;/p&gt;

&lt;p&gt;이어서 blob 타입의 오브젝트도 풀어보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a.txt&lt;/code&gt; 파일의 데이터가 출력되게 된다.&lt;/p&gt;

&lt;p&gt;결과를 비교해보면…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181576868-61e59dd4-e1f7-4503-99d0-a33572f7efcd.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181577332-78e3edfa-b7cc-473a-aca7-efac24497815.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;1개의 commit&lt;/u&gt; - create src/a.txt(ba4f09e)&lt;/p&gt;

&lt;p&gt;&lt;u&gt;2개의 tree&lt;/u&gt; - . 디렉토리(2092b97), src 디렉토리(924b0f9)&lt;/p&gt;

&lt;p&gt;&lt;u&gt;1개의 blob&lt;/u&gt; - a.txt(b5e4569)&lt;/p&gt;

&lt;p&gt;총 4개의 git 오브젝트가 생성되었음을 알 수 있으며…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/181575168-cc6ef9bd-8fa1-4b88-b58d-1cbca65f5dab.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;.git/objects에도 마찬가지로 4개의 오브젝트가 실제로 존재함을 확인 할 수 있다.&lt;/p&gt;
</description>
			<pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/cs/software-design/2022-07-21-git-objects/</link>
			<guid isPermaLink="true">/cs/software-design/2022-07-21-git-objects/</guid>
			
			
			<category>cs</category>
			
			<category>software-design</category>
			
		</item>
		
		<item>
			<title>Java에서의 AOT vs JIT 컴파일</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java에서-aot-vs-jit-컴파일&quot; id=&quot;markdown-toc-java에서-aot-vs-jit-컴파일&quot;&gt;Java에서 AOT vs JIT 컴파일&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#java에서의-컴파일&quot; id=&quot;markdown-toc-java에서의-컴파일&quot;&gt;Java에서의 컴파일&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#c1-컴파일러&quot; id=&quot;markdown-toc-c1-컴파일러&quot;&gt;C1 컴파일러&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#c2-컴파일러&quot; id=&quot;markdown-toc-c2-컴파일러&quot;&gt;C2 컴파일러&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#just-in-time-compilation-jit&quot; id=&quot;markdown-toc-just-in-time-compilation-jit&quot;&gt;Just in Time Compilation (JIT)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#ahead-of-time-compilation-aot&quot; id=&quot;markdown-toc-ahead-of-time-compilation-aot&quot;&gt;Ahead of Time Compilation (AOT)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jit-vs-aot&quot; id=&quot;markdown-toc-jit-vs-aot&quot;&gt;JIT vs AOT&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#aot-제약-사항-closed-world-assumption-cwa&quot; id=&quot;markdown-toc-aot-제약-사항-closed-world-assumption-cwa&quot;&gt;AOT 제약 사항: Closed-World Assumption (CWA)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#graalvm과-aot-컴파일은-java의-미래인가요&quot; id=&quot;markdown-toc-graalvm과-aot-컴파일은-java의-미래인가요&quot;&gt;GraalVM과 AOT 컴파일은 Java의 미래인가요?&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#결론&quot; id=&quot;markdown-toc-결론&quot;&gt;결론&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#참고&quot; id=&quot;markdown-toc-참고&quot;&gt;참고&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#따로-참고한-것&quot; id=&quot;markdown-toc-따로-참고한-것&quot;&gt;따로 참고한 것&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 글은 &lt;a href=&quot;https://github.com/cesarsotovalero&quot; target=&quot;_blank&quot;&gt;cesarsotovalero&lt;/a&gt;의  &lt;a href=&quot;https://www.cesarsotovalero.net/blog/aot-vs-jit-compilation-in-java.html&quot; target=&quot;_blank&quot;&gt;📜 AOT vs. JIT Compilation in Java&lt;/a&gt;를 번역한 글입니다.&lt;/p&gt;

&lt;p&gt;제 CS지식이 빈약하고, 영어 실력이 좋지 않아 번역 품질이 많이 떨어지니, 가급적 원 글을 읽어주세요.&lt;/p&gt;

&lt;h1 id=&quot;java에서-aot-vs-jit-컴파일&quot;&gt;Java에서 AOT vs JIT 컴파일&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;JIT(Just in Time Compilation) 또는 AOT(Ahead of Time Compilation)를 사용하여 Java 애플리케이션을 컴파일하는 두 가지 방법이 있습니다. JIT는 Java HotspotVM의 기본설정이며 이는 런타임에 Java 바이트 코드를 기계어로 변환하는 데 사용됩니다. AOT는 GraalVM에서 지원되며 빌드타임에 Java 바이트 코드를 기계어로 정적 컴파일링 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이 글에서는 두 가지 컴파일 방식의 차이점에 대해 설명할 것이며, 이 글을 읽고 나면 Java 컴파일러가 하는 일, 기존 컴파일 방식 간의 차이점, AOT 컴파일러를 사용하는 것이 더 적합한 상황에 대해 배울 수 있을것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/179343441-512e883c-3e59-493f-a26d-4d73b559ee49.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;© JIT vs AOT: 동전의 양면. 사진 출처: &lt;a href=&quot;https://www.google.se/maps/place/Tekniska+h%C3%B6gskolan/@59.3451978,18.0704429,16.59z/data=!4m5!3m4!1s0x465f9d41dbc866ef:0x3141fc2243b8b232!8m2!3d59.345909!4d18.
0716004?hl=sv&amp;amp;shorturl=1&quot; target=&quot;_blank&quot;&gt;Tekniska Högskolan station.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;java에서의-컴파일&quot;&gt;Java에서의 컴파일&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;프로그램을 컴파일한다는 것은, Java나 Python과 같은 고수준 프로그래밍 언어의 소스 코드를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Machine_code&quot; target=&quot;_blank&quot;&gt;📜 기계어&lt;/a&gt;로 변환하는 것을 의미합니다. 기계어란 특정 프로세서(즉, CPU. 이 글에서는 하드웨어 혹은 하드웨어 아키텍처라는 용어로도 많이 쓰였음)에서 실행할 수 있도록 만들어진 저수준의 명령어입니다. 그리고 컴파일러는 컴파일을 효율적으로 수행하도록 설계된 프로그램입니다. 컴파일러의 목표는 컴파일된 프로그램의 일관된 실행 파일을 만드는 것이며, 일관된 실행 파일은 소스 코드로 작성된 사양에 맞게 빠르고 안전하게 실행됩니다.&lt;/p&gt;

&lt;p&gt;컴파일러는 기계어 생성 과정에서 여러 최적화를 수행합니다. 예를 들어, 대부분의 컴파일러는 컴파일 타임에 constant inlining, loop unrolling, partial evaluation 등을 수행합니다. 이러한 컴파일러의 최적화 작업과 복잡성은 지난 수십 년 동안 크게 증가했습니다.&lt;/p&gt;

&lt;p&gt;표준 Java HotspotVM의 컴파일러 최적화 측면에서 두 가지 주요 컴파일러가 있는데, 이들이 바로 C1 컴파일러와 C2 컴파일러입니다.&lt;/p&gt;

&lt;h3 id=&quot;c1-컴파일러&quot;&gt;C1 컴파일러&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;C1 컴파일러&lt;/strong&gt;는 some value numbering, inlining, class analysis를 수행하는 빠르고 가볍게 최적화된 바이트 코드 컴파일러입니다.&lt;/p&gt;

&lt;p&gt;C1 컴파일러는 간단한 CFG 지향적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single-assignment_form&quot; target=&quot;_blank&quot;&gt;📜 SSA&lt;/a&gt;와 고수준의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Intermediate_representation&quot; target=&quot;_blank&quot;&gt;📜 중간 표현(IR)&lt;/a&gt;, 기계 지향적인 저수준의 IR, 선형 스캔 레지스터 할당 및 템플릿 스타일 코드 생성기를 사용합니다.&lt;/p&gt;

&lt;h3 id=&quot;c2-컴파일러&quot;&gt;C2 컴파일러&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;C2 컴파일러&lt;/strong&gt;는 &lt;a href=&quot;https://darksi.de/d.sea-of-nodes/&quot; target=&quot;_blank&quot;&gt;📜 노드의 바다&lt;/a&gt; SSA와 이상적인 IR을 사용하는 고도로 최적화된 바이트 코드 컴파일러이며, IR은 동일한 종류의 기계별 IR로 낮아집니다. C2 컴파일러에는 그래프 색칠 레지스터 할당자도 있습니다. 색상은 로컬, 글로벌, 인수 레지스터와 스택을 포함한 기계의 상태입니다. 또한, C2 컴파일러의 최적화에는 global value numbering, conditional constant type propagation, constant folding, global code motion, algebraic identities, method inlining (aggressive, optimistic, and/or multi-morphic), intrinsic replacement, loop transformations (unswitching, unrolling), array range check elimination 및 기타 등등이 포함됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 컴파일러의 역할을 어느정도 이해했으므로 컴파일이 수행되는 시점에 대해 이야기 해보겠습니다. Java에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JIT(Just in Time)&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AOT(Ahead of Time)&lt;/code&gt;라는 두 가지 주요한 컴파일 전략이 있습니다. JIT는 프로그램 자체를 실행하는 동안(즉, Java 메서드가 처음으로 호출되기 전) 기계어를 생성하며, AOT는 프로그램이 실행되기 전에 기계어를 생성해냅니다(즉, 애플리케이션의 바이트 코드 검증 및 빌드 단계에서). 다음 섹션에서는 이러한 두 접근 방식의 차이점에 대해 설명합니다.&lt;/p&gt;

&lt;h3 id=&quot;just-in-time-compilation-jit&quot;&gt;Just in Time Compilation (JIT)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;Java 프로그램을 컴파일할 때(예: javac 명령줄 도구를 사용하여) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;플랫폼(CPU 아키텍처 + OS, 예로 인텔맥은 인텔 CPU + MacOS를 사용하는 플랫폼)&lt;/code&gt;에 독립적인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중간 표현(IR, JVM 바이트 코드가 IR의 일종)&lt;/code&gt;으로 변환되며, 이 JVM 바이트 코드는 JVM이 읽기에는 아주 쉽지만 반대로 사람이 읽기는 어렵습니다.
우리 컴퓨터의 기존 프로세서는 JVM 바이트 코드를 직접 실행할 수 없으며, 그렇게 하기 위해 컴파일러는 다시 JVM 바이트 코드를 플랫폼에 종속적인 기계어로 변환해야만 하며, 이것은 프로그램이 본래 컴파일되었던 플랫폼과 동일한 플랫폼에서만 실행할 수 있음을 의미합니다. (즉, 인텔맥에서 컴파일 된 코드는 인텔맥에서만 실행할 수 있음을 의미함)&lt;/p&gt;

&lt;p&gt;그리고 이것들은 정확히 바이트 코드 컴파일러가 하는 작업입니다. (여기서 바이트 코드 컴파일러란 바이트 코드를 기계어로 변환하는 JVM 내부의 인터프리터를 의미함. 즉, Java는 기본적으로 정적 컴파일 방식과 동적 컴파일 방식을 함께 사용함.)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/179341951-49f9f9cc-c7c2-40f0-a17f-91b63444fd2a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;그림 1. Java 소스 코드는 먼저 바이트 코드로 컴파일된 후 나중에 기계어로 해석되고 실행되며, 다소 무거운 최적화 작업들은 JIT 컴파일 단계에 예정되어 있습니다. &lt;a href=&quot;https://dl.acm.org/doi/10.1145/3067695.3082521&quot; target=&quot;_blank&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;JVM은 런타임에 현재 어떤 플랫폼에서 프로세스가 실행되고 있는지를 파악하고 바이트 코드를 해석한 후 현재 플랫폼에 최적화된 기계어를 만들어 냅니다. 이 전략은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_compilation&quot; target=&quot;_blank&quot;&gt;📜 동적 컴파일&lt;/a&gt;의 한 형태인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot; target=&quot;_blank&quot;&gt;📜 JIT 컴파일&lt;/a&gt;로 알려져 있으며, JVM의 기본 JIT 컴파일러는 일명 Hotspot으로 알려져 있습니다. 그리고, &lt;a href=&quot;https://github.com/openjdk/jdk&quot; target=&quot;_blank&quot;&gt;📦 OpenJDK&lt;/a&gt;는 Java로 작성된 이 JVM 바이트 코드 컴파일러의 무료 버전입니다. &lt;u&gt;(즉, OpenJDK는 무료 버전의 HotspotVM이며, HotspotVM은 JIT 컴파일 방식을 사용한다는 의미)&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://chrisseaton.com/truffleruby/jokerconf17/&quot; target=&quot;_blank&quot;&gt;📜 Understanding How Graal Works - a Java JIT Compiler Written in Java&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;HotspotVM의 JIT 컴파일러는 C++로 작성되어 있는데 현 시점 이 코드는 포인터를 직접 다루고 있고, 코드가 오래됐기 때문에 유지보수성, 확장성, 안정성이 매우 떨어집니다. 우리는 이러한 문제를 해결하기 위해 JIT 컴파일러를 Java로 작성하기로 했습니다. C나 C++같은 시스템 언어를 사용하지 않고 JIT 컴파일러를 어떻게 작성할 수 있는지 궁금할 수도 있는데, 따지고 보면 JIT 컴파일러는 오직 JVM 바이트 코드를 입력받아 기계어로 변환 할 수만 있으면 됩니다. 또한, 당신은 JIT 컴파일러에 바이트 배열(byte[])을 입력하면 다시 바이트 배열이 출력되길 원할 수도 있습니다. 이러한 모든 작업들을 Java로 처리하기 위해 많은 복잡한 작업을 해야 하겠지만, 어쨋든 순수하게 Java로 JIT 컴파일러를 작성할 수는 있습니다. 그리고 순수한 Java로 이뤄진 JIT 컴파일러를 작성한다면 이 컴파일러는 더 이상 시스템과 관련이 없으므로 C나 C++과 같은 시스템 언어에 의존하지 않을 수 있게 됩니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;JIT 컴파일러의 목적은 최적화가 아주 잘 된 고품질의 기계어를 최대한 빠르게 생성해내는 것이며, 런타임에 추가적으로 얻을 수 있는 정보들 덕분에 JIT 컴파일러는 javac 컴파일러보다 훨씬 더 정교한 최적화를 수행 할 수 있게 됩니다. 그리고 이러한 최적화는 애플리케이션의 성능을 더더욱 향상시킵니다.&lt;/p&gt;

&lt;p&gt;JIT 컴파일러는 Java 메서드를 미리 수천 번 실행하여 JVM 바이트 코드 컴파일러가 Java 메서드를 “워밍업”할 수 있도록 합니다. 이 워밍업을 통해 컴파일러는 전체 클래스 계층 구조를 미리 관찰할 수 있기 때문에 최적화와 관련된 더 나은 결정을 내릴 수 있게 됩니다. 이 때, JIT 컴파일러는 JVM 바이트 코드 컴파일러가 수집한 분기 및 유형 프로필 정보도 검사할 수 있습니다.&lt;/p&gt;

&lt;p&gt;하지만, 이러한 JIT 컴파일러의 발전에도 불구하고 Java 애플리케이션은 기계어를 직접(IR을 거치지 않고) 만들어내는 C 또는 Rust와 같은 언어보다 여전히 훨씬 느립니다. 이러한 바이트 코드 해석 프로세스는 IR을 거치지 않고 기계어를 직접 만들어내는 프로세스보다 애플리케이션을 상당히 느리게 만들 수 밖에 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;ahead-of-time-compilation-aot&quot;&gt;Ahead of Time Compilation (AOT)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Ahead-of-time_compilation&quot; target=&quot;_blank&quot;&gt;📜 AOT 컴파일&lt;/a&gt;은 프로그램이 실행되기 전에 소스 코드를 기계어로 변환하는 방식으로 정적 
컴파일의 한 형태입니다. 이것은 C와 같은 오래된 프로그래밍 언어의 코드가 정적으로 링크되고 컴파일되는 “구형” 방식입니다. 컴파일의 결과로 얻어진 기계어는 특정 플랫폼에 맞게 
조정되며(단, 플랫폼에 종속됨) 매우 빠른 실행이 가능해집니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/oracle/graal&quot; target=&quot;_blank&quot;&gt;📦 GraalVM&lt;/a&gt;은 JVM 바이트 코드에 고도로 최적화된 AOT 컴파일을 수행할 수 있습니다. GraalVM은 Java로 작성되었으며 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JVMCI&lt;/code&gt;을 사용하여 HotspotVM과 통합됩니다. GraalVM 프로젝트의 초점은 최신 Java 애플리케이션에 더욱 좋은 성능과 더 나은 확장성을 제공하는 것입니다. 즉, 더 적은 오버헤드로 더 빠르게 실행되며 이는 더 적은 CPU와 메모리 자원의 소비를 의미합니다. 따라서 GraalVM은 JVM과 함께 제공되는 기존 JIT 컴파일러보다 더 나은 대안이 될 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;JVMCI는 JVM에서 메타데이터를 읽고 JVM에 기계어를 삽입하는 것과 같은 기능을 위한 JVM에 대한 저수준 인터페이스입니다. Java로 작성된 컴파일러를 동적 컴파일러로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“GraalVM의 도구로 생성된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;네이티브 이미지&lt;/code&gt;에는 애플리케이션 클래스, 종속성 클래스, 런타임 라이브러리 클래스 및 JDK에 정적으로 연결된 기계어가 포함됩니다. JVM에서 실행되지 않지만 “Substrate VM”이라는 다른 런타임 시스템의 메모리 관리, 스레드 스케줄링 등과 같은 필수 구성 요소를 포함합니다. Substrate VM은 런타임 구성 요소(예: 디옵티마이저, 가비지 수집기 및 스레드 스케줄링)의 이름입니다. 결과 프로그램은 JVM에 비해 시작 시간이 더 빠르고 런타임 메모리 오버헤드가 더 적습니다.”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;다음 그림은 &lt;a href=&quot;https://www.graalvm.org/22.0/reference-manual/native-image/&quot; target=&quot;_blank&quot;&gt;📜 네이티브 이미지&lt;/a&gt; 기술을 사용하는 GraalVM 컴파일러의 AOT 컴파일 프로세스를 보여줍니다.&lt;/p&gt;

&lt;p&gt;GraalVM은 애플리케이션, 라이브러리, JDK 및 JVM의 모든 클래스를 입력으로 받습니다. 그런 다음 고정된 지점에 도달할 때까지 &lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/3377555.3377885&quot; target=&quot;_blank&quot;&gt;📜 최첨단 포인트 분석을 사용하여 반복적인 바이트 코드 검색이 수행됩니다&lt;/a&gt;. 이 프로세스 동안 모든 안전한 클래스는 정적으로 미리 &lt;a href=&quot;https://docs.oracle.com/en/graalvm/enterprise/21/docs/reference-manual/native-image/ClassInitialization/&quot; target=&quot;_blank&quot;&gt;📜 초기화&lt;/a&gt;됩니다(즉, 인스턴스화됨). 초기화된 클래스의 클래스 데이터는 이미지 힙에 로드된 다음 독립 실행 파일(그림 2의 텍스트 섹션)에 저장됩니다. 그 결과 컨테이너에 직접 배송하거나 배포할 수 있는 실행 가능한 네이티브 이미지가 생성됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/179342041-b3e5af12-a78f-4cb5-84c1-b2e850e2579b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;그림 2. GraalVM의 기본 이미지 생성 프로세스 &lt;a href=&quot;https://dl.acm.org/doi/10.1145/3360610&quot; target=&quot;_blank&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;GraalVM의 AOT 컴파일은 JDK 및 해당 종속성에서 사용되지 않는 코드 제거, 힙 스냅샷 및 정적 코드 초기화와 같은 최적화를 적극적으로 수행하고, 독립 실행 파일을 생성합니다. 주요 이점은 실행 파일이 올바르게 실행되기 위해 클라이언트 시스템에 JVM을 설치할 필요가 없다는 것이며, 이것은 JVM 바이트 코드로 컴파일되는 프로그래밍 언어를 고성능 프로그램에 사용되는 C, C++, Rust 또는 Go와 같은 언어만큼 빠르게 만듭니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;Go의 경우 처음부터 언어차원에서 AOT가 구현되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;jit-vs-aot&quot;&gt;JIT vs AOT&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;이제 바이트 코드 컴파일이 작동하는 방식과 두 가지 주요 전략(JIT 및 AOT)을 이해했으므로 어떤 접근 방식을 사용하는 것이 가장 좋은지 궁금할 것입니다. 불행히도 대답은 예상대로 &lt;u&gt;&quot;그때 그때 다릅니다.&quot;&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;이 섹션에서는 각 방식의 장단점을 다룰 것입니다.&lt;/p&gt;

&lt;p&gt;JIT 컴파일러는 프로그램을 크로스 플랫폼으로 만들어줍니다(즉, 플랫폼에 독립적이라는 의미). 실제로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Write_once,_run_anywhere&quot; target=&quot;_blank&quot;&gt;📜 “한번만 작성하면 어디에서나 실행 할 수 있다”&lt;/a&gt; 라는 슬로건은 90년대 후반에 Java를 대중적인 언어로 만든 기능 중 하나였습니다. JIT 컴파일러는 
동시 가비지 컬렉터를 사용하여 최대 처리량 조건에서 메모리 회복력을 높여 STW(Stop the World)를 짧게 가져갑니다.&lt;/p&gt;

&lt;p&gt;반면에 AOT 컴파일러는 프로그램을 보다 효율적으로 실행하며, 이는 특히 클라우드 애플리케이션에 적합합니다. 네이티브 이미지는 더 빠른 시작 속도를 제공하므로 애플리케이션의 부팅 시간이 단축되고, 이는 클라우드 서비스의 Scale-out이 더욱 간편해지게 만듭니다. 또한, 클라우드에서 실행되는 Docker 컨테이너로 초기화된 마이크로서비스의 경우에 특히 유용합니다. 사용되지 않는 코드의 완전한 제거(클래스, 필드, 메서드, 분기) 덕분에 파일의 크기가 작아지기 때문에 결과적으로 컨테이너의 이미지도 작아집니다. 또한, 메모리 소비가 적기 때문에 동일한 메모리로 더 많은 컨테이너를 실행할 수 있으므로 클라우드 서비스의(AWS, GCP와 같은) 비용도 절감됩니다.&lt;/p&gt;

&lt;p&gt;다음 스파이더 그래프는 주요 차이점을 보여줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/179342067-8a333618-ca43-485e-8304-e7bb6653b53f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;그림 3. AOT vs JIT. &lt;a href=&quot;https://twitter.com/thomaswue/status/1145603781108928513?s=20&amp;amp;t=-6ufSBjc46mfN5d_6Y2-Rg&quot; target=&quot;_blank&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;요약하면 GraalVM을 사용한 AOT 컴파일은 표준 JIT 컴파일에 비해 다음과 같은 이점을 제공합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JVM에 필요한 자원의 일부를 사용합니다.&lt;/li&gt;
  &lt;li&gt;애플리케이션이 밀리초 단위로 부팅됩니다.&lt;/li&gt;
  &lt;li&gt;워밍업 없이 최고의 성능을 즉시 제공합니다.&lt;/li&gt;
  &lt;li&gt;더 빠르고 효율적인 배포를 위해 경량 컨테이너 이미지로 패키징할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;공격 표면이 감소됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;aot-제약-사항-closed-world-assumption-cwa&quot;&gt;AOT 제약 사항: Closed-World Assumption (CWA)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;AOT 컴파일의 포인트 분석이 올바르게 작동하려면 모든 바이트 코드를 보아야 할 필요가 있습니다. 이러한 제약은 CWA 한정으로 알려져 있습니다. 즉, GraalVM의 네이티브 이미지 도구가 독립 실행 파일을 빌드할 때 런타임에 호출할 수 있는 응용 프로그램의 모든 바이트 코드와 종속성을 알아야 함을 의미합니다.&lt;/p&gt;

&lt;p&gt;따라서 JNI(Java Native Interface), Java Reflection, 동적 프록시 개체(java.lang.reflect.Proxy) 또는 클래스 경로 리소스(Class.getResource)와 같은 동적 언어 기능이 지원되지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://openjdk.org/projects/leyden/notes/01-beginnings&quot; target=&quot;_blank&quot;&gt;📜 Project Leyden: Beginnings - Oracle&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이러한 한계를 극복하기 위해 GraalVM은 일반 JVM에서 실행되는 모든 동적 언어 기능을 추적하는 &lt;a href=&quot;https://www.graalvm.org/22.0/reference-manual/native-image/Agent/&quot; target=&quot;_blank&quot;&gt;📜 에이전트&lt;/a&gt;를 제공합니다. 실행하는 동안 에이전트는 JVM과 상호작용하며 클래스, 메서드, 필드, 리소스를 조회하거나 프록시 액세스를 요청하는 모든 호출을 가로챕니다. 그런 다음 에이전트 는 지정된 출력 디렉토리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jni-config.json&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reflect-config.json&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;proxy-config.json&lt;/code&gt; 및 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;resource-config&lt;/code&gt; 파일을 생성합니다. 이렇게 생성된 파일들은 가로채는 모든 동적 액세스를 포함하는 JSON 형식의 독립 실행형 구성 파일입니다. 이와 같은 명세 파일들은 네이티브 이미지 도구로 전달되며 네이티브 이미지 빌드 과정에서 사용된 클래스가 제거되지 않습니다.&lt;/p&gt;

&lt;p&gt;CWA가 다양한 코드 주입 가능성을 제거하므로 보안에 좋다는 점은 언급할만한 가치가 있습니다(예로 2021년 웹 생태계에 큰 충격을 준 Log4j 취약점은 Java의 동적 클래스 로딩 메커니즘의 악용으로 인해 가능했습니다). 반면에 포인트 분석은 도달 가능한 모든 바이트 코드를 분석해야 하기 때문에 AOT 컴파일을 JIT보다 느리게 만듭니다. 즉, 이는 값비싼 계산 방식입니다.&lt;/p&gt;

&lt;h2 id=&quot;graalvm과-aot-컴파일은-java의-미래인가요&quot;&gt;GraalVM과 AOT 컴파일은 Java의 미래인가요?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;네이티브 클라우드 애플리케이션을 위한 AOT 컴파일의 이점으로 인해 이 기술에 대한 관심이 높아졌고(대표적으로 클라우드 + MSA의 성공적인 사례), 이제 Java 생태계는 이 기술을 적극적으로 채택하고 있습니다. 이 글을 작성하는 시점에서 4가지의 주요 프레임워크는 GraalVM의 이점을 활용하여 애플리케이션을 빌드하고 최적화합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://quarkus.io/&quot; target=&quot;_blank&quot;&gt;Quarkus (by RedHat)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://micronaut.io/&quot; target=&quot;_blank&quot;&gt;Micronaut (by The Micronaut Foundation)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://helidon.io/&quot; target=&quot;_blank&quot;&gt;Helidon (by Oracle)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/&quot; target=&quot;_blank&quot;&gt;Spring Native (by Spring)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;JVM 기반 네이티브 애플리케이션을 구축하는 일반적인 프로세스는 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/179342137-dd8f55e9-86cf-435b-8bd0-ee474d3d8d82.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;GraalVM을 사용한 AOT는 Java, Scala, Kotlin과 같은 JVM 기반 언어의 미래인 것 같습니다. 그러나 네이티브 이미지 생성은 애플리케이션의 바이트 코드와 모든 종속성을 분석해야 하기 때문에 종속성 중 하나 이상이 일부 동적인 기능에 의존하고 있는 경우 CWA를 위반할 위험이 있습니다. 커뮤니티는 이러한 위험성을 고려한 새 버전의 라이브러리를 만들고 있지만, 가장 널리 사용되는 Java 라이브러리에 대한 지원은 아직도 충분하지 않습니다.&lt;/p&gt;

&lt;p&gt;따라서 이 기술이 대규모로 채택되기까지는 아직 시간이 더 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p class=&quot;note&quot;&gt;기술 채택 지연은 기술 생태계에서 일반적인 현상입니다. Docker 컨테이너와 같은 핵심 기술은 2013년부터 사용 가능했지만 5년 후인 2018년에 이르러서야 대규모로 채택되기 시작했습니다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;AOT 또는 JIT 접근 방식을 사용하여 JVM 바이트 코드를 기계어로 컴파일하는 것이 가능합니다.&lt;/p&gt;

&lt;p&gt;각 방식이 서로 다른 상황에 적합하기 때문에 둘 중 하나가 다른 방식보다 좋다고 말하는 것은 잘못된 것입니다.&lt;/p&gt;

&lt;p&gt;GraalVM을 사용하면 AOT 컴파일로 고성능 애플리케이션을 구축할 수 있으므로 시작 시간이 단축되고 성능이 크게 향상됩니다. 이러한 이점은 CWA를 준수하는 대신 얻어집니다.&lt;/p&gt;

&lt;p&gt;반대로 개발자는 여전히 Hotspot VM에서 표준 JIT 컴파일러를 사용하여 런타임에 기계어 생성을 지원하는 동적 언어 기능을 사용할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;참고&quot;&gt;참고&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.google.com/presentation/d/1JDVerE77ZWLqwtWP430QXF1KTd4RhKoD/edit?usp=sharing&amp;amp;ouid=117859204590242341300&amp;amp;rtpof=true&amp;amp;sd=true&quot; target=&quot;_blank&quot;&gt;📜 Java is Going to the Moon: Native Images with GraalVM&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.usenix.org/legacy/publications/library/proceedings/jvm02/yu/yu_html/index.html&quot; target=&quot;_blank&quot;&gt;📜 Supporting Binary Compatibility with Static Compilation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dl.acm.org/doi/10.1145/3360610&quot; target=&quot;_blank&quot;&gt;📜 Initialize Once, Start Fast: Application Initialization at Build Time&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/graal-java-jit-compiler&quot; target=&quot;_blank&quot;&gt;📜 Deep Dive Into the New Java JIT Compiler – Graal&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://openjdk.java.net/jeps/295&quot; target=&quot;_blank&quot;&gt;📜 JEP 295: Ahead-of-Time Compilation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/ahead-of-time-compilation&quot; target=&quot;_blank&quot;&gt;📜 Ahead of Time Compilation (AoT)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;따로-참고한-것&quot;&gt;따로 참고한 것&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://chrisseaton.com/truffleruby/jokerconf17/&quot; target=&quot;_blank&quot;&gt;📜 Understanding How Graal Works - a Java JIT Compiler Written in Java&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://rito15.github.io/posts/cs-dotnet-compile/&quot; target=&quot;_blank&quot;&gt;📜 .NET 환경의 컴파일 과정 - CLR, CIL, JIT, AOT&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dl.acm.org/doi/abs/10.1145/3377555.3377885&quot; target=&quot;_blank&quot;&gt;📜 Scalable pointer analysis of data structures using semantic models&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A4%91%EA%B0%84_%ED%91%9C%ED%98%84&quot; target=&quot;_blank&quot;&gt;📜 Intermediate Representation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Static_single-assignment_form&quot; target=&quot;_blank&quot;&gt;📜 Static Single Assignment Form&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html&quot; target=&quot;_blank&quot;&gt;📜 HotSpot Glossary of Terms&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://darksi.de/d.sea-of-nodes/&quot; target=&quot;_blank&quot;&gt;📜 Sea of Nodes&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Closed-world_assumption&quot; target=&quot;_blank&quot;&gt;📜 https://en.wikipedia.org/wiki/Closed-world_assumption&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://redcarrot.tistory.com/52&quot; target=&quot;_blank&quot;&gt;📜 Closed World Assumption (CWA; 닫힌 세계 가정)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Sat, 16 Jul 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/backend/java/2022-07-16-aot-vs-jit-in-java/</link>
			<guid isPermaLink="true">/backend/java/2022-07-16-aot-vs-jit-in-java/</guid>
			
			
			<category>backend</category>
			
			<category>java</category>
			
		</item>
		
		<item>
			<title>DNS는 무엇이고, 어떻게 동작할까?</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#dnsdomain-name-system&quot; id=&quot;markdown-toc-dnsdomain-name-system&quot;&gt;DNS(Domain Name System)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#용어&quot; id=&quot;markdown-toc-용어&quot;&gt;용어&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#흐름&quot; id=&quot;markdown-toc-흐름&quot;&gt;흐름&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#캐싱&quot; id=&quot;markdown-toc-캐싱&quot;&gt;캐싱&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;dnsdomain-name-system&quot;&gt;DNS(Domain Name System)&lt;/h1&gt;

&lt;hr /&gt;

&lt;p class=&quot;note&quot;&gt;DNS는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Domain Name Server&lt;/code&gt;가 아니고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Domain Name System&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;DNS는 사람이 쉽게 알아볼 수 있는 문자를 서버의 주소(IP)로 상호 변환해주는 시스템이다.&lt;/p&gt;

&lt;p&gt;이 DNS가 없던 옛날에는 구글에 접속하기 위해 google.com을 입력하는것이 아닌, 142.250.196.110같은 IP를 입력해야 했었다고 한다.&lt;/p&gt;

&lt;p&gt;참고로 DNS 통신의 well known port는 53이고, TCP/UDP 방식으로 동작한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/175770494-095651c1-c7e7-415b-9e71-bcd9d69b3148.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;&lt;a href=&quot;https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml?search=domain&quot; target=&quot;_blank&quot;&gt;📜 IANA - well known ports&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;용어&quot;&gt;용어&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Local DNS
    &lt;ul&gt;
      &lt;li&gt;기지국의 DNS 서버이다.&lt;/li&gt;
      &lt;li&gt;컴퓨터가 LAN을 통해 인터넷에 연결되면, 인터넷을 사용할 수 있게 IP를 할당해주는 통신사(KT, SK, LG)들의 DNS 서버를 말한다.&lt;/li&gt;
      &lt;li&gt;이사가면 인터넷 연결을 위해 어디에 전화를 걸게되는지 생각해보자&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Root DNS
    &lt;ul&gt;
      &lt;li&gt;Local DNS의 상위 DNS 서버이며, 최상위 DNS 서버이다.&lt;/li&gt;
      &lt;li&gt;전 세계의 주요 도시에 존재하며, 트리 구조로 하위에 많은 DNS 서버들을 알고 있다.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://root-servers.org/&quot; target=&quot;_blank&quot;&gt;📜 root.server.org&lt;/a&gt; 를 참고해보자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;최상위 도메인(Top-Level Domain, TLD)
    &lt;ul&gt;
      &lt;li&gt;국가 코드 최상위 도메인(Country Code Top-Level Domain, ccTLD)&lt;/li&gt;
      &lt;li&gt;일반 최상위 도메인(Generic Top-Level Domain, gTLD)&lt;/li&gt;
      &lt;li&gt;외 나머지는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EC%B5%9C%EC%83%81%EC%9C%84_%EB%8F%84%EB%A9%94%EC%9D%B8_%EB%AA%A9%EB%A1%9D&quot; target=&quot;_blank&quot;&gt;📜 인터넷 최상위 도메인 목록&lt;/a&gt;을 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;흐름&quot;&gt;흐름&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/175438394-c70b00ef-e9fb-418a-a85e-5714a9a93ff0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 이미지는 AWS에서 제공하는 DNS에 대한 개요이다.&lt;/p&gt;

&lt;p&gt;이미지를 요약하자면 다음과 같다. (접속은 google.com에 접속한다고 가정한다)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;클라이언트가 브라우저의 주소창에 google.com을 입력한다&lt;/li&gt;
  &lt;li&gt;클라이언트 컴퓨터의 hosts 파일에서 google.com의 IP 주소 정보가 있는지 확인한다
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;윈도우&lt;/code&gt;: &lt;u&gt;C:\Windows\System32\drivers\etc\hosts&lt;/u&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리눅스&lt;/code&gt;: &lt;u&gt;/etc/hosts&lt;/u&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;hosts 파일에 IP 주소 정보가 없다면 PC의 DNS 캐시를 확인한다
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;윈도우&lt;/code&gt;: &lt;u&gt;cmd -&amp;gt; ipconfig/displaydns 입력시 확인 가능&lt;/u&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리눅스&lt;/code&gt;: &lt;a href=&quot;https://netbeez.net/blog/how-dns-cache-works/&quot; target=&quot;_blank&quot;&gt;📜 How to inspect the DNS cache on Windows, Mac OS X, and Linux&lt;/a&gt; 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DNS 캐시에도 IP 주소 정보가 없다면 Local DNS에 google.com의 IP 주소에 대해 질의(Query)한다.&lt;/li&gt;
  &lt;li&gt;Local DNS는 자신의 DNS 캐시에서 IP 주소 정보를 찾고, 없다면 Root DNS에 질의한다.&lt;/li&gt;
  &lt;li&gt;Root DNS는 자신이 google.com의 IP 주소 정보를 갖고있지 않다면, TLD(Top-Level Domain) DNS 서버의 주소를 알려준다
    &lt;ul&gt;
      &lt;li&gt;여기서 google.com이니 TLD는 .com이 된다. 즉, gTLD&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Local DNS는 다시 com DNS에 google.com의 IP 주소 정보를 질의한다&lt;/li&gt;
  &lt;li&gt;com DNS에서 google.com의 IP 주소인 142.250.196.110을 응답해준다&lt;/li&gt;
  &lt;li&gt;Local DNS는 클라이언트에 142.250.196.110를 응답해주고, 이 IP 주소를 자신도 캐싱한다&lt;/li&gt;
  &lt;li&gt;클라이언트는 Local DNS에게 받은 14.250.196.110을 캐싱하고, 이후 위 주소로 다시 요청을 이어나간다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;URL을 뜯어보면 DNS 관점에서 다음과 같이 나눌 수 있는데, 다음과 같다. (HTTP 관점과는 약간 다름)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/175770125-ba20530e-b9e6-49f3-8004-46ae809f53a5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 흐름에서도 알 수 있듯이, Local DNS에서 Root DNS로 질의하면, Root DNS에서 모든걸 알아서 찾아주는 것이 아니고, Root DNS는 Local DNS에 TLD DNS의 정보를 알려주게 된다.&lt;/p&gt;

&lt;p&gt;그럼 Local DNS는 TLD DNS에게 다시 물어보며 DNS 트리구조를 타고 내려간다.&lt;/p&gt;

&lt;p&gt;모든 노드를 탐색할때까지 이 과정이 반복되기에 이것을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Recursive Query&lt;/code&gt;라고 부른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/175441665-45c52aae-2faa-44bc-b26e-39309ca59465.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;출처 - 구글 이미지 검색&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;캐싱&quot;&gt;캐싱&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;위 과정들을 보면 최초에 DNS 캐시를 먼저 조회하고, 마지막에도 찾은 정보를 DNS 캐시에 캐싱한다.&lt;/p&gt;

&lt;p&gt;이는 생각해보면 아주 당연한 일인데, google.com의 IP 주소를 찾기 위해 얼마나 복잡하고 많은 질의가 이루어졌는가?&lt;/p&gt;

&lt;p&gt;브라우저에 google.com을 입력 할 때마다 위의 과정을 모두 반복하면 이는 매우 비효율적이며, DNS 서버들은 전국, 전세계단위의 요청을 받기 때문에 DNS 서버들에 과부하가 갈 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;또한 도메인과 IP는 생각보다 그렇게 자주 변경되지 않기 때문에, 캐싱했을 때의 기대 효율이 높을 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/backend/server-side/2022-06-24-dns/</link>
			<guid isPermaLink="true">/backend/server-side/2022-06-24-dns/</guid>
			
			
			<category>backend</category>
			
			<category>server-side</category>
			
		</item>
		
		<item>
			<title>경력자로서 앞으로 뭐가 중요할까?</title>
			<description>
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;최근에 아주 좋은 글을 하나 읽었는데, 어떻게 해야 10배 이상 뛰어난 개발자가 되는지에 대한 글이었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@_michaellin/how-to-be-a-10x-engineer-fdac2a5a1bd5&quot; target=&quot;_blank&quot;&gt;📜 How to Be a 10x Software Engineer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;하나하나 내용이 주옥같지만, 내가 가장 영감을 받은 것은 1번 문단이었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;사용하는 도구에 대한 연구가 없다&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;에이브러햄 링컨은 “나에게 나무를 베는 데 8시간이 주어진다면 도끼를 가는 데 7시간을 쓸 것이다.”라고 말했다. 
주니어 개발자는 무딘 도끼로 8시간 나무를 벨 것이다.
반면, 시니어 개발자는 작업 시작 전 한 시간 동안 최고의 전기톱을 고를 것이다. 
그리고 그는 5분 만에 모든 나무를 자를 것이다.&lt;/p&gt;

  &lt;p&gt;예시: 웹사이트 개발&lt;/p&gt;

  &lt;p&gt;나는 최근에 후배 주니어 엔지니어와 누가 개인 웹사이트를 더 빨리 구축할 수 있는지에 대한 내기를 했다.
후배는 2주 동안 1000줄 이상의 코드를 작성했지만, 그는 2주가 지나도 작업을 마치지 못했다.
반면, 단 한줄의 코딩조차 하지 않고 하루만에 나만의 웹사이트를 만들어 냈다.
&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/172092795-ffc0c222-55df-4456-848f-672675892c0a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;내가 보기에 위 일화에서 후배의 문제는, 알고 있는 정보가 너무 적었다는 것이다.&lt;/p&gt;

&lt;p&gt;이를 그림으로 그려보면 대략 아래와 같이 될 수 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/172094124-27ae2cb7-b661-4d8c-95c0-ab23c168bdd0.png&quot; alt=&quot;image&quot; /&gt;
개발자, 지식의 피라미드&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예를 들어, 내가 전기톱을 아주 잘 다룬다고 가정하자.&lt;/p&gt;

&lt;p&gt;하지만 나무에 못을 박아야 하는 상황이 생겼고, 나는 망치라는 도구의 존재를 모른다면?&lt;/p&gt;

&lt;p&gt;당연히 전기톱으로 못을 박으려고 들 것이고, 이는 아주 바보같은 짓임에 틀림없다.&lt;/p&gt;

&lt;p&gt;하지만, 못을 박는데 최적화된 망치라는 도구의 존재를 내가 알고있지만, 당장 이 망치를 제대로 다루지는 못한다면?&lt;/p&gt;

&lt;p&gt;나는 전기톱으로 못을 박기보다는, 망치를 다루는 약간의 연습을 한 후에 망치로 못을 박을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 지식의 피라미드에서 가장 많은 부분을 차지하는 가장 하위 계층의 &lt;strong&gt;내가 모른다는 것조차 모르는 것&lt;/strong&gt; 부분이 우리가 해결하려는 문제에 대한 가장 완벽한 정답임에도 불구하고 그 존재조차 알지 못하는 많은 언어, 프레임워크, 기술이라고 볼 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;나는 자바를 아주 잘 안다고 자신할 수 없지만, 그럼에도 불구하고 내가 다루는 기술 중 자바를 가장 잘 다룰 수 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;내가 잘 다룰 수 있다고 생각하는 자바를 더욱 더 갈고닦는다면 지식의 피라미드에서 &lt;strong&gt;내가 안다고 생각하는 것&lt;/strong&gt;부분이 더욱 넓어질 것이며, 이는 곧 내 기술의 깊이다.&lt;/p&gt;

&lt;p&gt;반대로 내가 잘 다루지 못한다고 생각하는 도커, k8s, MQ등의 기술들이 있는데, 나는 이 기술들을 제대로 다뤄본 적은 없으나, 이 기술들이 어떤 목적을 달성하기 위해 탄생했고, 어떤 상황에 쓰여야 하는지 정도는 안다.&lt;/p&gt;

&lt;p&gt;그러니까 이는 곧 내 기술의 폭이다.&lt;/p&gt;

&lt;p&gt;예를 들어 Spring Application을 모니터링 해야 한다면 내가 선택할 수 있는 선택지들은 어떤것들이 있을까?&lt;/p&gt;

&lt;p&gt;리눅스의 iostat, top, htop 명령어 부터 해서, 오픈소스인 Scouter, PinPoint, Spring Actuator + Grafana, Prometheus, 상용 소프트웨어인 제니퍼, 데이터독, 와탭 등이 있을 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;외에 내가 존재조차 알지 못하는, 예를 들자면 위에서 언급되지 않은 APM 도구들이 &lt;strong&gt;내가 모른다는 것조차 모르는 것&lt;/strong&gt;이라고 볼 수 있겠다.&lt;/p&gt;

&lt;p&gt;그리고 내가 존재조차 알지 못하는 그 APM 도구는 내가 해결하려는 문제의 가장 완벽한 솔루션일 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;내가 앞으로 중요시해야 할 것은 무엇일까?&lt;/p&gt;

&lt;p&gt;일단 생각하기엔 최대한 IT 트렌드를 파악하고, 다른 현직자들의 경험담을 계속 경청하는 것이다.&lt;/p&gt;

&lt;p&gt;그들은 어떠한 문제를 겪었고, 그 문제를 어떻게 해결 했는지 등이다.&lt;/p&gt;

&lt;p&gt;기발한 발상으로 문제를 해결했을 수도 있고 내가 알지 못하는 다른 도구를 사용해 문제를 쉽게 해결했을 수도 있다.&lt;/p&gt;

&lt;p&gt;또한, 다른 현직자들이 어떤 것들에 관심을 두고 있는지 관심을 기울이며, 계속해서 정보를 공유하는 것이다.&lt;/p&gt;

&lt;p&gt;정보가 사소하던 사소하지 않던간에, 그러한 모든 정보들이 내게 도움이 될 거라고 생각한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-06-02-diary-42/</link>
			<guid isPermaLink="true">/diary/2022-06-02-diary-42/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>도메인 주도 개발 시작하기</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#대상독자&quot; id=&quot;markdown-toc-대상독자&quot;&gt;대상독자&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote class=&quot;lead&quot;&gt;
  &lt;p&gt;최범균 지음, 한빛미디어&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/169468618-19dc8e29-9b75-4dfd-b278-2248ca6968f0.png&quot; alt=&quot;image&quot; class=&quot;lead&quot; width=&quot;500&quot; height=&quot;100&quot; loading=&quot;lazy&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;DDD 핵심 개념 정리부터 구현까지&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;요즘 DDD가 그렇게 핫하다길래 뭔지 궁금해서 자료를 찾던 중 올해 출간된 책이 있어 구매해 읽었다.&lt;/p&gt;

&lt;p&gt;결론적으로 적절한 시기에 아주 적절한 책을 골라 읽었다는 만족감이 생겼다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;대상독자&quot;&gt;대상독자&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;저자이신 최범균님께서 아주 적절한 글을 책 초반부에 적어놓으셨다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/169470390-64ce50a9-6d13-426f-b279-303744334a4e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/169470451-de257d2d-d9a0-4023-9250-33fa1d70a03a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;DDD 입문서라고는 하지만, 핵심적인 개념들에 대해서는 오히려 아주 상세히 잘 설명되어 있었고, 코드 또한 굉장히 실무적이었다.&lt;/p&gt;

&lt;p&gt;최범균님이 평소 글을 많이 쓰시는 분이시라 그런지, 책의 가독성도 굉장히 훌륭하였다.&lt;/p&gt;

&lt;p&gt;이 책을 제대로 읽고 에릭 에반스의 DDD를 읽으면 아주 괜찮겠다는 생각도 들었다.&lt;/p&gt;

&lt;p&gt;DDD에 대해 관심은 있지만, DDD가 뭔지 잘 모르는 상태라면 굉장히 훌륭한 책이 될 것이라고 장담할 수 있다.&lt;/p&gt;

&lt;p&gt;한 가지 단점이라면, 책이 출간된지 얼마 안되어서 그런지 오탈자가 굉장히 많았는데, 몇몇 오탈자들은 내용 자체에 혼선을 일으키는 부분들이여서 한번씩 흐름이 꼬였다.&lt;/p&gt;

&lt;p&gt;나도 몇가지 오탈자를 제보하였으며, 이 부분은 시간이 지나면 차차 개선되지 않을까 싶다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 책을 읽고 DDD에 대해 더 관심이 생겨 약간 더 알아보다 약간의 의문이 들었는데, 나는 DDD가 아주 간단하게, 그저 널리고 널린 개발 방법론 중 하나의 개발 방법론이라 생각하고 있었으나, 종국에는 DDD라는 것은 조금 더 본질적인, 그러니까 개발에 대한 개발자의 마인드를 교정하는데 목적이 있는건가? 라는 의구심이 생겼다.&lt;/p&gt;

&lt;p&gt;왜냐하면, 대부분의 DDD 관련 아티클들은 애그리거트, CQRS 등의 이야기들만을 상세히 다루며 이러한 정보들을 별 생각 없이 접하다 보면 DDD는 일종의 패턴으로 인식이 된다.&lt;/p&gt;

&lt;p&gt;DDD에서 사용되는 용어들은 아주 많으며, 많은 아티클들에서 이 용어들에 대한 설명을 수십, 수백 페이지에 걸쳐 장황하게 설명한다.&lt;/p&gt;

&lt;p&gt;그리고 결론적으로, DDD라는 것은 패키지를 어떻게 나누고, 도메인을 어떻게 설계하고, 데이터 입력, 수정, 조회 등은 이렇게 하는 것이다!&lt;/p&gt;

&lt;p&gt;이런 식이니 종국엔 DDD가 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;레이어드 아키텍처(controller - service - repository)&lt;/code&gt;와 유사한, 하나의 개발 패턴으로 인식이 돼버린다.&lt;/p&gt;

&lt;p&gt;하지만 DDD에 대한 깊이있는 정보들을 다시 접하면 왜 DDD를 해야 하는지로 시작하고 이에 대한 합당한 주장을 펼친다.&lt;/p&gt;

&lt;p&gt;모든 상황에 DDD의 개발 패턴을 따라야 할까? 아니라고 생각한다.&lt;/p&gt;

&lt;p&gt;현실적으로 모든 프로젝트에 DDD를 완벽하게 적용하기는 힘들 것이다.&lt;/p&gt;

&lt;p&gt;왜냐하면 기존에 작성된 수 많은 레거시 프로젝트들은 도메인 위주가 아닌 데이터 중심적으로 설계됐고 운영되고 있기 때문이다. 또한, 그렇게 운영되어야만 하는 프로젝트들도 반드시 존재 할 것이다.&lt;/p&gt;

&lt;p&gt;하지만, 개발자는 단순히 도메인 전문가의 의견을 코드로 번역하는 사람이 아니며, 개발자도 도메인에 대해 도메인 전문가 만큼 깊이있게 이해해야 한다는 주장만큼은 아주 크게 동의할 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Fri, 20 May 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-05-20-diary-41/</link>
			<guid isPermaLink="true">/diary/2022-05-20-diary-41/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>클린 코더</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#성장하기&quot; id=&quot;markdown-toc-성장하기&quot;&gt;성장하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#소프트웨어-추정&quot; id=&quot;markdown-toc-소프트웨어-추정&quot;&gt;소프트웨어 추정&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#후기&quot; id=&quot;markdown-toc-후기&quot;&gt;후기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote class=&quot;lead&quot;&gt;
  &lt;p&gt;로버트 마인 지음, 정희종 옮김, 에이콘 출판사&lt;/p&gt;

  &lt;p&gt;단순 기술자에서 진정한 소프트웨어 장인이 되기까지&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/166902343-7f71cd6f-b5d4-47d2-a44b-bc2ff72f5a63.png&quot; alt=&quot;image&quot; class=&quot;lead&quot; width=&quot;500&quot; height=&quot;100&quot; loading=&quot;lazy&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;The Clean Coder&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;같은 팀 동료분의 추천으로 읽게 되었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://shirohoo.github.io/diary/2022-01-19-diary-31/&quot; target=&quot;_blank&quot;&gt;📕 소프트웨어 장인&lt;/a&gt; 과 매우 유사한 책이라고 느꼈다.&lt;/p&gt;

&lt;p&gt;전체적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로페셔널&lt;/code&gt;로서의 태도, 마음가짐에 대해 단호한 어조로 강조하고 있는 책이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;예전에 읽은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소프트웨어 장인&lt;/code&gt;에서 많은 감명을 받고 반성의 시간을 가진적이 있었고, 이후 스스로를 프로페셔널 프로그래머라 생각하며 개발에 임해왔다.&lt;/p&gt;

&lt;p&gt;이런 입장에서 볼 때 이 책의 내용은 내가 볼때 일부 극단적인 예시도 있긴 했으나, 대체로 크게 공감하며 술술 읽어 나갈 수 있었다.&lt;/p&gt;

&lt;p&gt;특히, 엉클밥이라고 불리는 로버트 마틴의 경험담 부분들이 크게 인상 깊었는데, 기간 산정을 잘못하여 프로젝트가 실패하였고 이로 인해 눈물을 쏟았다거나, 스스로의 기술적인 능력만을 과시하여 조직문화를 해쳐 해고당했었다는 이야기들은 내게 큰 교훈을 주었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;성장하기&quot;&gt;성장하기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/shirohoo/code-kata&quot; target=&quot;_blank&quot;&gt;📦 코드 카타&lt;/a&gt; 는 내 개발 커리어 내내 꾸준히 하고 있다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;우리는 직장에서 훈련하기 때문에 실수를 반복하는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;위 문구는 내가 가장 크게 감명을 받은 문구였기 때문이다.&lt;/p&gt;

&lt;p&gt;책에서도 카타와 짝 프로그래밍에 대한 이야기가 나오는데 아주 크게 공감하며 읽어나갈 수 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;또한, 다음과 같은 문구도 나왔었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;배우기에 가장 좋은 방법은 가르치는 것이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;강의형 스터디를 하고 있는 입장에서 역시 아주 크게 공감하는 대목이었다.&lt;/p&gt;

&lt;p&gt;멘토, 멘티관계의 두 사람이 있다면 오히려 더 많은것을 배워가는 사람은 멘토일수도 있다고 생각한다.&lt;/p&gt;

&lt;p&gt;사람은 누군가를 가르치며 자신의 지식을 타인에게 설명해줄 수 있을 만큼 잘 정리되어 있는지를 자가진단할 수 있다.&lt;/p&gt;

&lt;p&gt;즉, 메타인지에 아주 큰 도움이 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;소프트웨어-추정&quot;&gt;소프트웨어 추정&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;다른 분야에서 약 10년 가까이 일을 해온 나는 누가 내게 어떤 업무가 얼마나 걸릴지 물어보는 상황에 나만의 추정 방식이 있다.&lt;/p&gt;

&lt;p&gt;내가 생각할 때 3일이면 끝날 것 같다고 생각된다면, 그 기간에 x2를 하여 대답을 하는 것이다. 즉, 6일이다.&lt;/p&gt;

&lt;p&gt;사회초년생 시절에는 별 생각없이 &lt;strong&gt;“언제까지 되겠는데?”&lt;/strong&gt; 라는 생각이 들면 그 생각을 바로 입밖에 내었으나, 이 추정이 많이 실패하고서야 생긴 나만의 방식이다.&lt;/p&gt;

&lt;p&gt;그러니까… 어린 시절의 나는 스스로의 능력을 과대평가하고, 다른 동료들에게 능력있어 보이고 싶었던 것 같다.&lt;/p&gt;

&lt;p&gt;하지만 위 방식대로 하며 언제나 항상 기한을 지킬 수 있었으며, 오히려 내가 추정했던 시간보다 업무를 더 빨리 마칠때도 아주 많았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 책에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소프트웨어 추정&lt;/code&gt;이라는 단어로 정규분포를 활용해 설명을 해주고 있는데, 나는 수학을 잘 하지 못하지만 대략 나만의 기준이 이 책에서 나오는 추정법과 생각보다 비슷하다는 생각을 했다.&lt;/p&gt;

&lt;p&gt;약간의 차이라면 나만의 추정 방식은 기한은 절대 어기지 않지만, 오히려 업무가 생각한것보다 훨씬 더 빨리 끝나는 경우는 알기 힘들었다는 점이다.&lt;/p&gt;

&lt;p&gt;그러니, 관리자 입장에서 나라는 부하직원은 오히려 일정을 낭비하는 직원일수도 있었겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;내 꿈은 백발의 개발자인데, 나이가 들어도 내 개발 능력을 토대로 개발자로서 계속 일을하고 싶다.&lt;/p&gt;

&lt;p&gt;우리나라의 기업문화는 나이가 찬 직원은 관리직으로 빠지는 경우가 허다하기 때문에 과연 내 꿈이 이뤄질 수 있을지는 잘 모르겠다.&lt;/p&gt;

&lt;p&gt;만약, 스스로를 월급쟁이가 아닌 프로페셔널 개발자라고 생각한다면 시간을 내어 읽어보기를 강력하게 추천하는 책이다.&lt;/p&gt;

&lt;p&gt;이 책을 추천해준 팀 동료분에게 감사한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Thu, 05 May 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-05-05-diary-40/</link>
			<guid isPermaLink="true">/diary/2022-05-05-diary-40/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>antMatchers vs. mvcMatchers</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#cve-2016-5007&quot; id=&quot;markdown-toc-cve-2016-5007&quot;&gt;CVE-2016-5007&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#방법-1-uri에-와일드카드를-붙인다&quot; id=&quot;markdown-toc-방법-1-uri에-와일드카드를-붙인다&quot;&gt;방법 1. URI에 와일드카드를 붙인다&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#방법-2-mvcmatchers를-사용한다&quot; id=&quot;markdown-toc-방법-2-mvcmatchers를-사용한다&quot;&gt;방법 2. mvcMatchers를 사용한다&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#-reference&quot; id=&quot;markdown-toc--reference&quot;&gt;📕 Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;cve-2016-5007&quot;&gt;CVE-2016-5007&lt;/h1&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
  &lt;p&gt;Both Spring Security 3.2.x, 4.0.x, 4.1.0 and the Spring Framework 3.2.x, 4.0.x, 4.1.x, 4.2.x rely on URL pattern mappings for authorization and for mapping requests to controllers respectively. Differences in the strictness of the pattern matching mechanisms, for example with regards to space trimming in path segments, can lead Spring Security to not recognize certain paths as not protected that are in fact mapped to Spring MVC controllers that should be protected. The problem is compounded by the fact that the Spring Framework provides richer features with regards to pattern matching as well as by the fact that pattern matching in each Spring Security and the Spring Framework can easily be customized creating additional differences.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;업계에서 흔히 RESTful이라고 부르는 API 설계 방식에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;슬래시(/)&lt;/code&gt;를 통해 리소스 구조를 표현한다.&lt;/p&gt;

&lt;p&gt;흔히 볼 수 있는 방식인데, 리눅스의 파일 시스템도 이와 같은 방식으로 구분을 하고 있다.&lt;/p&gt;

&lt;p&gt;궁금하다면, 터미널에서 pwd를 입력해보자.&lt;/p&gt;

&lt;p&gt;아무튼, URI에서 슬래시는 이렇게 특별한 역할을 하고 있기 때문에, 이를 URI 맨 뒤쪽에 넣는다면 혼동이 생길 수 있다.&lt;/p&gt;

&lt;p&gt;위와 같은 이유로 스프링 시큐리티에서 기본적으로 사용하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;antMatchers&lt;/code&gt;는 URI 맨 뒤에 슬래시가 붙어있다면, 이를 제대로 검증하지 못한다.&lt;/p&gt;

&lt;p&gt;이게 무슨 말이냐면, 코드로 보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SecurityConfiguration&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebSecurityConfigurerAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpSecurity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;httpBasic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;csrf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                
            &lt;span class=&quot;c1&quot;&gt;// 블랙리스트 방식&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authorizeRequests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;antMatchers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/v1/api/members&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authenticated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;anyRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;permitAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/v1/api/members&lt;/code&gt;로 오는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET&lt;/code&gt; 방식의 요청은 인증된 상태여야만 허용되게끔 설정돼있다.&lt;/p&gt;

&lt;p&gt;이 상태에서 다음과 같은 요청을 보내보았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@SpringBootTest&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@AutoConfigureMockMvc&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DemoApplicationTests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;MockMvc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mockMvc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contextLoads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mockMvc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/v1/api/members/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;andDo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;보다시피 요청 URI 맨 뒤에 슬래시를 하나 더 붙여버렸다.&lt;/p&gt;

&lt;p&gt;실행하면 403이 응답될까? 아닐까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MockHttpServletRequest:
      HTTP Method &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; GET
      Request URI &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /v1/api/members/
       Parameters &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
          Headers &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
             Body &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
    Session Attrs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

Handler:
             Type &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; me.siro.demo.MemberController
           Method &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; me.siro.demo.MemberController#members&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

Async:
    Async started &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false
     &lt;/span&gt;Async result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

Resolved Exception:
             Type &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

ModelAndView:
        View name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
             View &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
            Model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

FlashMap:
       Attributes &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

MockHttpServletResponse:
           Status &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 200
    Error message &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
          Headers &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Content-Type:&lt;span class=&quot;s2&quot;&gt;&quot;application/json&quot;&lt;/span&gt;, X-Content-Type-Options:&lt;span class=&quot;s2&quot;&gt;&quot;nosniff&quot;&lt;/span&gt;, X-XSS-Protection:&lt;span class=&quot;s2&quot;&gt;&quot;1; mode=block&quot;&lt;/span&gt;, Cache-Control:&lt;span class=&quot;s2&quot;&gt;&quot;no-cache, no-store, max-age=0, must-revalidate&quot;&lt;/span&gt;, Pragma:&lt;span class=&quot;s2&quot;&gt;&quot;no-cache&quot;&lt;/span&gt;, Expires:&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;, X-Frame-Options:&lt;span class=&quot;s2&quot;&gt;&quot;DENY&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
     Content &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; application/json
             Body &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Liam&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Noah&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Oliver&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Elijah&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;William&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;James&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Benjamin&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Lucas&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Henry&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;Alexander&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Olivia&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Emma&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Ava&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Charlotte&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Sophia&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Amelia&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Isabella&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Mia&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Evelyn&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;s2&quot;&gt;&quot;Harper&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}]&lt;/span&gt;
    Forwarded URL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
   Redirected URL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
          Cookies &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;놀랍게도 403이 아닌 200이 응답됐으며, 모든 사용자의 정보가 외부에 노출되어버렸다.&lt;/p&gt;

&lt;p&gt;이처럼 모든 엔드포인트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허용&lt;/code&gt; 상태로 두고 몇몇 엔드포인트만 콕 집어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인증필요&lt;/code&gt; 상태로 관리하는 방식을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;블랙리스트 방식&lt;/code&gt;이라고 부르는데, 이는 스프링 시큐리티에서 권장하는 방식이 아니다.&lt;/p&gt;

&lt;p&gt;스프링 시큐리티에서는 모든 엔드포인트를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인증필요&lt;/code&gt; 상태로 관리하고, 몇몇 엔드포인트만 콕 집어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허용&lt;/code&gt; 상태로 관리하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;화이트리스트 방식&lt;/code&gt;을 권장하고 있다.&lt;/p&gt;

&lt;p&gt;즉, 화이트리스트 방식으로 코드를 작성했다면 일단 위와 같은 취약점이 생기지는 않는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SecurityConfiguration&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebSecurityConfigurerAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpSecurity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;httpBasic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;csrf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
                
            &lt;span class=&quot;c1&quot;&gt;// 화이트리스트 방식&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authorizeRequests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;antMatchers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;POST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/v1/api/members&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;permitAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;anyRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authenticated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;하지만, 업무규칙으로 인해 블랙리스트 방식으로 코드를 작성해야만 하는 경우도 있을것이다.&lt;/p&gt;

&lt;p&gt;그리고 그런 상황에 위와 같은 정보를 알지 못한다면, 보다시피 보안 취약점이 생길 여지가 분명히 존재한다.&lt;/p&gt;

&lt;p&gt;이러한 상황에 대처하기 위해 두가지 방법이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;방법-1-uri에-와일드카드를-붙인다&quot;&gt;방법 1. URI에 와일드카드를 붙인다&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SecurityConfiguration&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebSecurityConfigurerAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpSecurity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;httpBasic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;csrf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authorizeRequests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;antMatchers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/v1/api/members/**&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authenticated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//                                            ^^^ - 와일드카드 추가&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;anyRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;permitAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;URI 맨 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/**&lt;/code&gt;를 추가했다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;antMatchers&lt;/code&gt;로도 위와 같은 보안 취약점이 발생하지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MockHttpServletRequest:
      HTTP Method &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; GET
      Request URI &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /v1/api/members/
       Parameters &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
          Headers &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
             Body &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
    Session Attrs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SPRING_SECURITY_SAVED_REQUEST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DefaultSavedRequest &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;http://localhost/v1/api/members/]&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

Handler:
             Type &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

Async:
    Async started &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false
     &lt;/span&gt;Async result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

Resolved Exception:
             Type &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

ModelAndView:
        View name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
             View &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
            Model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

FlashMap:
       Attributes &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

MockHttpServletResponse:
           Status &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 403
    Error message &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Access Denied
          Headers &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;X-Content-Type-Options:&lt;span class=&quot;s2&quot;&gt;&quot;nosniff&quot;&lt;/span&gt;, X-XSS-Protection:&lt;span class=&quot;s2&quot;&gt;&quot;1; mode=block&quot;&lt;/span&gt;, Cache-Control:&lt;span class=&quot;s2&quot;&gt;&quot;no-cache, no-store, max-age=0, must-revalidate&quot;&lt;/span&gt;, Pragma:&lt;span class=&quot;s2&quot;&gt;&quot;no-cache&quot;&lt;/span&gt;, Expires:&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;, X-Frame-Options:&lt;span class=&quot;s2&quot;&gt;&quot;DENY&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
     Content &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
             Body &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
    Forwarded URL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
   Redirected URL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
          Cookies &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;요청 URI 맨 뒤에 슬래시를 추가하여 요청했음에도 403과 함께 요청이 디나이 된 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;방법-2-mvcmatchers를-사용한다&quot;&gt;방법 2. mvcMatchers를 사용한다&lt;/h2&gt;

&lt;hr /&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SecurityConfiguration&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WebSecurityConfigurerAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;HttpSecurity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;httpBasic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;csrf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;disable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authorizeRequests&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mvcMatchers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;GET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;/v1/api/members&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;authenticated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//           ^^^^^^^^^^^ - antMatchers 대체&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;anyRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;permitAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MockHttpServletRequest:
      HTTP Method &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; GET
      Request URI &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /v1/api/members/
       Parameters &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
          Headers &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
             Body &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
    Session Attrs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;SPRING_SECURITY_SAVED_REQUEST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;DefaultSavedRequest &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;http://localhost/v1/api/members/]&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

Handler:
             Type &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

Async:
    Async started &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false
     &lt;/span&gt;Async result &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

Resolved Exception:
             Type &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

ModelAndView:
        View name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
             View &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
            Model &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

FlashMap:
       Attributes &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null

MockHttpServletResponse:
           Status &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 403
    Error message &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Access Denied
          Headers &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;X-Content-Type-Options:&lt;span class=&quot;s2&quot;&gt;&quot;nosniff&quot;&lt;/span&gt;, X-XSS-Protection:&lt;span class=&quot;s2&quot;&gt;&quot;1; mode=block&quot;&lt;/span&gt;, Cache-Control:&lt;span class=&quot;s2&quot;&gt;&quot;no-cache, no-store, max-age=0, must-revalidate&quot;&lt;/span&gt;, Pragma:&lt;span class=&quot;s2&quot;&gt;&quot;no-cache&quot;&lt;/span&gt;, Expires:&lt;span class=&quot;s2&quot;&gt;&quot;0&quot;&lt;/span&gt;, X-Frame-Options:&lt;span class=&quot;s2&quot;&gt;&quot;DENY&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
     Content &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
             Body &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
    Forwarded URL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
   Redirected URL &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; null
          Cookies &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;역시 마찬가지로 요청 URI 맨 뒤에 슬래시를 추가하여 요청했음에도 403과 함께 요청이 디나이 된 모습을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;-reference&quot;&gt;📕 Reference&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-5007&quot;&gt;📜 CVE-2016-5007&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/50536292/difference-between-antmatcher-and-mvcmatcher&quot;&gt;📜 Stackoverflow - Difference between antMatcher and mvcMatcher&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/builders/HttpSecurity.RequestMatcherConfigurer.html#mvcMatchers(java.lang.String...)&quot;&gt;📜 Spring docs - RequestMatcherConfigurer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.6-Release-Notes#pathpattern-based-path-matching-strategy-for-spring-mvc&quot;&gt;📜 Spring Boot 2.6 Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/spring/spring-security/2022-03-31-mvcMatchers/</link>
			<guid isPermaLink="true">/spring/spring-security/2022-03-31-mvcMatchers/</guid>
			
			
			<category>spring</category>
			
			<category>spring-security</category>
			
		</item>
		
		<item>
			<title>개발 포기 !</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#뭘-포기하는데&quot; id=&quot;markdown-toc-뭘-포기하는데&quot;&gt;뭘 포기하는데?&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#그래서-&quot; id=&quot;markdown-toc-그래서-&quot;&gt;그래서 ?&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#-reference&quot; id=&quot;markdown-toc--reference&quot;&gt;📕 Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;뭘-포기하는데&quot;&gt;뭘 포기하는데?&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;JPA에서 DB 테이블과 매핑하기 위해 사용하는 엔티티는 접근제한자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;이 아닌 기본 생성자가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;그저께 엔티티에 무지성으로(그리고 기계적으로) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@NoArgsConstructor&lt;/code&gt;를 살포하고 있다가, &lt;u&gt;@Entity를 감지하면 접근제한자가 protected 인 기본 생성자를 자동으로 만들어주는 도구를 만들어 보면 어떨까? 그럼 @NoArgsConstructor 안 써도 되니까 이거 완전 개꿀인 부분 아닌가?&lt;/u&gt; 하는 생각이 문득 들었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 그렇다면 이것을 어떻게 만들것인지 곰곰이 생각을 또 해보니 &lt;u&gt;&quot;이거 그냥 @Entity 감지해서 기본생성자 하나 달아주면 끝이네? 개 쉽네?&quot;&lt;/u&gt; 라고 생각하고 바로 작업에 착수했다.&lt;/p&gt;

&lt;p&gt;당시 내가 고려해야 할 사항은 다음과 같이 단순했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;컴파일 타임에 매개변수가 없는 기본 생성자를 추가해주면 된다
    &lt;ul&gt;
      &lt;li&gt;프록시 기반의, 런타임에 바이트 코드를 조작하는 방식들(ASM, Byte Buddy 등)은 사용할 수 없다&lt;/li&gt;
      &lt;li&gt;그럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;annotation processor&lt;/code&gt;를 사용하면 되겠다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/160814919-2c51371c-67c4-41ca-ad67-80dff969c33c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이후 MVP를 만들어 로컬 저장소에 배포해서 돌려보니 이게 웬걸?&lt;/p&gt;

&lt;p&gt;이상한 예외가 발생했다.&lt;/p&gt;

&lt;p&gt;예외 메시지를 천천히 살펴보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;annotation processor&lt;/code&gt;는 새로운 .class파일은 만들수 있지만, 기존에 존재하는 .class파일을 수정 할 수는 없다는 것 같았다.&lt;/p&gt;

&lt;p&gt;바로 현실부정에 들어가며 스펙들을 찾아보기 시작했는데…&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;During each run of an annotation processing tool, a file with a given pathname may be created only once. If that file already exists before the first attempt to create it, the old contents will be deleted. Any subsequent attempt to create the same file during a run will throw a FilerException, as will attempting to create both a class file and source file for the same type name or same package name. The initial inputs to the tool are considered to be created by the zeroth round; therefore, attempting to create a source or class file corresponding to one of those inputs will result in a FilerException.&lt;/p&gt;

  &lt;p&gt;annotation processor를 실행할 때마다 지정된 경로명을 가진 파일은 단 한 번만 생성될 수 있습니다. 파일을 처음 생성하기 전 해당 파일이 이미 존재하는 경우 이전 내용이 삭제됩니다. 이후 실행 중에 동일한 파일을 생성하려고 하면 FilerException이 발생합니다. 이는 동일한 타입 이름 또는 동일한 패키지 이름에 대한 클래스 파일과 소스 파일을 모두 생성하려고 시도하는 것이기 때문입니다. 툴에 대한 초기 입력은 0번째 라운드에서 생성된 것으로 간주됩니다. 따라서 이러한 입력 중 하나에 해당하는 소스 또는 클래스 파일을 만들려고 하면 FilerException이 발생합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;진짜 그렇다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/160823293-5229fced-7642-4097-9539-ba6bf95154f6.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;바로 의문이 들었는데, 그럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;롬복(Lombok)&lt;/code&gt;은 대체 이걸 어떻게 하는거지?&lt;/p&gt;

&lt;p&gt;당장 롬복 깃허브에 들어가 프로젝트를 로컬 머신에 클론하고, 소스코드를 살펴보기 시작했다.&lt;/p&gt;

&lt;p&gt;이윽고 어이가 없어져버렸는데, 롬복은 무려 자바 컴파일러를 해킹하고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/160815465-b27968be-fae4-43fd-997a-a38fbd159795.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;자바 컴파일러가 자바 코드를 구문분석해 이를 트리구조로 만들어 관리하는데, 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;추상 구문 트리(AST, Abstract Syntax Tree)&lt;/code&gt; 라고 부르는 듯 했다. (JCTree가 AST의 루트 노드라는데, 이 녀석 이름 뜻은 Java Code Tree인가? 🤔)&lt;/p&gt;

&lt;p&gt;관련 자료들을 좀 둘러보다 보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eslint&lt;/code&gt;같은 정적 코드 분석 도구들이 돌아가는 방식도 이와 비슷한 원리로 추측되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아무튼 뭐가 문제냐면, 이 AST를 조작하는 API가 정식적인 공개 API가 아니고, 비공개 API 라는 것이다.&lt;/p&gt;

&lt;p&gt;한마디로 이것들은 자바팀에서 사용하지 말라고 숨겨놓은 것들인데, 롬복은 이를 리플렉션을 통해 강제로 끄집어내 사용하고 있었다. (tools.jar, com.sun.tools 패키지의…)&lt;/p&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getter&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setter&lt;/code&gt;등의 노드를 만들어 AST에 append하는 방식으로 돌아가는 듯 했다.&lt;/p&gt;

&lt;p&gt;그런데 공개 API는 외부에 직접적으로 노출되는 인터페이스이기 때문에 하위호환성을 위해 변경되지 않는게 원칙이지만, 비공개 API들은 세부 구현이기 때문에 언제든지 변경될 수 있다는게 문제다.&lt;/p&gt;

&lt;p&gt;즉, 롬복은(그리고 내가 하려던 짓은) 이 언제든지 변경될 수 있는 비공개 API들을 어거지로 끌어다 사용하고 있기 때문에, 자바의 세부 구현에 직접적으로 영향을 받고 있는 셈이었다.&lt;/p&gt;

&lt;p&gt;초창기의 롬복이 굉장히 불안정하고, 호환성이 좋지 않았던 이유가 이와 관련되지 않았을까?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;그래서-&quot;&gt;그래서 ?&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;일단 컴파일러와 AST에 대한 내 이해도도 처참한 수준이라, 내게는 구현 난이도부터 매우 높거니와(넘사벽) 어찌어찌 맨땅에 헤딩해가며 구현을 했다 하더라도 자바의 세부 구현이 변경 될 때마다 같이 유지보수를 해야 한다는 생각이 드니, 도저히 이걸 더 진행하지 못하겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;나중에 자바가 계속 개선되어 AST를 조작할 수 있는 정식적인 API가 나오게 된다면 그 때 다시 천천히 공부를 해 봐야겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 사실 롬복이 별거 아닌 줄 알았다.&lt;/p&gt;

&lt;p&gt;나는 &lt;u&gt;&quot;그까이꺼 그냥 annotation processor 몇개 구현하면 되는거 아니야?&quot;&lt;/u&gt; 라는 무식한 생각을 갖고 있었다. (무지에서 나오는 용기…)&lt;/p&gt;

&lt;p&gt;근데 코드를 뜯어보고 원리를 파헤쳐보니 정말 자바로 할 수 있는 최고 수준의 프로젝트가 아닌가 ?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;암튼 세상만사 쉬운거 하나 없다.&lt;/p&gt;

&lt;p&gt;그래도 이번 삽질에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;annotation processor&lt;/code&gt;로 어디까지 할 수 있고, 어디까지 할 수 없는지 등 생각보다 많은 걸 배운 것 같기도 하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/160973489-45f5a5bd-895c-4319-901a-17d389c48427.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;-reference&quot;&gt;📕 Reference&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html&quot;&gt;📜 javadocs javax.annotation.processing.Processor&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Filer.html&quot;&gt;📜 javadocs javax.annotation.processing.Filer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/java-annotation-processing-builder&quot;&gt;📜 Baeldung - Java Annotation Processing and Creating a Builder&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/36563807/can-i-add-a-method-to-a-class-from-a-compile-time-annotation&quot;&gt;📜 Stackoverflow - Can I add a method to a class from a compile time annotation?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jnb.ociweb.com/jnb/jnbJan2010.html&quot;&gt;📜 Reducing Boilerplate Code with Project Lombok&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/projectlombok/lombok&quot;&gt;📦 projectlombok/lombok&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmer.ink/think/lombok-principle-and-implementation.html&quot;&gt;📜 Lombok principle and Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-03-30-diary-39/</link>
			<guid isPermaLink="true">/diary/2022-03-30-diary-39/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>자바와 코틀린에 대한 생각 정리</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#java-vs-kotlin&quot; id=&quot;markdown-toc-java-vs-kotlin&quot;&gt;Java vs. Kotlin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;java-vs-kotlin&quot;&gt;Java vs. Kotlin&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;최근 코틀린에 대해 많은 관심이 생겨 문법도 보고, 이런저런 책도 보고, 코딩도 해보는 시간을 2주가량 가졌는데, 일단 굉장히 주관적인 생각이지만 결론부터 말하자면 코틀린이 자바에 비해 모든 부분에서 우세하지 않나 싶다.&lt;/p&gt;

&lt;p&gt;간결함, 확장성, Null Safety, 코루틴 등…&lt;/p&gt;

&lt;p&gt;자바로 할 수 있는 모든 것을 코틀린으로 할 수 있으면서도 자바로 하기 힘든 것들을 오히려 코틀린으로 더욱 쉽게 할 수 있는, 그러니까 코틀린은 자바의 슈퍼셋이다.&lt;/p&gt;

&lt;p&gt;한마디로 코틀린에 익숙하다면 굳이 자바를 사용해야 하느냐? 라는 의심마저 들 언어라는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이제 코틀린을 맛만 본 셈이지만 익숙하지 않은걸 한다는게 역시 굉장히 어렵다.&lt;/p&gt;

&lt;p&gt;무엇보다 프로그래밍 패러다임의 변화에 따른 사고방식 전환에서 엄청난 어려움을 겪는 것 같다.&lt;/p&gt;

&lt;p&gt;예를 들어 최근 카타를 하고있는 코틀린으로 RPG만들기 같은 경우, 플레이어가 물약을 사용하는 메서드가 있는데, 자바였다면 이 메서드가 호출될 때 물약이 없다면 IllegalStateException 같은 예외를 던졌을 것이다.&lt;/p&gt;

&lt;p&gt;하지만 함수형 프로그래밍에서는 함수에서 예외가 발생하면 해당 함수가 순수함수가 아니게 되기 때문에, 모나드 연산을 통한 여러 값을 리턴하게 되는 것 같은데, 이 때 물약이 없다면 물약을 먹지 않은 플레이어가 리턴될 것이고, 물약이 있었다면 물약을 먹은 플레이어가 리턴될 것이다.&lt;/p&gt;

&lt;p&gt;그렇다면 클라이언트는 해당 플레이어가 물약을 먹었는지 먹지 않았는지를 어떻게 판단해야 하는가?&lt;/p&gt;

&lt;p&gt;이러한 고민들로 인해 흐름이 자꾸 끊겨, 사실 코딩이 쭉쭉 이어지지는 않고 있다.&lt;/p&gt;

&lt;p&gt;결국 내 함수형 프로그래밍에 대한 이해도가 개세적인 수준이기 때문인 셈이다. 🤣&lt;/p&gt;

&lt;p&gt;코틀린도 객체지향적으로 사용하면 별 문제없겠지만, 사실 함수형도 맛깔나게 써볼 수 있는 언어를 공부 해보는데 함수형을 해보지 않는다는것도 말이 안되지 않는가?&lt;/p&gt;

&lt;p&gt;아무튼 이 사고전환의 어려움으로 인해 자바와 객체지향에 너무 깊게 심취한 나머지 내 개발 스타일이 갈라파고스화된 느낌이 없지 않아 있다는 자각을 하게 된 계기가 되기도 했다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;자바는 하위호환성을 굉장히 잘 지켜주는 언어이다.&lt;/p&gt;

&lt;p&gt;별도로 JVM 튜닝을 빡세게 한게 아니고서야 당장 자바8로 작성된 프로그램을 자바17로 변경하여 돌려도 별 무리없이 돌아갈거라 장담할 수 있을 정도다.&lt;/p&gt;

&lt;p&gt;자바 진영의 하위호환성에 대한 집착은 나도 굉장히 좋게 생각하는 부분이지만(A/B테스트 마냥 올려버린 파이썬2와 3의 선례를 생각하면…), 이렇게 하위호환성에 집착한 나머지 자바는 성장 동력을 잃어버렸다는 생각도 든다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;코틀린은 이러한 자바와의 상호호환성을 100% 보장해주며, 자바에 더 이상 도입하기 힘든 피쳐들을 도입할 수 있게 해준다.&lt;/p&gt;

&lt;p&gt;그러면서도 코틀린은 자바와의 상호호환성에 굉장히 집착한다고도 느꼈다.&lt;/p&gt;

&lt;p&gt;아무리 편리한 기능이라도 자바와의 상호호환성을 보장할 수 없다면 도입하지 않는?&lt;/p&gt;

&lt;p&gt;이는 아마 코틀린을 창조해낸 JetBrains의 상황 때문인 것 같은데, 이미 JetBrains가 상업용으로 판매하고 있는 소프트웨어들은 자바를 마개조하다시피 해서 사용하고 있는데, 이것이 한계에 부딪혀 코틀린이라는 이름의, 일종의 모던 자바를 만들어낸 셈이다.&lt;/p&gt;

&lt;p&gt;즉, 자바와의 상호호환성이 보장되지 않는다면, JetBrains는 자신들의 비즈니스에도 어느정도 타격을 입을 수 밖에 없을 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;내가 코틀린에 관심을 가지게 된 계기는, 코틀린에 대해 잘 알지 못하던 시절에도 이미 자바 LTS가 계속해서 릴리즈되며 여러 모던 언어들의 피쳐들을 도입하고 있다는걸 알고는 있었고, 특히 이번 LTS인 자바17에서는 거의 자바8에 준하는 굉장히 큰 변화가 일어났는데, 그중에서도 대부분의 변화들이 코틀린의 피쳐를 차용해와 생긴 부분임을 알았기 때문이다.&lt;/p&gt;

&lt;p&gt;자바17을 공부하고 사용하게 되며 자연스럽게 코틀린에도 많은 관심이 가게 됐고, 자바 진영의 이러한 기조와 업계 여러 회사들의 현황, 자바와 코틀린의 상호호환성을 볼 때 근 5년 내, 길어야 10년 내에 코틀린이 국내에서 굉장히 큰 파이를 가져갈 것이라는 확신도 생겼다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;국내의 고연차 개발자분들(대략 20년차 까지도?)은 사실상 자바 하나로 평생을 먹고살았다 봐도 무방할 정도라고 생각된다.&lt;/p&gt;

&lt;p&gt;하지만 우리 세대 개발자들은 어떨까?&lt;/p&gt;

&lt;p&gt;최근 100년의 변화가 지난 수천년의 변화보다 더욱 눈부신 인류의 역사에 대비해 생각해볼 때 개발 업계도 이와 크게 다르지 않을 것 같다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;미친듯이 급변하는 업계에 발맞춰 살아남기 위해서는 보다 근본적인, 보다 더 로우 레벨의 컴퓨터과학 지식에 시간과 노력을 투자해, 그 어떤 변화가 일어나도 그것들을 쉽게 수용해낼 수 있는 기반을 다져야 하며, 그 와중에도 업계가 어떤 방향으로 향하는지 계속해서 추이를 살펴야만 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;시스템이 발달하며 데이터는 미친듯이 불어나고 있는데 반해, 하드웨어는 더이상 과거처럼 눈부시게 발전하기 어렵다. 무어의 법칙은 이제 옛말이다.&lt;/p&gt;

&lt;p&gt;이 막대한 데이터를 처리해내기 위해서는 우리에게 허락된 하드웨어 성능을 최대한 효율적으로 사용해내야 하며, 현 시점 이에 대한 답은 병렬 프로세싱이다.&lt;/p&gt;

&lt;p&gt;그리고 이러한 병렬 프로세싱을 잘 활용하기 위해서는 부수효과가 없는 함수형 프로그래밍이 제격이다.&lt;/p&gt;

&lt;p&gt;그러니 현 세대 개발자인 나는 시대의 흐름에 맞춰 함수형 프로그래밍에도 시간을 투자해야만 하고, 특히 자바 개발자인 나에게 코틀린은 이 미션을 수행하기 위한 좋은 수단이 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;자연스레 코틀린을 트래킹해야 한다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;하지만 그러면서도 나는 자바를 자바스럽게 사용하는데에만 1년이 넘게 걸렸고, 아직도 잘 못한다고 생각하기 때문에 새로운 언어를 배운다는게 굉장히 막막하게 느껴진다.&lt;/p&gt;

&lt;p&gt;자바를 어떻게 써야 자바스럽게 쓸 수 있는지, 자바의 SDK에는 어떤것들이 존재하는지, 자바의 코드가 어떤 instruction set으로 변환되는지, 자바는 어떤 원리로 돌아가는지, JVM은 대략적으로 어떻게 생겨먹었고 어떻게 돌아가는지 등에 관심을 가져왔고, 아직도 이러한 주제들에 대해 제대로 알지 못한다는 생각을 하곤 한다.&lt;/p&gt;

&lt;p&gt;이런 상황에 다른 언어에 눈을 돌린다?&lt;/p&gt;

&lt;p&gt;당연히 다른 언어를 공부하며 새롭게 깨달아가는 것도 있겠지만, 아무튼 막막한건 막막한거다.&lt;/p&gt;

&lt;p&gt;자바에 쏟아부은 시간과 노력, 그 이상을 코틀린에 또 쏟아부어야 하는 것이기 때문에…&lt;/p&gt;

&lt;p&gt;비유하자면, 예전에 getting over it 이라는 이름의 게임이 하나 있었는데, 이것과 굉장히 비슷하다.&lt;/p&gt;

&lt;p&gt;어떤 아저씨가 항아리에 하반신이 갇힌 채, 오함마 하나로 벽을 타고 올라가는 게임인데, 어디서 추락하건 한번 추락하면 사실상 처음부터 다시 시작해야 한다.&lt;/p&gt;

&lt;p&gt;물론 1회차보다 2회차가 더 쉽기는 하겠다만… 그럼에도 불구하고, 종류를 막론하고 처음부터 다시 시작한다는 것은 굉장히 힘든 일임에 틀림없다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;언어하나 새로 배우는게 뭐가 어렵냐? 라고 생각할수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;결국 이 아젠다에 대한 견해는 사바사일 것 같은데, 어차피 언어의 문법이야 길어야 한두시간정도면 다 배우는 것인데, 나는 고작 이정도 했다고 새로운 언어를 배웠다고 생각하지는 않는다.&lt;/p&gt;

&lt;p&gt;내가 생각하는 문제는 그 언어의 철학, 그 이면의 동작원리, 그 언어를 그 언어스럽게 사용하는 것 등인데, 이것들은 결국 굉장히 많은 시간과 노력을 들여야만 체득되는 것이라는 생각을 갖고 있기 때문이다.&lt;/p&gt;

&lt;p&gt;C언어만 해도 기능도 별거 없고 문법은 아주 쉽지만, C언어를 잘 활용하기 위한 이런저런 트릭들이 많은걸로 알고 있다.&lt;/p&gt;

&lt;p&gt;즉, 새로운 언어 하나를 배운다는 것은 생각보다 많은 시간과 노력이 담보 되어야만 하는, 어렵고 고단한 일이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아무튼 징징대는건 이쯤하고, 미래를 보자면 나는 이걸 해야만 하기는 한다.&lt;/p&gt;

&lt;p&gt;위에 말한 게임과 관련된 관용어로 get over it이라는 게 있는데, 불평 그만하고 상황을 받아들이라는 뜻을 가졌다. (이 또한 지나가리~~~)&lt;/p&gt;

&lt;p&gt;정확하게 내 상황과 일치하는데, 그나마 코틀린은 자바 개발자에게 아주 좋고 훌륭하고 상대적으로 쉬운 언어이기도 하니 다행이다 싶기도 하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;열심히 하자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Sun, 27 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-03-27-diary-38/</link>
			<guid isPermaLink="true">/diary/2022-03-27-diary-38/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>운영체제(Operating System) 10강</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#lecture&quot; id=&quot;markdown-toc-lecture&quot;&gt;Lecture&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#disk-management-and-scheduling&quot; id=&quot;markdown-toc-disk-management-and-scheduling&quot;&gt;Disk Management and Scheduling&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#disk-structure&quot; id=&quot;markdown-toc-disk-structure&quot;&gt;Disk Structure&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#disk-management&quot; id=&quot;markdown-toc-disk-management&quot;&gt;Disk Management&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#disk-scheduling&quot; id=&quot;markdown-toc-disk-scheduling&quot;&gt;Disk Scheduling&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#fcfs-first-come-first-service&quot; id=&quot;markdown-toc-fcfs-first-come-first-service&quot;&gt;FCFS (First Come First Service)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#sstf-shortest-seek-time-first&quot; id=&quot;markdown-toc-sstf-shortest-seek-time-first&quot;&gt;SSTF (Shortest Seek Time First)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#scan-elevator-algorithm&quot; id=&quot;markdown-toc-scan-elevator-algorithm&quot;&gt;SCAN (Elevator Algorithm)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#c-scan&quot; id=&quot;markdown-toc-c-scan&quot;&gt;C-SCAN&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#n-scan-look-c-look&quot; id=&quot;markdown-toc-n-scan-look-c-look&quot;&gt;N-SCAN, LOOK, C-LOOK&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#disk-scheduling-algorithm의-결정&quot; id=&quot;markdown-toc-disk-scheduling-algorithm의-결정&quot;&gt;Disk Scheduling Algorithm의 결정&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#swap-space-management&quot; id=&quot;markdown-toc-swap-space-management&quot;&gt;Swap-Space Management&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#raid-redundant-array-of-independent-disks&quot; id=&quot;markdown-toc-raid-redundant-array-of-independent-disks&quot;&gt;RAID (Redundant Array of Independent Disks)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;lecture&quot;&gt;Lecture&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kocw.or.kr/home/cview.do?mty=p&amp;amp;kemId=1046323&quot;&gt;운영체제 - 반효경 교수님&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Disk Management and Scheduling 1&lt;/li&gt;
      &lt;li&gt;Disk Management and Scheduling 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;disk-management-and-scheduling&quot;&gt;Disk Management and Scheduling&lt;/h1&gt;

&lt;h2 id=&quot;disk-structure&quot;&gt;Disk Structure&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114161-048feeed-9f6f-4774-9112-0a599c417e35.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Logical Block
    &lt;ul&gt;
      &lt;li&gt;디스크의 외부에서 보는 디스크의 단위 정보 저장 공간&lt;/li&gt;
      &lt;li&gt;디스크 외부에서는 이를 주소를 가진 1차원 배열로 취급&lt;/li&gt;
      &lt;li&gt;디스크에 데이터가 저장될때, 디스크 I/O가 일어날때 모두 논리 블록 단위로 관리&lt;/li&gt;
      &lt;li&gt;디스크에 저장된 데이터에 접근하기 위해서는 해당 데이터가 저장돼있는 논리 블록의 인덱스 번호를 디스크로 전달해야 함&lt;/li&gt;
      &lt;li&gt;논리 블록은 가상 메모리처럼 논리적인 개념이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Sector
    &lt;ul&gt;
      &lt;li&gt;디스크의 물리적인 최소 단위&lt;/li&gt;
      &lt;li&gt;논리 블록과 매핑된 디스크의 물리적인 위치 (논리블록 : 섹터 = 1 : 1)&lt;/li&gt;
      &lt;li&gt;디스크의 물리적인 구조는 마그네틱 원판으로 구성돼있으며, 이 원판은 최소 하나 이상이다&lt;/li&gt;
      &lt;li&gt;각 원판은 트랙(Track)으로 구성돼있고, 각 트랙은 섹터로 구성돼있다&lt;/li&gt;
      &lt;li&gt;여러 개의 원판에서 상대적으로 동일한 위치의 트랙 집합을 실린더라고 부른다&lt;/li&gt;
      &lt;li&gt;섹터 0은 최외곽 실린더의 첫 번째 트랙의 첫 번째 섹터이다
        &lt;ul&gt;
          &lt;li&gt;디스크에 데이터를 읽고 쓰기 위해서는 디스크 암(Disk Arm)이 해당 섹터가 위치한 실린더로 이동 후 원판이 회전하여 디스크 헤드가 저장된 섹터 위치에 도달해야 한다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;disk-management&quot;&gt;Disk Management&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Physical Formatting (Low-Level Formatting)
    &lt;ul&gt;
      &lt;li&gt;디스크를 컨트롤러가 읽고 쓸 수 있도록 여러개의 섹터로 나누는 과정&lt;/li&gt;
      &lt;li&gt;각 섹터는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;header&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data(보통 512 bytes)&lt;/code&gt; + &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trailer&lt;/code&gt; 로 구성&lt;/li&gt;
      &lt;li&gt;header와 trailer는 sector number, ECC(Error-Correcting Code) 등의 정보가 저장되며 컨트롤러가 직접 접근 및 운영&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Partitioning
    &lt;ul&gt;
      &lt;li&gt;디스크를 하나 이상의 실린더 그룹으로 나누는 과정&lt;/li&gt;
      &lt;li&gt;OS는 이것을 독립적인 디스크로 취급한다 (물리적인 하드디스크는 하나이지만, C드라이브, D드라이브등으로 나눌 수 있다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Logical Formatting
    &lt;ul&gt;
      &lt;li&gt;파일 시스템을 만드는 것&lt;/li&gt;
      &lt;li&gt;FAT, Inode, Free Space 등의 구조를 포함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Booting
    &lt;ul&gt;
      &lt;li&gt;ROM에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Small Bootstrap Loader&lt;/code&gt;를 실행&lt;/li&gt;
      &lt;li&gt;sector 0(boot block)을 load하여 실행&lt;/li&gt;
      &lt;li&gt;sector 0은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Full Bootstrap Loader Program&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;OS를 디스크에서 load하여 실행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;disk-scheduling&quot;&gt;Disk Scheduling&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;디스크에 대한 접근 시간(Access Time)은 아래 세 가지 시간의 합
    &lt;ul&gt;
      &lt;li&gt;탐색 시간(seek time)
        &lt;ul&gt;
          &lt;li&gt;디스크 헤드를 해당 실린더 위치로 이동하는 데 걸리는 시간&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;회전 지연 시간(rotational latency)
        &lt;ul&gt;
          &lt;li&gt;디스크가 회전해서 읽고 쓰려는 섹터가 헤드 위치에 도달하기까지 걸리는 시간&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;전송 시간(transfer time)
        &lt;ul&gt;
          &lt;li&gt;해당 섹터가 헤드 위치에 도달한 후 데이터를 실제로 섹터에 읽고 쓰는 데 소요되는 시간&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;회전 지연 시간과 전송 시간은 상대적으로 수치가 작고 운영체제 입장에서 통제하기 힘든 부분이기에 탐색 시간을 줄이기 위해 헤드의 움직임을 최소화하는 스케쥴링 작업을 함&lt;/li&gt;
  &lt;li&gt;즉, 디스크 스케쥴링의 가장 중요한 목표는 디스크 헤드의 이동 거리를 줄이는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fcfs-first-come-first-service&quot;&gt;FCFS (First Come First Service)&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;FCFS은 디스크에 먼저 들어온 요청을 먼저 처리하는 방식 (FIFO와 사실상 같다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114492-19e12dfa-f987-4235-9ce1-dbd05d5ab3b2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재 디스크 헤드가 53번 실린더에 있을 경우 헤드는 53에서 출발해 98, 183, …과 같이 요청이 들어온 순서대로 이동하게 되므로 총 헤드가 이동한 거리는 640이 된다&lt;/li&gt;
  &lt;li&gt;FCFS는 합리적인 것처럼 보이지만 효율성은 매우 떨어진다&lt;/li&gt;
  &lt;li&gt;최악의 경우 디스크의 한쪽 끝과 반대쪽 끝을 왔다갔다하면 탐색 시간이 매우 길어지므로 접근 시간이 기하급수적으로 커질 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sstf-shortest-seek-time-first&quot;&gt;SSTF (Shortest Seek Time First)&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;SSTF 스케쥴링은 헤드의 현재 위치로부터 가장 가까운 위치에 있는 요청을 제일 먼저 처리하는 알고리즘이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114528-90805343-e606-4a48-9b43-4bdaa1389ccf.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;53번 실린더에서 출발하여 가장 가까운 65번, 그 후 65번에서 가장 가까운 67번, …을 반복하여 총 이동 거리는 236이다&lt;/li&gt;
  &lt;li&gt;FCFS보다 약 3배나 성능 개선이 이루어진 것을 볼 수 있다&lt;/li&gt;
  &lt;li&gt;그러나 SSTF는 Starvation(기아) 문제를 초래할 수 있다
    &lt;ul&gt;
      &lt;li&gt;현재의 헤드 위치 근방으로 무한히 요청이 들어오면, 헤드 위치에서 멀리 있는 요청은 영원히 기다려야 할 수도 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;scan-elevator-algorithm&quot;&gt;SCAN (Elevator Algorithm)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114582-4105cc88-4d4c-49a7-bb97-640df5d0f5ab.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SCAN은 헤드가 디스크 원판의 안쪽 끝과 바깥쪽 끝을 오가며, 그 경로에 존재하는 모든 요청을 처리하는 것&lt;/li&gt;
  &lt;li&gt;즉, 디스크의 어떠한 위치에 요청이 들어오는 가와 상관 없이 헤드는 정해진 방향으로 이동하면서 길목에 있는 요청을 처리하며 지나감&lt;/li&gt;
  &lt;li&gt;문제점: 실린더 위치에 따라 대기 시간이 다름
    &lt;ul&gt;
      &lt;li&gt;제일 안쪽이나 제일 바깥쪽 위치보다는 가운데 위치가 평균 대기 시간이 짧다&lt;/li&gt;
      &lt;li&gt;예를 들어 0번에서 199번까지 200개의 실린더를 가진 디스크의 경우 0번 실린더나 199번 실린더를 막 지나가고 나서 해당 지점에 요청이 들어왔다면 반대쪽 끝까지 헤드가 갔다 와야 하므로 이동 거리 400만큼 대기해야 하지만, 100번 실린더를 막 지나가고 나서 해당 지점에 요청이 들어왔다면 대기해야 하는 이동 거리가 200에 불과함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114657-5337a1b5-ae2c-4efd-ad68-fd526e27201f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;c-scan&quot;&gt;C-SCAN&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114734-a5d901ae-92c9-4dd2-9735-80416cf73bd4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C-SCAN은 SCAN처럼 헤드가 한쪽 끝에서 다른 쪽 끝으로 이동하며 가는 길목에 있는 모든 요청을 처리&lt;/li&gt;
  &lt;li&gt;하지만 SCAN과 달리 헤드가 다른 족 끝에 도달해 방향을 바꾼 후에는 요청을 처리하지 않고 곧바로 출발점으로 다시 이동&lt;/li&gt;
  &lt;li&gt;SCAN 알고리즘보다 균일한 대기 시간을 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114717-ee5908d6-b6b3-4222-a681-22298b8bc312.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;헤드가 53번 실린더에서 출발하여 199번 실린더까지 이동하며 중간에 있는 요청을 처리&lt;/li&gt;
  &lt;li&gt;헤드가 199번 실린더에 도달하면 0번 다시 실린더로 이동하는데, 이때는 중간에 있는 요청을 처리하지 않음&lt;/li&gt;
  &lt;li&gt;이후 0번 실린더에서 다시 199번 실린더로 이동하면서 중간에 있는 요청을 처리&lt;/li&gt;
  &lt;li&gt;총 이동 거리는 383&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;n-scan-look-c-look&quot;&gt;N-SCAN, LOOK, C-LOOK&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;N-SCAN 알고리즘
    &lt;ul&gt;
      &lt;li&gt;SCAN의 변형 알고리즘&lt;/li&gt;
      &lt;li&gt;일단 헤드가 한 방향으로 움직이기 시작하면 그 시점 이후에 도착한 요청은 되돌아올 때 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;LOOK, C-LOOK 알고리즘
    &lt;ul&gt;
      &lt;li&gt;SCAN이나 C-SCAN은 헤드가 디스크 끝에서 끝으로 이동&lt;/li&gt;
      &lt;li&gt;LOOK과 C-LOOK은 헤드가 이동 중 그 방향에 더 이상 기다리는 요청이 없으면 헤드의 이동 방향을 즉시 반전시킴&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159114910-66d29e54-0b1f-4ca7-87d6-0cd70d2e275d.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;disk-scheduling-algorithm의-결정&quot;&gt;Disk Scheduling Algorithm의 결정&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;SCAN, C-SCAN 및 그 응용 알고리즘은 LOOK, C-LOOK 등이 일반적으로 디스크 입출력이 많은 시스템에서 효율적인 것으로 알려져 있음&lt;/li&gt;
  &lt;li&gt;현대 컴퓨팅 시스템에서는 SCAN 기반의 알고리즘들을 많이 사용하고 있음
    &lt;ul&gt;
      &lt;li&gt;디스크 헤드의 이동거리를 줄일 수 있는것이 가장 큰 이유&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;File의 할당 방법에 따라 디스크 요청이 영향을 받음
    &lt;ul&gt;
      &lt;li&gt;연속 할당을 했다면 연속된 실린더 위치에 존재하기 때문에 헤드의 이동거리를 줄일 수 있음&lt;/li&gt;
      &lt;li&gt;불연속 할당을 했다면 헤드의 이동거리가 상대적으로 증가할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크 스케쥴링 알고리즘은 필요할 경우 다른 알고리즘으로 쉽게 교체할 수 있도록 OS와 별도의 모듈로 작성되는 것이 바람직
    &lt;ul&gt;
      &lt;li&gt;디스크 스케쥴링의 효율을 결정짓는 변인이 많기 때문에, 디스크 스케쥴링 알고리즘을 쉽게 변경할 수 있어야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;swap-space-management&quot;&gt;Swap-Space Management&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159115229-893425cb-bbaa-4c6f-9d7e-d9a9f9ed7711.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;디스크를 사용하는 이유는 메모리의 제약적인 성질때문이다
    &lt;ul&gt;
      &lt;li&gt;메모리의 휘발성을 비휘발성인 파일 시스템으로 해결&lt;/li&gt;
      &lt;li&gt;메모리의 단가가 비싸기 때문에 프로그램 실행을 위한 메모리 공간은 항상 부족&lt;/li&gt;
      &lt;li&gt;메모리 공간 부족을 디스크를 활용한 Swap space로 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Swap-Space
    &lt;ul&gt;
      &lt;li&gt;가상 메모리 시스템에서 디스크를 메모리의 연장 공간으로 사용&lt;/li&gt;
      &lt;li&gt;파일 시스템 내부에 둘 수도 있으나 별도 파티션을 사용하는 것이 일반적
        &lt;ul&gt;
          &lt;li&gt;공간 효율성보다는 속도 효율성이 우선
            &lt;ul&gt;
              &lt;li&gt;공간 효율성이 덜 중요한 이유는, 어차피 시간이 조금 지나 프로세스가 종료되면 사라질 내용들이기 때문&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;일반 파일보다 훨씬 짧은 시간만 존재하고 자주 참조됨&lt;/li&gt;
          &lt;li&gt;따라서 블록의 크기 및 저장 방식이 일반 파일 시스템과 다름&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;raid-redundant-array-of-independent-disks&quot;&gt;RAID (Redundant Array of Independent Disks)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/159115328-0dcf8b37-02b7-4233-b878-f06b01177489.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RAID는 여러 개의 디스크(특히 저렴한)를 묶어서 사용하는 것&lt;/li&gt;
  &lt;li&gt;RAID의 사용 목적
    &lt;ul&gt;
      &lt;li&gt;디스크 처리 속도 향상
        &lt;ul&gt;
          &lt;li&gt;여러 디스크에다 블록의 내용들을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분산 저장&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;병렬적으로 읽어올 수 있음 (interleaving 혹은 striping)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;신뢰성(Reliability) 향상
        &lt;ul&gt;
          &lt;li&gt;동일 정보를 여러 디스크에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;중복 저장&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;하나의 디스크가 고장나도 다른 디스크에서 읽어올 수 있음 (mirroring 혹은 shadowing)&lt;/li&gt;
          &lt;li&gt;단순한 중복 저장이 아니라 일부 디스크에 parity(오류 검출 코드)를 저장하여 공간의 효율성을 높일 수도 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Sat, 19 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/cs/operating-system/2022-03-19-disk-management/</link>
			<guid isPermaLink="true">/cs/operating-system/2022-03-19-disk-management/</guid>
			
			
			<category>cs</category>
			
			<category>operating-system</category>
			
		</item>
		
		<item>
			<title>운영체제(Operating System) 9강</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#lecture&quot; id=&quot;markdown-toc-lecture&quot;&gt;Lecture&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#file-and-file-system&quot; id=&quot;markdown-toc-file-and-file-system&quot;&gt;File and File System&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#directory-and-logical-disk&quot; id=&quot;markdown-toc-directory-and-logical-disk&quot;&gt;Directory and Logical Disk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#open&quot; id=&quot;markdown-toc-open&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open()&lt;/code&gt;&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#open-동작-과정&quot; id=&quot;markdown-toc-open-동작-과정&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open()&lt;/code&gt; 동작 과정&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#file-protection&quot; id=&quot;markdown-toc-file-protection&quot;&gt;File Protection&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#mounting-of-file-system&quot; id=&quot;markdown-toc-mounting-of-file-system&quot;&gt;Mounting of File System&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#access-method&quot; id=&quot;markdown-toc-access-method&quot;&gt;Access Method&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#allocation-of-file-data-in-disk&quot; id=&quot;markdown-toc-allocation-of-file-data-in-disk&quot;&gt;Allocation of File Data in Disk&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#contiguous-allocation&quot; id=&quot;markdown-toc-contiguous-allocation&quot;&gt;Contiguous Allocation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#linked-allocation&quot; id=&quot;markdown-toc-linked-allocation&quot;&gt;Linked Allocation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#indexed-allocation&quot; id=&quot;markdown-toc-indexed-allocation&quot;&gt;Indexed Allocation&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#unix-파일시스템의-구조&quot; id=&quot;markdown-toc-unix-파일시스템의-구조&quot;&gt;UNIX 파일시스템의 구조&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#fat-file-system&quot; id=&quot;markdown-toc-fat-file-system&quot;&gt;FAT File System&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#free-space-management&quot; id=&quot;markdown-toc-free-space-management&quot;&gt;Free-Space Management&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#directory-implementation&quot; id=&quot;markdown-toc-directory-implementation&quot;&gt;Directory Implementation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#vfs-and-nfs&quot; id=&quot;markdown-toc-vfs-and-nfs&quot;&gt;VFS and NFS&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#page-cache-and-buffer-cache&quot; id=&quot;markdown-toc-page-cache-and-buffer-cache&quot;&gt;Page Cache and Buffer Cache&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#execution-of-the-program&quot; id=&quot;markdown-toc-execution-of-the-program&quot;&gt;Execution of The Program&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#memory-mapped-io-수행&quot; id=&quot;markdown-toc-memory-mapped-io-수행&quot;&gt;Memory Mapped I/O 수행&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#read-수행&quot; id=&quot;markdown-toc-read-수행&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 수행&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#memory-mapped-io-vs-read&quot; id=&quot;markdown-toc-memory-mapped-io-vs-read&quot;&gt;Memory Mapped I/O vs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;lecture&quot;&gt;Lecture&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kocw.or.kr/home/cview.do?mty=p&amp;amp;kemId=1046323&quot;&gt;운영체제 - 반효경 교수님&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;File Systems&lt;/li&gt;
      &lt;li&gt;File Systems Implementation 1&lt;/li&gt;
      &lt;li&gt;File Systems Implementation 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;file-and-file-system&quot;&gt;File and File System&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;파일
    &lt;ul&gt;
      &lt;li&gt;이름이 있는 정보의 묶음&lt;/li&gt;
      &lt;li&gt;일반적으로 비휘발성인 보조 기억 장치(HDD, SSD)에 저장&lt;/li&gt;
      &lt;li&gt;운영체제는 다양한 저장 장치를 파일이라는 동일한 논리적 단위로 볼 수 있게 해 줌&lt;/li&gt;
      &lt;li&gt;연산자(커널 함수, 이느 모두 시스템 콜을 동반한다)
        &lt;ul&gt;
          &lt;li&gt;create, read, write, reposition(lseek), delete, open, close 등&lt;/li&gt;
          &lt;li&gt;reposition(lseek): 위치를 변경 및 저장&lt;/li&gt;
          &lt;li&gt;open: 파일의 메타데이터를 메모리에 탑재&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일의 속성(메타데이터)
    &lt;ul&gt;
      &lt;li&gt;파일 자체의 내용이 아니라 파일을 관리하기 위한 각종 정보
        &lt;ul&gt;
          &lt;li&gt;파일의 이름, 유형, 저장된 위치, 파일 사이즈&lt;/li&gt;
          &lt;li&gt;접근 권한(읽기/쓰기/실행), 시간(생성/변경/사용), 소유자 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파일 시스템
    &lt;ul&gt;
      &lt;li&gt;운영체제에서 파일을 관리하는 부분&lt;/li&gt;
      &lt;li&gt;파일 및 파일의 메타데이터, 디렉토리 정보 등을 관리&lt;/li&gt;
      &lt;li&gt;파일의 저장 방법 결정&lt;/li&gt;
      &lt;li&gt;파일 보호 등&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;directory-and-logical-disk&quot;&gt;Directory and Logical Disk&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;디렉토리
    &lt;ul&gt;
      &lt;li&gt;파일의 메타데이터 중 일부를 보관하고 있는 일종의 특별한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파일&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;그 디렉토리에 속한 파일 이름 및 파일의 속성&lt;/li&gt;
      &lt;li&gt;연산자
        &lt;ul&gt;
          &lt;li&gt;search for a file, create a file, delete a file&lt;/li&gt;
          &lt;li&gt;list a directory, rename a file, traverse the file system&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파티션 (=논리 디스크)
    &lt;ul&gt;
      &lt;li&gt;하나의 물리 디스크 안에 여러 파티션을 두는 것이 일반적&lt;/li&gt;
      &lt;li&gt;여러 개의 물리 디스크를 하나의 파티션으로 구성하기도 함&lt;/li&gt;
      &lt;li&gt;물리 디스크를 파티션으로 구성한 뒤 각각의 파티션에 파일 시스템을 깔거나 스와핑(page 관련) 등 다른 용도로 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;open&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open()&lt;/code&gt;&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158370138-d7b27c81-feb4-4761-92c1-bc6ae3c59068.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;open(/a/b/c)
    &lt;ul&gt;
      &lt;li&gt;디스크로부터 파일 c의 메타데이터를 메모리로 가지고 옴&lt;/li&gt;
      &lt;li&gt;이를 위하여 directory path를 탐색
        &lt;ul&gt;
          &lt;li&gt;루트 디렉토리 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/&lt;/code&gt; 를 open하고 그 안에서 파일 위치 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 의 위치를 획득&lt;/li&gt;
          &lt;li&gt;파일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; 를 open한 후 read하여 그 안에서 파일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 의 위치를 획득&lt;/li&gt;
          &lt;li&gt;파일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;b&lt;/code&gt; 를 open한 후 read하여 그 안에서 파일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 의 위치를 획득&lt;/li&gt;
          &lt;li&gt;파일 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c&lt;/code&gt; 를 open&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Directory path의 탐색에 너무 많은 시간 소요
        &lt;ul&gt;
          &lt;li&gt;그래서 open을 read/write와 별도로 둠&lt;/li&gt;
          &lt;li&gt;한 번 open한 파일은 read / write시 directory 탐색이 불필요&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Open file table
        &lt;ul&gt;
          &lt;li&gt;현재 open된 파일의 in memory 메타데이터 보관소&lt;/li&gt;
          &lt;li&gt;디스크의 메타데이터보다 몇 가지 정보가 추가됨
            &lt;ul&gt;
              &lt;li&gt;open한 프로세스의 수&lt;/li&gt;
              &lt;li&gt;file offset: 파일 어느 위치를 접근 중인지 표시 (별도 테이블 필요)&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;File descriptor
        &lt;ul&gt;
          &lt;li&gt;Open file table에 대한 위치 정보 (프로세스 별)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;open-동작-과정&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Open()&lt;/code&gt; 동작 과정&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158371573-eceb904e-2975-45ae-a6bc-898c6f0f30c4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;root의 위치는 고정이기 때문에 즉시 알 수 있다. 디스크에 있던 root의 메타데이터가 메모리에 올라감&lt;/li&gt;
  &lt;li&gt;메모리에 있는 root의 주소를 찾고, root에 존재하는 a의 메타데이터에 접근&lt;/li&gt;
  &lt;li&gt;a의 메타데이터를 메모리에 올림 (Open file table)&lt;/li&gt;
  &lt;li&gt;메모리에 있는 a의 주소를 찾고, a에 존재하는 b의 메타데이터에 접근&lt;/li&gt;
  &lt;li&gt;b의 메타데이터를 메모리에 올림 (Open file table)&lt;/li&gt;
  &lt;li&gt;메모리에 올라온 b의 메타데이터를 가르키는 포인터 값(file descriptor)를 open() 함수의 결과로 반환&lt;/li&gt;
  &lt;li&gt;프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;open()&lt;/code&gt; 함수의 반환 값을 전달 받음&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 함수가 호출되면, open() 호출시 반환 받은 file descriptor 값을 이용하여 b의 컨텐츠를 읽고, 읽은 컨텐츠를 디스크 버퍼 캐시에 저장&lt;/li&gt;
  &lt;li&gt;디스크 버퍼 캐시에 있는 b의 컨텐츠를 커널 메모리의 버퍼 캐시에 저장&lt;/li&gt;
  &lt;li&gt;커널 메모리 버퍼 캐시에 있는 b의 컨텐츠를 사용자 메모리의 버퍼 캐시에 저장&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 시스템에서는 메모리때와 다르게 LRU, LFU와 같은 알고리즘을 사용한 버퍼 캐싱이 가능하다&lt;/li&gt;
  &lt;li&gt;메모리 관리는 하드웨어들이 직접 하였기 때문에 운영체제가 관여할 수 없었지만, 파일 시스템의 경우 시스템 콜을 통해 진행이 되기 때문에, 운영체제가 관여할 수 있는 부분이 많다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;file-protection&quot;&gt;File Protection&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158372059-1979c17e-1fe1-4419-8686-31d316047d05.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mounting-of-file-system&quot;&gt;Mounting of File System&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158372128-b8597b49-d0d2-4169-b209-f2d549d02e1f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 파티션에 별도의 파일 시스템을 설치할 수 있다&lt;/li&gt;
  &lt;li&gt;한 파티션의 파일 시스템에서 다른 파티션의 파일 시스템에 접근하고 싶다면?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158372366-af06ede3-3b9f-4909-b238-8af701ab5c62.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;마운팅을 통해 서로 다른 파티션에 있는 파일 시스템에 접근할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;access-method&quot;&gt;Access Method&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158372593-b99041d7-9746-48b6-9915-9b13b52293b4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;allocation-of-file-data-in-disk&quot;&gt;Allocation of File Data in Disk&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;모든 파일의 크기는 불규칙적이다&lt;/li&gt;
  &lt;li&gt;파일을 동일한 크기로 쪼개어 디스크에 sector(512byte) 단위로 저장한다&lt;/li&gt;
  &lt;li&gt;프로세스를 여러개의 페이지로 나눠 관리하던 메모리 관리를 떠올리면 이해가 쉽다&lt;/li&gt;
  &lt;li&gt;디스크에 파일 데이터를 할당하는 방식은 세가지가 존재한다
    &lt;ul&gt;
      &lt;li&gt;Contiguous Allocation&lt;/li&gt;
      &lt;li&gt;Linked Allocation&lt;/li&gt;
      &lt;li&gt;Indexed Allocation&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;contiguous-allocation&quot;&gt;Contiguous Allocation&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;하나의 파일이 디스크 sector에 연속해서 저장되는 방식&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158373315-eb9a904b-2144-42ed-86bd-02f8c7aed764.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;매우 빠른 I/O
        &lt;ul&gt;
          &lt;li&gt;디스크의 처리 시간은 디스크 헤드가 디스크 트랙의 특정 sector로 이동하는데 걸리는 시간이 전부&lt;/li&gt;
          &lt;li&gt;파일이 연속적으로 위치하기 때문에 파일의 첫 sector에 한번만 seek/rotation하면 사실상 끝난다&lt;/li&gt;
          &lt;li&gt;빠른 속도로 인해 Realtime 파일 용, 혹은 프로세스의 스와핑용으로 매우 적합(공간 효율성보다 시간 효율성이 중요한 시스템)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Direct Access(Random Access)가 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;외부 단편화 발생&lt;/li&gt;
      &lt;li&gt;File grow가 어려움
        &lt;ul&gt;
          &lt;li&gt;파일 생성시 얼마나 큰 hole을 할당할 것인가&lt;/li&gt;
          &lt;li&gt;gorw 가능 vs 낭비(내부 단편화 발생)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;linked-allocation&quot;&gt;Linked Allocation&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;하나의 파일이 불연속적인 디스크 sector에 나누어 저장되고, 각 sector가 하나의 노드가 되어 연결리스트 구조로 저장되는 방식&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158374550-2291671b-b297-4e82-888b-b7059a1e4629.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;외부 단편화 발생 안함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;연결리스트 구조상 반드시 첫 요소부터 차례대로 읽어야 하므로 Random Access 불가
        &lt;ul&gt;
          &lt;li&gt;Reliability 문제
            &lt;ul&gt;
              &lt;li&gt;한 sector가 고장나 다음 sector를 가리키는 포인터가 유실되면 많은 부분을 유실함&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;포인터를 위한 공간(4byte)이 필요하므로 공간 효율성을 떨어뜨리게 된다 (512byte/sector - 4byte/pointer = 508byte/remaining sector)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;변형(Linked Allocation의 개선 버전)
        &lt;ul&gt;
          &lt;li&gt;File-allocation table (FAT) 파일 시스템
            &lt;ul&gt;
              &lt;li&gt;포인터를 별도의 위치에 보관하여 신뢰성 문제와 공간 효율성 문제를 해결한 시스템&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;indexed-allocation&quot;&gt;Indexed Allocation&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;파일이 어디에 나눠져 있는지 인덱스를 기록 해 두는 sector(index block) 하나를 만들어 활용하는 방식&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158375525-aa7d7fd5-e026-4c7e-92aa-e6a8da7e6b14.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;외부 단편화가 발생하지 않음&lt;/li&gt;
      &lt;li&gt;Random Access 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;작은 파일의 경우 공간이 낭비 됨(실제로 많은 파일들이 작다)&lt;/li&gt;
      &lt;li&gt;매우 큰 파일의 경우 하나의 인덱스 블록이 부족할 수 있다
        &lt;ul&gt;
          &lt;li&gt;Linked Scheme&lt;/li&gt;
          &lt;li&gt;Multi-level Index&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;unix-파일시스템의-구조&quot;&gt;UNIX 파일시스템의 구조&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158376389-e2302f77-835e-4310-a4a0-65499bd547f3.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Boot block
    &lt;ul&gt;
      &lt;li&gt;모든 파일 시스템의 약속&lt;/li&gt;
      &lt;li&gt;부팅에 필요한 정보를 담고 있는 블록&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Super block
    &lt;ul&gt;
      &lt;li&gt;파일 시스템에 관한 총체적인 정보를 담고 있는 블록&lt;/li&gt;
      &lt;li&gt;빈 블록, 사용 중인 블록, Inode 블록의 위치, Data 블록의 위치 등을 알려 주는 정보 갖고 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Inode list (index node list)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파일 이름을 제외한 파일의 모든 메타데이터&lt;/code&gt;를 따로 저장&lt;/li&gt;
      &lt;li&gt;파일 하나 당 Inode가 하나씩 할당되고, Inode는 파일의 메타데이터를 갖고 있다&lt;/li&gt;
      &lt;li&gt;파일의 이름은 디렉토리가 가지고 있으며, 디렉토리는 파일의 이름과 Inode의 인덱스를 갖고 있다.
        &lt;ul&gt;
          &lt;li&gt;이전 수업에서 디렉토리가 파일의 메타데이터를 모두 가지고 있다고 했는데, 유닉스 파일 시스템의 디렉토리는 파일의 이름과 Inode의 인덱스를 가지고 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;direct block은 파일이 존재하는 인덱스를 저장하는 인덱스 블록이다
        &lt;ul&gt;
          &lt;li&gt;파일의 크기가 크지 않다면 이 블록을 이용하여 파일에 접근할 수 있다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;direct block으로 커버할 수 있는 크기보다 저장 용량이 큰 파일은 single indirect를 통해서 하나의 level을 두어서 저장하는 방식을 취하고, 그보다 더 큰 파일은 double indirect, 더 큰 파일은 triple indirect 방식을 취한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Data block
    &lt;ul&gt;
      &lt;li&gt;파일의 실제 내용을 보관하는 블록&lt;/li&gt;
      &lt;li&gt;이 중 디렉토리 파일은 자신의 디렉토리에 속한 파일들의 이름과 Inode 인덱스를 가지고 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;fat-file-system&quot;&gt;FAT File System&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158576628-86d31a40-cc9a-4d1f-afba-91837456fee6.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FAT 파일 시스템은 윈도우즈 계열에서 주로 사용&lt;/li&gt;
  &lt;li&gt;파일의 메타데이터 일부를 FAT에 저장하고, 나머지 정보는 디렉토리가 가지고 있음&lt;/li&gt;
  &lt;li&gt;위 이미지에서 217번이 첫 번째 블록인데, 다음 블록의 위치를 FAT에 별도로 관리&lt;/li&gt;
  &lt;li&gt;FAT 테이블 전체를 메모리에 올려 놓았으므로 Linked Allocation의 단점(Random Access 불가, Reliability 문제, 공간 효율성 문제)을 전부 극복함&lt;/li&gt;
  &lt;li&gt;FAT는 중요한 정보이므로 복제본을 만들어 두어야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;free-space-management&quot;&gt;Free-Space Management&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158577070-6c6e735f-e76c-498d-be8d-9e81469ff3a9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;directory-implementation&quot;&gt;Directory Implementation&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158577140-40309088-bc17-441e-b5a3-35edc8e5e3fd.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일 메타데이터의 보관 위치
    &lt;ul&gt;
      &lt;li&gt;디렉토리 내에 직접 보관&lt;/li&gt;
      &lt;li&gt;디렉토리에는 포인터를 두고 다른 곳에 보관
        &lt;ul&gt;
          &lt;li&gt;Inode, FAT 등&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;긴 파일명 지원
    &lt;ul&gt;
      &lt;li&gt;&amp;lt;파일명, 파일 메타데이터&amp;gt;의 리스트에서 각 엔트리는 일반적으로 고정 크기&lt;/li&gt;
      &lt;li&gt;하지만 파일명이 고정된 엔트리 길이보다 긴 경우 마지막 엔트리 내 파일명의 뒷 부분이 위치한 곳에 포인터를 둠&lt;/li&gt;
      &lt;li&gt;파일명의 나머지 부분은 동일한 디렉토리 파일의 일부에 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vfs-and-nfs&quot;&gt;VFS and NFS&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158577707-f4b596ba-af09-4386-bb1e-a64587bc2b72.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158577633-3f3c84c8-e3e7-431f-8c17-3d3d16996e3b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-cache-and-buffer-cache&quot;&gt;Page Cache and Buffer Cache&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158577800-d3b1ec22-6177-4829-9e1e-ad993e6f2e70.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158577899-a53e1801-aa94-441e-9895-09cac7a798c9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158578032-a7221738-e2b1-41cc-8bc1-cac4b62871c2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;execution-of-the-program&quot;&gt;Execution of The Program&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158578217-c3997efc-49d3-4cd6-bcd5-ece61eab73bf.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램이 실행되면 실행 파일이 프로세스가 되며, 프로세스만의 독자적인 주소 공간이 만들어 진다.&lt;/li&gt;
  &lt;li&gt;이 공간은 코드, 데이터, 스택으로 구분되며 당장 사용될 부분은 물리 메모리에 올라가고, 당장 사용되지 않는 부분은 스왑 영역으로 내려간다.&lt;/li&gt;
  &lt;li&gt;이때 코드 부분은 이미 파일 시스템에 있기 때문에 스왑 영역에 내리지 않고, 필요 없으면 물리 메모리에서 지운다. 나중에 필요하면 파일 시스템에서 가져오면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;memory-mapped-io-수행&quot;&gt;Memory Mapped I/O 수행&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158578253-401cfd6f-9b9d-420b-b977-0a32d1e89ae1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 일반 데이터 파일을 I/O하고 싶을 수 있음&lt;/li&gt;
  &lt;li&gt;이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap()&lt;/code&gt; 호출시 Memory Mapped I/O 방식으로 파일을 I/O 할 수 있고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap()&lt;/code&gt; 은 시스템 콜이 필요한 함수이므로 운영체제에 CPU의 제어권이 넘어감&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158578317-0424b9c9-e559-48b5-9c77-c88b296298dc.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제는 데이터 파일의 일부를 프로세스 메모리에 매핑한다&lt;/li&gt;
  &lt;li&gt;만약 데이터 파일이 매핑영역에 접근했을 때, 물리 메모리에 페이지가 올라와 있지 않다면 Page Fault가 발생&lt;/li&gt;
  &lt;li&gt;그렇지 않으면 가상 메모리의 매핑영역은 물리 메모리의 페이지 프레임과 일치되므로 프로세스가 데이터 파일에 대해 I/O 를 수행 하고 싶을 때 운영체제의 도움 없이 독자적으로 할 수 있다&lt;/li&gt;
  &lt;li&gt;물리 메모리에 올라간 데이터 파일과 매핑된 페이지 프레임을 swap out 할 때는 스왑 영역으로 옮기는 것이 아니라 수정사항을 파일 시스템에 적용하고 물리 메모리에서 제거&lt;/li&gt;
  &lt;li&gt;현재 프로세스 B가 데이터 파일에 대해 Memory Mapped I/O를 수행하여 물리 메모리에 페이지 프레임을 올려 두었으므로, 프로세스 A도 이 페이지 프레임을 공유하여 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;read-수행&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 수행&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158578328-1fca4829-e60e-415f-a79c-862537e88783.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스가 일반적인 데이터 파일을 I/O 하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 함수를 호출할 수도 있다&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 함수는 메모리의 버퍼 캐시를 확인해야 하는데, 통합 버퍼 캐시 환경에서는 페이지 캐시가 버퍼 캐시 역할을 동시에 수행한다. 따라서, Memory Mapped I/O로 올라 간 페이지 캐시를 버퍼 캐시로 사용할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/158578348-8a5a3c2b-53dd-4c86-8edc-be5a1ff195c4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;운영체제는 버퍼 캐시에 있던 데이터를 복사하여 프로세스의 주소 공간에 할당한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;memory-mapped-io-vs-read&quot;&gt;Memory Mapped I/O vs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Memory Mapped I/O
    &lt;ul&gt;
      &lt;li&gt;가상 메모리에 올라온 영역이 파일이므로 시스템 콜 없이 I/O 작업을 할 수 있음&lt;/li&gt;
      &lt;li&gt;페이지 캐시에 있는 내용을 복사할 필요가 없음&lt;/li&gt;
      &lt;li&gt;여러 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mmap()&lt;/code&gt; 을 사용하여 같은 영역을 공유하여 사용하면 일관성 문제가 발생할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;운영체제에 의해 제어 됨&lt;/li&gt;
      &lt;li&gt;페이지 캐시에 있는 내용을 복사해야 함&lt;/li&gt;
      &lt;li&gt;여러 프로세스가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;read()&lt;/code&gt; 를 사용해도 일관성 문제가 발생하지 않음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Fri, 18 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/cs/operating-system/2022-03-18-file-system/</link>
			<guid isPermaLink="true">/cs/operating-system/2022-03-18-file-system/</guid>
			
			
			<category>cs</category>
			
			<category>operating-system</category>
			
		</item>
		
		<item>
			<title>운영체제(Operating System) 8강</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#lecture&quot; id=&quot;markdown-toc-lecture&quot;&gt;Lecture&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#virtual-memory&quot; id=&quot;markdown-toc-virtual-memory&quot;&gt;Virtual Memory&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#demand-paging&quot; id=&quot;markdown-toc-demand-paging&quot;&gt;Demand Paging&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#page-fault&quot; id=&quot;markdown-toc-page-fault&quot;&gt;Page Fault&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#performance-of-demand-paging&quot; id=&quot;markdown-toc-performance-of-demand-paging&quot;&gt;Performance of Demand Paging&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#page-replacement&quot; id=&quot;markdown-toc-page-replacement&quot;&gt;Page Replacement&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#page-replacement-algorithm&quot; id=&quot;markdown-toc-page-replacement-algorithm&quot;&gt;Page Replacement Algorithm&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#optimal-algorithm&quot; id=&quot;markdown-toc-optimal-algorithm&quot;&gt;Optimal Algorithm&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#fifo-first-in-first-out&quot; id=&quot;markdown-toc-fifo-first-in-first-out&quot;&gt;FIFO (First-In-First-Out)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#lru-least-recently-used&quot; id=&quot;markdown-toc-lru-least-recently-used&quot;&gt;LRU (Least Recently Used)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#lfu-least-frequently-used&quot; id=&quot;markdown-toc-lfu-least-frequently-used&quot;&gt;LFU (Least Frequently Used)&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#다양한-캐싱-환경&quot; id=&quot;markdown-toc-다양한-캐싱-환경&quot;&gt;다양한 캐싱 환경&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#페이징-시스템에서-lru-lfu-가능한가&quot; id=&quot;markdown-toc-페이징-시스템에서-lru-lfu-가능한가&quot;&gt;페이징 시스템에서 LRU, LFU 가능한가?&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#clock-algorithm&quot; id=&quot;markdown-toc-clock-algorithm&quot;&gt;Clock Algorithm&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#page-frame-allocation&quot; id=&quot;markdown-toc-page-frame-allocation&quot;&gt;Page Frame Allocation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#global-vs-local-replacement&quot; id=&quot;markdown-toc-global-vs-local-replacement&quot;&gt;Global vs Local Replacement&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#thrashing&quot; id=&quot;markdown-toc-thrashing&quot;&gt;Thrashing&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#working-set&quot; id=&quot;markdown-toc-working-set&quot;&gt;Working-Set&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#pff-page-fault-frequency&quot; id=&quot;markdown-toc-pff-page-fault-frequency&quot;&gt;PFF (Page-Fault Frequency)&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#page-size-결정&quot; id=&quot;markdown-toc-page-size-결정&quot;&gt;Page Size 결정&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;lecture&quot;&gt;Lecture&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kocw.or.kr/home/cview.do?mty=p&amp;amp;kemId=1046323&quot;&gt;운영체제 - 반효경 교수님&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Virtual Memory 1&lt;/li&gt;
      &lt;li&gt;Virtual Memory 2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;virtual-memory&quot;&gt;Virtual Memory&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;demand-paging&quot;&gt;Demand Paging&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;페이지가 실제로 필요할 때 메모리에 올리기에 다음과 같은 장점이 있다
    &lt;ul&gt;
      &lt;li&gt;I/O 감소&lt;/li&gt;
      &lt;li&gt;메모리 사용량 감소&lt;/li&gt;
      &lt;li&gt;빠른 응답 시간&lt;/li&gt;
      &lt;li&gt;더 많은 사용자 수용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Valid/Invalid Bit
    &lt;ul&gt;
      &lt;li&gt;Invalild의 의미
        &lt;ul&gt;
          &lt;li&gt;사용되지 않는 주소 영역인 경우&lt;/li&gt;
          &lt;li&gt;페이지가 물리 메모리에 없는 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;최초에는 모든 page entry가 Invalid로 초기화 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157585722-6b5f5ec9-6d1c-44b1-9d11-091cc10f91d1.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0, 2, 5 (A, C, F) 는 당장 필요한 부분이기 때문에,
물리 메모리에 올라가 있고 Valid로 마킹 되어있다&lt;/li&gt;
  &lt;li&gt;1, 3, 4 (B, D, E) 는 논리 메모리에는 올라가 있지만 당장 사용되지 않고 있는 부분이기 때문에 Invalid로 마킹 되어있다&lt;/li&gt;
  &lt;li&gt;6, 7 (G, H) 같은 경우에는 페이지가 물리 메모리에 없는 상태이기 때문에,
Invalid로 마킹 되어있다&lt;/li&gt;
  &lt;li&gt;Invalid Bit이 설정되어 있으면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Page Fault&lt;/code&gt; 인터럽트가 발생하며, 쉽게 얘기하자면 물리 메모리에 페이지가 존재하지 않으니 확인해보라는 의미이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-fault&quot;&gt;Page Fault&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Invalid Page에 접근하면 MMU가 interrupt를 발생시킨다 (page fault trap)&lt;/li&gt;
  &lt;li&gt;커널 모드로 전환 후 Page Fault Handler가 호출 된다&lt;/li&gt;
  &lt;li&gt;Page Fault 처리 순서
    &lt;ul&gt;
      &lt;li&gt;Invalid 를 참조&lt;/li&gt;
      &lt;li&gt;빈 Page Frame을 가져오는데, 없으면 뺏어온다 (Page Replace)&lt;/li&gt;
      &lt;li&gt;해당 페이지를 디스크에서 메모리로 읽어온다 (swap in)&lt;/li&gt;
      &lt;li&gt;디스크 읽기/쓰기 작업이 끝날 때 까지 프로세스가 blocked된다&lt;/li&gt;
      &lt;li&gt;디스크 읽기가 끝나면 PTE(Page Table Entry)를 기록하고,
Valid/Invalid Bit을 Valid로 바꾼다.&lt;/li&gt;
      &lt;li&gt;Ready Queue에 프로세스를 넣는다&lt;/li&gt;
      &lt;li&gt;이 프로세스가 CPU를 점유하여 다시 running&lt;/li&gt;
      &lt;li&gt;아까 중단되었던 Instruction을 재개&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;performance-of-demand-paging&quot;&gt;Performance of Demand Paging&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 부재의 발생 빈도가 성능에 가장 큰 영향을 미친다.&lt;/li&gt;
  &lt;li&gt;유효 접근 시간(요청한 페이지를 참조하는 데 걸리는 시간)
    &lt;ul&gt;
      &lt;li&gt;(1 - P) x 메모리 접근 시간 + P x M&lt;/li&gt;
      &lt;li&gt;페이지 부재 발생 비율(P) → 0 ≤ P ≤ 1
        &lt;ul&gt;
          &lt;li&gt;P = 0: 페이지 부재가 한 번도 일어나지 않은 경우&lt;/li&gt;
          &lt;li&gt;P = 1: 모든 참조 요청에서 페이지 부재가 발생한 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;M (각종 오버헤드)
        &lt;ul&gt;
          &lt;li&gt;페이지 부재 발생 처리 오버헤드&lt;/li&gt;
          &lt;li&gt;메모리에 빈 프레임이 없는 경우 swap out 오버헤드&lt;/li&gt;
          &lt;li&gt;요창된 페이지의 swap in 오버헤드&lt;/li&gt;
          &lt;li&gt;프로세스의 재시작 오버헤드&lt;/li&gt;
          &lt;li&gt;위 오버헤드의 총합&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;쉽게 얘기하면 Page Fault가 발생했을때의 오버헤드는 매우 값 비싸다&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-replacement&quot;&gt;Page Replacement&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Page Fault가 발생하여 요청된 페이지를 디스크에서 메모리로 읽어오려고 하는데, 물리 메모리에 빈 공간이 없을 수 있다&lt;/li&gt;
  &lt;li&gt;이때 이미 메모리에 올라와 있는 페이지 중 하나를 디스크로 쫓아내(swap out) 물리 메모리에 빈 공간을 확보하는데, 어떠한 페이지를 교체할지 결정하는 것을 Page Replacement라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157590366-024ff8db-0d8c-4087-8abe-56fd47caede2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-replacement-algorithm&quot;&gt;Page Replacement Algorithm&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 교체를 할 때에 어떠한 프레임에 있는 페이지를 swap out 할 것인지 결정하는 알고리즘
    &lt;ul&gt;
      &lt;li&gt;이 알고리즘의 목표는 페이지 부재율을 최소화하는 것&lt;/li&gt;
      &lt;li&gt;주어진 페이지 참조열에 대한 부재율을 계산하여 알고리즘을 평가한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;optimal-algorithm&quot;&gt;Optimal Algorithm&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;물리 메모리에 존재하는 페이지 중 가장 먼 미래에 참조될 페이지를 쫓아내는 알고리즘&lt;/li&gt;
  &lt;li&gt;미래의 참조를 알아야 하므로 현실적으로 구현할 수 없다&lt;/li&gt;
  &lt;li&gt;하지만 현존하는 알고리즘 중 가장 성능이 좋으므로, 타 알고리즘과의 비교를 위해 사용된다&lt;/li&gt;
  &lt;li&gt;즉, 다른 알고리즘의 성능에 대한 상한선을 제공&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157590646-46e2fd52-6f11-40d9-ba1e-d719903c81fe.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;초기 4회는 물리 메모리가 비어있으므로 불가피하게 Page Fault가 발생&lt;/li&gt;
  &lt;li&gt;이후 1, 2는 물리 메모리에 1, 2페이지가 있으므로 Page Fault가 발생하지 않는다&lt;/li&gt;
  &lt;li&gt;페이지 5는 물리 메모리에 없으므로 가장 먼 미래에 참조되는 페이지 4를 디스크로 swap out&lt;/li&gt;
  &lt;li&gt;반복한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fifo-first-in-first-out&quot;&gt;FIFO (First-In-First-Out)&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;물리 메모리에 가장 먼저 올라온 페이지를 우선적으로 swap out한다&lt;/li&gt;
  &lt;li&gt;메모리가 증가하였음에도 Page Fault가 오히려 늘어나는 현상이 발생할 수 있다 (Belady’s Anomaly)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157591193-28223764-61f1-4972-bc0b-6ef39800d7a4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lru-least-recently-used&quot;&gt;LRU (Least Recently Used)&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;지역성 이론중, 시간적 지역성에 따른 알고리즘이다&lt;/li&gt;
  &lt;li&gt;최근에 참조된 것이 조만간 다시 참조될 수 있다는 것인데, 역설적으로 말하면 최근에 참조되지 않은 것은 다시 참조될 확률이 적다고 볼수도 있는 것이다&lt;/li&gt;
  &lt;li&gt;즉, 가장 오래 전에 참조됐던 페이지를 swap out 하는 알고리즘이다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157591589-4b8fc2d9-33dc-4b26-b923-2626243da8de.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;초기 4회는 물리 메모리가 비어있으므로 불가피하게 Page Fault가 발생&lt;/li&gt;
  &lt;li&gt;이후 1, 2는 물리 메모리에 1, 2페이지가 있으므로 Page Fault가 발생하지 않는다&lt;/li&gt;
  &lt;li&gt;페이지 5는 물리 메모리에 없으므로 가장 오래 전에 참조된 페이지 3을 디스크로 swap out한다&lt;/li&gt;
  &lt;li&gt;반복한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lfu-least-frequently-used&quot;&gt;LFU (Least Frequently Used)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;페이지의 참조 횟수가 가장 적은 페이지를 교체하는 알고리즘&lt;/li&gt;
  &lt;li&gt;최저 참조 횟수인 페이지가 여러 개 있는 경우
    &lt;ul&gt;
      &lt;li&gt;LFU 알고리즘 자체에서는 여러 페이지 중 임의로 선정&lt;/li&gt;
      &lt;li&gt;성능 향상을 위해 가장 오래 전에 참조된 페이지를 지우게 구현할 수도 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;LRU처럼 직전 참조 시점만 보는 것이 아니라 장기적인 규모로 보기 때문에 페이지의 인기도를 조금 더 정확히 반영할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;참조 시점의 최근성을 반영하지 못한다&lt;/li&gt;
      &lt;li&gt;LRU보다 구현이 복잡하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;다양한-캐싱-환경&quot;&gt;다양한 캐싱 환경&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;캐싱 기법
    &lt;ul&gt;
      &lt;li&gt;한정된 빠른 공간(=캐시)에 요청된 데이터를 저장해 두었다가 후속 요청시 캐시로부터 직접 서비스하는 방식&lt;/li&gt;
      &lt;li&gt;페이징 시스템 외에도 캐시 메모리, 버퍼 캐시, 웹 캐시 등 다양한 분야에서 사용된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;캐시 운영의 시간 제약
    &lt;ul&gt;
      &lt;li&gt;교체 알고리즘에서 삭제할 항목을 결정하는 일에 지나치게 많은 시간이 걸리는 경우 실제 시스템에서 사용할 수 없다&lt;/li&gt;
      &lt;li&gt;버퍼 캐시나나 웹 캐시의 경우 O(1)에서 O(log N)까지 허용&lt;/li&gt;
      &lt;li&gt;페이징 시스템의 경우
        &lt;ul&gt;
          &lt;li&gt;Page Fault의 경우에만 OS가 관여한다.&lt;/li&gt;
          &lt;li&gt;페이지가 이미 메모리에 존재하는 경우 참조 시각 등의 정보를 OS가 알 수 없다&lt;/li&gt;
          &lt;li&gt;O(1)인 LRU의 List 조작조차 불가능&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;페이징-시스템에서-lru-lfu-가능한가&quot;&gt;페이징 시스템에서 LRU, LFU 가능한가?&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157619731-c0d89443-d995-4df8-97c7-5d52d02141fc.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 A가 CPU를 잡고 실행 중인 상태라면, 프로세스 A의 논리 메모리에서 매 순간 명령어를 읽어와서 처리 할 것이다&lt;/li&gt;
  &lt;li&gt;이때 페이지 테이블을 통해서 논리 주소를 물리 주소로 변환 하여 물리 메모리에 있는 내용을 CPU로 읽어와야 한다
    &lt;ul&gt;
      &lt;li&gt;주소 변환을 했는데 해당하는 페이지가 이미 물리 메모리에 올라와 있다면 물리 메모리를 그대로 읽는다&lt;/li&gt;
      &lt;li&gt;위와 같은 주소 변환 과정은 모두 하드웨어가 담당하며, OS는 일체 관여하지 않는다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변환하려는 논리 주소의 Valid-Invalid Bit의 값이 Invalid 여서 Page Fault가 발생하였다면 Backing Store 접근을 필요로 한다&lt;/li&gt;
  &lt;li&gt;이때 DISK I/O를 수행해야 하므로 trap이 발동하여 interrupt가 발생하고 CPU의 제어권이 프로세스 A에서 OS로 넘어가게 된다&lt;/li&gt;
  &lt;li&gt;OS가 디스크의 Page Fault가 발생한 페이지를 물리 메모리로 swap in하고, 그 과정에서 물리 메모리에 빈 공간이 없다면 물리 메모리의 페이지 하나를 swap out해야 한다&lt;/li&gt;
  &lt;li&gt;위 일련의 과정을 수행하면서 LRU, LFU 알고리즘을 적용할 수 있을까?
    &lt;ul&gt;
      &lt;li&gt;프로세스가 요청한 페이지가 메모리에 이미 있는 경우에는 CPU가 OS로 넘어가지 않는다&lt;/li&gt;
      &lt;li&gt;Page Fault 가 발생해야 CPU 제어권이 OS로 넘어가므로 디스크에서 메모리로 페이지가 넘어오는 시간을 파악할 수 있다&lt;/li&gt;
      &lt;li&gt;즉, Page Fault가 발생할 때만 페이지에 접근하는 정보를 알 수 있으므로 LRU, LFU 알고리즘은 페이징 시스템에서 사용할 수 없다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;clock-algorithm&quot;&gt;Clock Algorithm&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;LRU의 근사 알고리즘이다&lt;/li&gt;
  &lt;li&gt;여러 명칭으로 불린다
    &lt;ul&gt;
      &lt;li&gt;Second Chance Algorithm&lt;/li&gt;
      &lt;li&gt;NUR(Not Used Recently)&lt;/li&gt;
      &lt;li&gt;NRU (Not Recently Used)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Reference Bit를 사용하여 교체 대상 페이지를 선정한다. (circular list)
    &lt;ul&gt;
      &lt;li&gt;Reference Bit를 수정하는 작업은 OS가 아닌, 하드웨어가 수행&lt;/li&gt;
      &lt;li&gt;Reference Bit가 0인 것을 찾을 때까지 포인터를 하나씩 앞으로 이동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Clock Algorithm 개선
    &lt;ul&gt;
      &lt;li&gt;Reference Bit와 Modified Bit(Dirty Bit)를 함께 사용한다.&lt;/li&gt;
      &lt;li&gt;Reference Bit가 1이면 최근에 참조된 페이지&lt;/li&gt;
      &lt;li&gt;Modified Bit(Dirty Bit)가 1이면 최근에 변경된 페이지 (I/O를 동반하는 페이지)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157621089-fc271e3f-ffb5-4807-8e8d-5a0ece5b6fef.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 사각형은 물리 메모리에 있는 페이지 프레임을 의미&lt;/li&gt;
  &lt;li&gt;페이지에 대해 어떤 페이지가 참조되어 CPU가 그 페이지를 사용하게 되면, 하드웨어는 그 페이지의 Reference Bit가 1로 세팅한다&lt;/li&gt;
  &lt;li&gt;OS는 포인터를 이동하면서 페이지의 Reference Bit가 이미 1이면, 페이지를 swap out 하지 않고 Reference Bit를 0으로 세팅한 후 다음 페이지의 Reference Bit를 검사&lt;/li&gt;
  &lt;li&gt;OS는 다시 포인터를 이동하다가 Reference Bit가 0인 페이지를 찾으면, 해당 페이지를 swap out
    &lt;ul&gt;
      &lt;li&gt;Reference Bit는 해당 페이지가 참조될 때 하드웨어가 1로 세팅하므로 시계 바늘이 한 바퀴 돌아오는 동안에 다시 참조되지 않은 경우 그 페이지는 교체되는 것이다&lt;/li&gt;
      &lt;li&gt;A라는 페이지 프레임의 Reference Bit를 0으로 바꾼 후, 다시 한 바퀴 돌아서 A 페이지 프레임의 Reference Bit가 0이면 가장 오랫동안 참조가 일어나지 않은 페이지라고 판단한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;개선 클럭 알고리즘은 Reference Bit 외에 Modified Bit를 사용
    &lt;ul&gt;
      &lt;li&gt;Modified Bit는 어떤 페이지가 쫓겨날 때, 이 페이지의 Modified Bit가 0이면 Backing Store에서 물리적 메모리로 올라온 이후로 수정이 되지 않은 페이지이므로 바로 메모리에서 지워도 된다&lt;/li&gt;
      &lt;li&gt;Modified Bit가 1이면 물리 메모리로 올라온 이후로 수정이 발생한 페이지이므로 swap out 전에 Backing Store에 수정한 내용을 반영하고 메모리에서 지워야 한다&lt;/li&gt;
      &lt;li&gt;Modified Bit가 1이면 디스크로 swap out 되는 페이지의 수정된 내용을 반영하는 오버헤드가 발생하므로, 해당 페이지를 swap out하지 않고 Modified Bit를 0으로 수정한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;page-frame-allocation&quot;&gt;Page Frame Allocation&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157621799-03d544c6-bf18-4e53-83fc-a4562a6ec09a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;global-vs-local-replacement&quot;&gt;Global vs Local Replacement&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157621873-721e44a3-d55c-44d2-8e2a-28f3fcf6344f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;thrashing&quot;&gt;Thrashing&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스의 원활한 수행에 필요한 최소한의 Page Frame수를 할당받지 못하면 Page Fault Rate가 크게 상승하여 CPU 이용률이 떨어지고, 낮은 처리량을 보이는 현상이다.&lt;/li&gt;
  &lt;li&gt;스레싱이 발생하는 시나리오
    &lt;ul&gt;
      &lt;li&gt;OS는 CPU 이용률이 낮을 경우 메모리에 올라와 있는 프로세스의 수가 적다고 판단하여 메모리에 올라가는 프로세스를 늘린다
        &lt;ul&gt;
          &lt;li&gt;Ready Queue에 프로세스가 단 하나라도 있으면 CPU는 그 프로세스를 실행하므로 쉬지 않고 일하게 되는데, CPU 이용률이 낮다는 것은 Ready Queue가 비어있다는 것을 의미한다&lt;/li&gt;
          &lt;li&gt;메모리에 올라가 있는 프로세스의 수를 Multi Programming Degree(MPD)라고 부른다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MPD가 과도하게 높아지면 각 프로세스에게 할당되는 메모리의 양이 감소한다&lt;/li&gt;
      &lt;li&gt;각 프로세스는 그들이 원활하게 수행되기 위해 필요한 최소한의 Page Frame도 할당 받지 못하므로 Page Fault Rate가 증가한다&lt;/li&gt;
      &lt;li&gt;Page Fault가 발생하면 DISK I/O를 수반하므로 다른 프로세스에게 CPU가 넘어간다&lt;/li&gt;
      &lt;li&gt;다른 프로세스 역시 Page Fault가 발생하고 있어서 또 다른 프로세스에게 CPU가 넘어간다&lt;/li&gt;
      &lt;li&gt;결국 Ready Queue에 있는 모든 프로세스에게 CPU가 한 차례씩 할당 되었는데도 모든 프로세스에 Page Fault가 발생하여 CPU의 이용률이 급격하게 떨어진다&lt;/li&gt;
      &lt;li&gt;OS는 위 현상이 MPD가 낮다고 판단하여 다시 MPD를 높이려고 한다&lt;/li&gt;
      &lt;li&gt;이러한 악순환이 계속 반복되는 상황을 스레싱이라고 부른다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157621970-6df5542f-aaef-4494-ade5-732212f76da0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;working-set&quot;&gt;Working-Set&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157625267-c9c8d326-4136-4a54-8b13-b78151967424.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157625352-5c2ebca3-37ab-4f78-8b27-80c99695f79f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pff-page-fault-frequency&quot;&gt;PFF (Page-Fault Frequency)&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157625610-f41955e2-1961-4d7d-8441-b15e05bb2a3c.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Page Fault Rate를 주기적으로 조사하고 이 값에 근거해서 각 프로세스에 할당할 메모리 양을 동적으로 조절하는 것&lt;/li&gt;
  &lt;li&gt;Page Fault Rate의 상한값과 하한값을 둔다
    &lt;ul&gt;
      &lt;li&gt;Page Fault Rate의 상한값을 넘으면 페이지 프레임을 더 할당한다&lt;/li&gt;
      &lt;li&gt;Page Fault Rate의 하한값보다 낮으면 할당 페이지 프레임 수를 줄인다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;빈 페이지 프레임이 없으면 일부 프로세스를 swap out한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;page-size-결정&quot;&gt;Page Size 결정&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157625917-35bfc93b-eba0-450c-b5c1-96c19d12e2e9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/cs/operating-system/2022-03-10-virtual-memory/</link>
			<guid isPermaLink="true">/cs/operating-system/2022-03-10-virtual-memory/</guid>
			
			
			<category>cs</category>
			
			<category>operating-system</category>
			
		</item>
		
		<item>
			<title>운영체제(Operating System) 7강</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#lecture&quot; id=&quot;markdown-toc-lecture&quot;&gt;Lecture&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#memory&quot; id=&quot;markdown-toc-memory&quot;&gt;Memory&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#logical-address-vs-physical-address&quot; id=&quot;markdown-toc-logical-address-vs-physical-address&quot;&gt;Logical Address vs Physical Address&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#address-binding&quot; id=&quot;markdown-toc-address-binding&quot;&gt;Address Binding&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mmumemory-management-unit&quot; id=&quot;markdown-toc-mmumemory-management-unit&quot;&gt;MMU(Memory Management Unit)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#memory-terminology&quot; id=&quot;markdown-toc-memory-terminology&quot;&gt;Memory Terminology&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#dynamic-loading&quot; id=&quot;markdown-toc-dynamic-loading&quot;&gt;Dynamic Loading&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#overlay&quot; id=&quot;markdown-toc-overlay&quot;&gt;Overlay&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#swapping&quot; id=&quot;markdown-toc-swapping&quot;&gt;Swapping&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#dynamic-linking&quot; id=&quot;markdown-toc-dynamic-linking&quot;&gt;Dynamic Linking&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#allocation-of-physical-memory&quot; id=&quot;markdown-toc-allocation-of-physical-memory&quot;&gt;Allocation Of Physical Memory&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#contiguous-allocation&quot; id=&quot;markdown-toc-contiguous-allocation&quot;&gt;Contiguous Allocation&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#dynamic-storage-allocation-problem&quot; id=&quot;markdown-toc-dynamic-storage-allocation-problem&quot;&gt;Dynamic Storage Allocation Problem&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;#compaction&quot; id=&quot;markdown-toc-compaction&quot;&gt;Compaction&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#non-contiguous-allocation&quot; id=&quot;markdown-toc-non-contiguous-allocation&quot;&gt;Non-Contiguous Allocation&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#paging&quot; id=&quot;markdown-toc-paging&quot;&gt;Paging&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#address-translation-architecture&quot; id=&quot;markdown-toc-address-translation-architecture&quot;&gt;Address Translation Architecture&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#implementation-of-page-table&quot; id=&quot;markdown-toc-implementation-of-page-table&quot;&gt;Implementation Of Page Table&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#tlb&quot; id=&quot;markdown-toc-tlb&quot;&gt;TLB&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#hierarchical-paging&quot; id=&quot;markdown-toc-hierarchical-paging&quot;&gt;Hierarchical Paging&lt;/a&gt;            &lt;ul&gt;
              &lt;li&gt;&lt;a href=&quot;#two-level-page-table&quot; id=&quot;markdown-toc-two-level-page-table&quot;&gt;Two-Level Page Table&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#paging-1&quot; id=&quot;markdown-toc-paging-1&quot;&gt;Paging&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#multilevel-paging-and-performance&quot; id=&quot;markdown-toc-multilevel-paging-and-performance&quot;&gt;Multilevel Paging and Performance&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#memory-protection&quot; id=&quot;markdown-toc-memory-protection&quot;&gt;Memory Protection&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#inverted-page-table&quot; id=&quot;markdown-toc-inverted-page-table&quot;&gt;Inverted Page Table&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#shared-page&quot; id=&quot;markdown-toc-shared-page&quot;&gt;Shared Page&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#segmentation&quot; id=&quot;markdown-toc-segmentation&quot;&gt;Segmentation&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#segmentation-architecture&quot; id=&quot;markdown-toc-segmentation-architecture&quot;&gt;Segmentation Architecture&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#segmentation-hardware&quot; id=&quot;markdown-toc-segmentation-hardware&quot;&gt;Segmentation Hardware&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#protection&quot; id=&quot;markdown-toc-protection&quot;&gt;Protection&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#sharing&quot; id=&quot;markdown-toc-sharing&quot;&gt;Sharing&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#allocation-of-physical-memory-1&quot; id=&quot;markdown-toc-allocation-of-physical-memory-1&quot;&gt;Allocation of Physical Memory&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#advantages-and-disadvantages-of-segmentation&quot; id=&quot;markdown-toc-advantages-and-disadvantages-of-segmentation&quot;&gt;Advantages and Disadvantages of Segmentation&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#paged-segmentation&quot; id=&quot;markdown-toc-paged-segmentation&quot;&gt;Paged Segmentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;lecture&quot;&gt;Lecture&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kocw.or.kr/home/cview.do?mty=p&amp;amp;kemId=1046323&quot;&gt;운영체제 - 반효경 교수님&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Memory Management 1&lt;/li&gt;
      &lt;li&gt;Memory Management 2&lt;/li&gt;
      &lt;li&gt;Memory Management 3&lt;/li&gt;
      &lt;li&gt;Memory Management 4&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;memory&quot;&gt;Memory&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;각 프로세스는 독립적인 메모리를 점유한다 하였다.&lt;/p&gt;

&lt;p&gt;이번에는 운영체제가 메모리를 어떻게 관리하는지 알아 볼 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;logical-address-vs-physical-address&quot;&gt;Logical Address vs Physical Address&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156889420-a02b0b51-2254-48a6-a06b-26faa8315555.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;address-binding&quot;&gt;Address Binding&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;프로세스의 논리적 주소를 물리적 메모리 주소로 연결하는 작업을 말한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Symbolic Address -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Logical Address (바로 이 시점)&lt;/code&gt; -&amp;gt; Physical Address&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Symbolic Address는 프로그래머 입장에서 사용하는 것이며, 프로그래머는 데이터를 메모리 몇 번지에 저장하라고 코딩하지 않고, 문자로 된 변수명을 사용한다.&lt;/p&gt;

&lt;p&gt;마찬가지로, 함수도 메모리 몇 번지로 jump하라고 코딩하지 않고, 문자로 된 함수명을 사용한다.&lt;/p&gt;

&lt;p&gt;이를 Symbolic하다고 표현하며, 주소 바인딩 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156890004-1ab854de-9a36-414b-93d4-25b9f785f41a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Compile Time Binding&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램을 컴파일할 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식&lt;/li&gt;
      &lt;li&gt;컴파일 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 이미 결정하므로 프로그램이 절대 주소로 적재된다는 뜻에서 절대 코드를 생성하는 바인딩 방식이라고도 부른다&lt;/li&gt;
      &lt;li&gt;프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶다면 컴파일을 다시 해야 한다&lt;/li&gt;
      &lt;li&gt;멀티프로그래밍이 없던 시절에는 사용됐으나, 현대의 시분할 컴퓨팅 환경에서 거의 사용하지 않는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Load Time Binding&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램이 실행 될 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식&lt;/li&gt;
      &lt;li&gt;Loader의 관리 하에 물리적 메모리 주소가 결정되며 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다
        &lt;ul&gt;
          &lt;li&gt;Loader는 사용자 프로그램을 메모리에 적재하는 프로그램이다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;컴파일러가 재배치 가능 코드를 생성한 경우에만 가능하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Execution Time Binding&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Runtime Binding&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램이 실행된 후에도 프로그램이 위치한 물리적 메모리 주소가 변경 될 수 있는 바인딩 방식&lt;/li&gt;
      &lt;li&gt;CPU가 주소를 참조할 때마다 해당 데이터가 어느 물리주소에 위치에 존재하는지 확인해야하는데, 이때 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MMU(Memory Management Unit)&lt;/code&gt;의 주소 매핑 테이블을 사용한다
        &lt;ul&gt;
          &lt;li&gt;MMU는 논리적 주소와 물리적 주소를 매핑해주는 하드웨어 장치이다 (데이터베이스 매핑 테이블을 연상하라)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;MMU, 기준 레지스터, 한계 레지스터 등과 같은 하드웨어적인 자원이 필요하다&lt;/li&gt;
      &lt;li&gt;현대의 시분할 컴퓨팅 환경에서 사용되는 방식&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;mmumemory-management-unit&quot;&gt;MMU(Memory Management Unit)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156890264-594e4195-8654-4687-842b-a4188f4ed6ba.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156890486-86575be0-1ade-4bf1-a1de-3316ab261786.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Relocation Register (Base Register)
    &lt;ul&gt;
      &lt;li&gt;사용자 프로세스의 논리적 주소 0번지에 매핑된 물리적 주소를 의미&lt;/li&gt;
      &lt;li&gt;사용자 프로세스는 항상 자신의 시작 주소가 0번지라고 생각하지만, 이는 논리 주소일 뿐이며, 실제 물리 주소는 0번지가 아닐 수 있다&lt;/li&gt;
      &lt;li&gt;위 그림에서 P1은 CPU를 통해 논리 주소 346번지의 데이터를 요청했으나, 실제로 이 사용자 프로세스가 할당받은 물리 시작 주소는 14,000번지로 MMU에 저장돼있으므로 MMU는 14,000에 346을 더한 14,346번지의 주소를 반환한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Limit Register
    &lt;ul&gt;
      &lt;li&gt;사용자 프로세스에게 할당된 메모리의 최대 크기를 저장하는 레지스터&lt;/li&gt;
      &lt;li&gt;운영체제가 사용자 프로세스에게 할당한 메모리를 넘어 바깥의 메모리를 침범하면, 이 프로세스는 악의적인 프로세스(바이러스 등)일 가능성이 있으므로 이를 차단해야 한다&lt;/li&gt;
      &lt;li&gt;위 그림에서 운영체제가 P1에게 할당한 메모리의 크기는 3,000이며, 물리 주소는 14,000~17,000 이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156890581-fd4ac610-ee81-440d-9f3f-a03355577dfd.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;memory-terminology&quot;&gt;Memory Terminology&lt;/h2&gt;

&lt;h3 id=&quot;dynamic-loading&quot;&gt;Dynamic Loading&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 올리는 것&lt;/li&gt;
  &lt;li&gt;메모리를 더 효율적으로 사용할 수 있게 된다&lt;/li&gt;
  &lt;li&gt;가끔씩 사용되는 많은 양의 코드의 경우, 예를 들자면 오류 처리 루틴같은 것들에 유용하다&lt;/li&gt;
  &lt;li&gt;운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며, 운영체제가 라이브러리를 통해 지원할 수도 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;overlay&quot;&gt;Overlay&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;메모리에 프로세스의 부분 중 실제 필요한 정보만을 올리는 기법으로 Dynamic Loading와 비슷하여 헷갈릴 수 있다&lt;/li&gt;
  &lt;li&gt;초창기 컴퓨터 시스템은 메모리가 매우 작아 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없었다&lt;/li&gt;
  &lt;li&gt;프로세스의 주소 공간을 분할해 당장 필요한 부분만을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법&lt;/li&gt;
  &lt;li&gt;프로세스의 크기가 메모리보다 클 때 유용하다&lt;/li&gt;
  &lt;li&gt;작은 공간의 메모리를 사용하던 초창기 시스템에서 운영체제의 지원 없이 수작업으로 프로그래머가 구현하였다. 즉, 현재는 일반적으로 사용되지 않는다
    &lt;ul&gt;
      &lt;li&gt;프로그래밍이 상당히 복잡하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic Loading과의 차이점
    &lt;ul&gt;
      &lt;li&gt;Dynamic Loading: 멀티프로그래밍 환경에서 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도. 운영체제의 도움을 받는다&lt;/li&gt;
      &lt;li&gt;Overlay: 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 올리기 위한 용도. 운영체제의 도움을 받지 않는다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;swapping&quot;&gt;Swapping&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;메모리에 올라온 프로세스를 디스크의 Backing Store로 쫓아내는 것
    &lt;ul&gt;
      &lt;li&gt;Backing Store는 Swap Area라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는, 많은 사용자 프로세스를 담을 만큼 충분히 빠르고 큰 저장 공간이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;디스크에서 메모리로 올리는 작업을 Swap In, 메모리에서 디스크로 내리는 작업을 Swap Out라고 부른다&lt;/li&gt;
  &lt;li&gt;Swap이 일어나는 과정
    &lt;ul&gt;
      &lt;li&gt;일반적으로 중기 스케줄러(Swapper)가 Swap Out할 프로세스를 선정한다
        &lt;ul&gt;
          &lt;li&gt;주로 우선 순위 기반 CPU 스케줄링을 사용한다&lt;/li&gt;
          &lt;li&gt;우선 순위가 높은 프로세스를 Swap In&lt;/li&gt;
          &lt;li&gt;우선 순위가 낮은 프로세스를 Swap Out&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;만약 컴파일 타임 바인딩 혹은 로드 타임 바인딩 방식이 사용되고 있다면, Swap Out되었다가 Swap In이 되면 원래 존재하던 메모리 위치로 다시 올라가야만 한다&lt;/li&gt;
      &lt;li&gt;반면 런타임 바인딩 방식이 사용되고 있다면, 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있으므로 Swapping에 적합하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Swap Time은 디스크의 탐색 시간이나 회전 지연 시간 보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간(transfer time)이 대부분을 차지한다
    &lt;ul&gt;
      &lt;li&gt;디스크는 물리적으로 움직이는 시간이 존재하기 때문에, 전기적 신호로 동작하는 메모리에 비해 심각하게 느리다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dynamic-linking&quot;&gt;Dynamic Linking&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;연결(Linking)이란, 개발자가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행 파일을 생성하는 과정이다&lt;/li&gt;
  &lt;li&gt;Dynamic Linking은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연하는 기법이다.&lt;/li&gt;
  &lt;li&gt;Static Linking
    &lt;ul&gt;
      &lt;li&gt;외부 라이브러리가 프로그램의 실행 파일에 포함된다&lt;/li&gt;
      &lt;li&gt;실행 파일의 크기가 커진다&lt;/li&gt;
      &lt;li&gt;동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비가 심하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dynamic Linking
    &lt;ul&gt;
      &lt;li&gt;실행 파일에 라이브러리 코드가 포함되지 않으며, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다&lt;/li&gt;
      &lt;li&gt;라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 Stub이라는 작은 코드를 둔다&lt;/li&gt;
      &lt;li&gt;라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어 온다&lt;/li&gt;
      &lt;li&gt;운영 체제의 도움이 필요하다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;allocation-of-physical-memory&quot;&gt;Allocation Of Physical Memory&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;물리적 메모리는 운영체제 상주 영역(커널)과 사용자 프로세스 영역으로 나뉨
    &lt;ul&gt;
      &lt;li&gt;운영체제 상주 영역은 인터럽트 벡터와 함께 낮은 주소 영역을 사용한다 (주로 물리적 메모리의 0번지)&lt;/li&gt;
      &lt;li&gt;사용자 프로세스 영역은 운영체제보다 높은 주소 영역을 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;contiguous-allocation&quot;&gt;Contiguous Allocation&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;각각의 프로세스가 연속적인 메모리 공간에 적재되도록 하는 것&lt;/li&gt;
  &lt;li&gt;고정 메모리 분할 방식과 가변 메모리 분할 방식이 존재&lt;/li&gt;
  &lt;li&gt;고정 분할 방식은 외부 조각과 내부 조각이 동시에, 가변 분할 방식은 외부조각이 발생할 수 있다
    &lt;ul&gt;
      &lt;li&gt;외부 조각 (External Fragmentation)
        &lt;ul&gt;
          &lt;li&gt;프로그램의 크기보다 파티션의 크기가 작은 경우 해당 파티션이 비어있는 데도 불구하고 프로그램을 적재하지 못하기 때문에 생기는 메모리 공간을 의미&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;내부 조각 (Internal Fragmentation)
        &lt;ul&gt;
          &lt;li&gt;프로그램의 크기보다 파티션의 크기가 큰 경우 해당 파티션에 프로그램을 적재하고 남는 메모리 공간을 의미&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156916189-a3c38169-c2be-424e-9ab8-f39806943148.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156916195-5fa84be8-d7d9-467b-ba0b-9674a7ecfc04.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156916501-b54f0f76-a504-4311-84f2-02c258d1e19a.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;dynamic-storage-allocation-problem&quot;&gt;Dynamic Storage Allocation Problem&lt;/h4&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;가변 분할 방식에서 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내의 가용 공간 중 어느 위치에 올릴 것인지 결정하는 문제&lt;/li&gt;
  &lt;li&gt;First-fit
    &lt;ul&gt;
      &lt;li&gt;size가 n 이상인 것 중 최초로 찾아지는 hole에 할당&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Best-fit
    &lt;ul&gt;
      &lt;li&gt;size가 n 이상인 가장 작은 hole을 찾아 할당&lt;/li&gt;
      &lt;li&gt;hole 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole을 탐색해야 함&lt;/li&gt;
      &lt;li&gt;많은 수의 아주 작은 hole이 생성 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Worst-fit
    &lt;ul&gt;
      &lt;li&gt;가장 큰 hole에 할당 해야 함&lt;/li&gt;
      &lt;li&gt;역시 hole을 탐색해야 함&lt;/li&gt;
      &lt;li&gt;상대적으로 아주 큰 hole이 생성 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 효과적&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;compaction&quot;&gt;Compaction&lt;/h4&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;외부 조각 문제를 해결하는 방법 중 하나&lt;/li&gt;
  &lt;li&gt;물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리를 한 쪽으로 밀고, 가용 공간들을 다른 한쪽으로 몰아서 하나의 큰 가용 공간을 만드는 방법이다 (디스크 조각모음?, 가비지 컬렉션?)&lt;/li&gt;
  &lt;li&gt;매우 비용이 많이 드는 방법이다&lt;/li&gt;
  &lt;li&gt;최소한의 메모리 이동으로 압축하는 방법은 매우 복잡한 문제이다&lt;/li&gt;
  &lt;li&gt;압축은 프로세스의 주소가 실행 시간에 동적으로 재배치가 가능한 런타임 바인딩 방식을 지원하는 환경에만 가능하다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;non-contiguous-allocation&quot;&gt;Non-Contiguous Allocation&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;하나의 프로세스가 메모리의 여러 영역에 분산되어 적재 되는 것&lt;/li&gt;
  &lt;li&gt;Paging, Segmentation, Paged Segmentation 방식이 존재&lt;/li&gt;
  &lt;li&gt;현대의 컴퓨팅 시스템은 Non-Contiguous Allocation 방식의 Paging 기법을 주로 사용한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;paging&quot;&gt;Paging&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 페이지를 저장하는 방식&lt;/li&gt;
  &lt;li&gt;각 프로세스의 주소 공간 전체를 메모리에 한꺼번에 올릴 필요가 없고, 일부는 Backing Storage, 일부는 메모리에 혼재하는 것이 가능해진다&lt;/li&gt;
  &lt;li&gt;메모리를 페이지와 같은 동일한 크기의 프레임으로 미리 나누어 둔다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;페이지 프레임(Page Frame)&lt;/code&gt; 이라 칭한다&lt;/li&gt;
  &lt;li&gt;메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로 외부 조각이 발생하지 않고, 동적 메모리 할당 문제도 고려할 필요가 없어진다&lt;/li&gt;
  &lt;li&gt;주소 매핑을 기존 MMU의 레지스터 두개로는 처리할 수 없고, 페이지 테이블이라는 것을 사용하여 논리적 주소를 물리적 주소로 변환하는 작업이 필요해진다&lt;/li&gt;
  &lt;li&gt;프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없으므로 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부 조각이 발생할 수 있다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156917155-2fcba97f-fc20-4725-b553-eddea1635678.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;address-translation-architecture&quot;&gt;Address Translation Architecture&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156917190-b65a32a6-6440-4437-8dba-297e6bfdb4e6.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이징에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환에 사용&lt;/li&gt;
  &lt;li&gt;페이지 번호는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스로 사용되고, 해당 인덱스의 항목에는 그 페이지의 물리적 메모리 상의 기준 주소, 즉 시작 위치가 저장 됨&lt;/li&gt;
  &lt;li&gt;프로세스의 p번째 페이지의 물리적 메모리의 시작 위치를 알고 싶다면 해당 프로세스의 페이지 테이블에서 p번째 항목을 찾으면 됨&lt;/li&gt;
  &lt;li&gt;페이지 오프셋은 하나의 페이지 내에서의 변위(offset)를 알려 줌&lt;/li&gt;
  &lt;li&gt;기준 주소 값에 변위를 더함으로써 요청된 논리적 주소에 매핑되는 물리적 주소를 얻을 수 있다&lt;/li&gt;
  &lt;li&gt;위 그림에서 f (물리적 주소의 시작 위치) + d를 취하면 처음에 CPU가 요청한 논리적 주소에 매핑되는 물리적 주소가 나온다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-of-page-table&quot;&gt;Implementation Of Page Table&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료 구조로, 메모리에 항상 상주한다&lt;/li&gt;
  &lt;li&gt;현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다
    &lt;ul&gt;
      &lt;li&gt;Page-Table Base Register
        &lt;ul&gt;
          &lt;li&gt;메모리 내에서 페이지 테이블의 시작 위치를 가리킨다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Page-Table Length Register
        &lt;ul&gt;
          &lt;li&gt;페이지 테이블의 크기를 보관&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;페이징에서 모든 메모리 접근 연산은 총 2번씩 필요
    &lt;ul&gt;
      &lt;li&gt;주소 변환을 위해 페이지 테이블에 접근&lt;/li&gt;
      &lt;li&gt;변환된 주소에서 실제 데이터에 접근&lt;/li&gt;
      &lt;li&gt;이러한 오버헤드를 줄이고 메모리의 접근 속도를 향상하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLB(Translation Lock-aside Buffer)&lt;/code&gt; 라고 불리는 주소 변환용 고속 하드웨어 캐시를 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tlb&quot;&gt;TLB&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;TLB는 가격이 매우 비싸기 때문에 빈번히 참조되는 페이지에 대한 주소 변환 정보만 담게 된다&lt;/li&gt;
  &lt;li&gt;요청된 페이지 번호가 TLB에 존재한다면 곧바로 대응하는 물리적 메모리의 프레임 번호를 얻을 수 있지만, TLB에 존재하지 않는 경우에는 메인 메모리에 있는 페이지 테이블에 접근 해 프레임 번호를 알아내야 한다&lt;/li&gt;
  &lt;li&gt;페이지 테이블에는 페이지 번호가 주어지면 해당 페이지에 대응하는 프레임 번호를 얻을 수 있지만, TLB에는 페이지 번호와 프레임 번호 쌍을 가지고 있으므로 특정 페이지 번호가 있는지 TLB 전체를 찾아봐야 한다
    &lt;ul&gt;
      &lt;li&gt;이때 TLB 풀 스캔 시간이 오래 걸리므로 병렬적으로 탐색이 가능한 연관 레지스터를 사용한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TLB는 Context Switching 시, 이전 프로세스의 주소 변환 정보를 담고 있는 내용이 전부 지워진다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156917461-b40a24bd-ce0e-4477-a95a-f5acd2d7b589.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;hierarchical-paging&quot;&gt;Hierarchical Paging&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;현대의 컴퓨터는 하드웨어의 발달로 메모리를 크게 잡아먹는 프로그램을 지원
    &lt;ul&gt;
      &lt;li&gt;예를 들어 32bit 주소 체계를 사용하는 컴퓨터에서는 4GB의 주소 공간을 갖는 프로그램을 지원
        &lt;ul&gt;
          &lt;li&gt;페이지 사이즈가 4K라면, 한 프로세스당 페이지 테이블을 위해 1M 크기의 페이지 테이블 메모리 공간이 필요&lt;/li&gt;
          &lt;li&gt;그러나 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 페이지 테이블 공간이 심하게 낭비 됨&lt;/li&gt;
          &lt;li&gt;이러한 공간 낭비를 막기 위해 페이지 테이블 자체를 페이지로 구성하는 다단계 페이징 기법을 사용&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;two-level-page-table&quot;&gt;Two-Level Page Table&lt;/h4&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156917623-c636ae51-6724-4369-9461-510307884065.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주소 변환을 위해 외부 페이지 테이블과 내부 페이지 테이블로 나뉜 2단계 페이지 테이블을 사용&lt;/li&gt;
  &lt;li&gt;사용하지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 null로 설정, 이에 대응하는 내부 페이지 테이블을 생성하지 않음&lt;/li&gt;
  &lt;li&gt;페이지 테이블을 위해 사용되는 메모리 공간을 줄이지만, 페이지 테이블의 수가 증가하므로 약간의 시간적인 성능 손해가 발생한다 (trade-off)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156917713-80e7eb9c-9444-418a-a218-ebaadd7c87ca.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스의 논리적 주소를 두 종류의 페이지 번호(P1, P2)와 페이지 오프셋(d)으로 구분
    &lt;ul&gt;
      &lt;li&gt;P1은 외부 페이지 테이블의 인덱스이고, P2는 내부 페이지 테이블의 인덱스이다&lt;/li&gt;
      &lt;li&gt;따라서, 논리적 주소를 &amp;lt;P1, P2, d&amp;gt; 형태로 표시할 수 있게 된다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;외부 페이지 테이블로부터 P1만큼 떨어진 위치에서 내부 페이지 테이블의 주소를 얻게 되고, 내부 페이지 테이블로부터 P2만큼 떨어진 위치에서 요청된 페이지가 존재하는 프레임의 위치를 얻은 후, 해당 프레임으로부터 d만큼 떨어진 곳이 찾으려는 물리적 주소임&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;paging-1&quot;&gt;Paging&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;multilevel-paging-and-performance&quot;&gt;Multilevel Paging and Performance&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 주소 변환을 위한 메모리 공간 낭비가 심해진다&lt;/li&gt;
  &lt;li&gt;이 때, 다단계 페이지 테이블을 사용하면 페이지 테이블을 위해 사용되는 메모리 공간의 소모를 줄일 수 있지만, 메모리 접근 시간이 늘어난다&lt;/li&gt;
  &lt;li&gt;이 문제를 다시 TLB를 통해 메모리 접근 시간을 줄일 수 있다. 즉 현대의 컴퓨팅 시스템에서 TLB는 필연이다&lt;/li&gt;
  &lt;li&gt;4단계 페이지 테이블을 사용하는 경우
    &lt;ul&gt;
      &lt;li&gt;메모리 접근 시간 = 100ns, TLB 접근 시간 = 20ns&lt;/li&gt;
      &lt;li&gt;요청된 페이지에 대한 주소 변환 정보가 TLB에 존재할 확률 98%&lt;/li&gt;
      &lt;li&gt;평균 메모리 접근 시간 (EAT) = 0.98 x 120 + 0.02 x 520 = 128ns
        &lt;ul&gt;
          &lt;li&gt;TLB hit이 성공할 때 - TLB 접근 시간과 메모리 접근 시간의 합인 120ns&lt;/li&gt;
          &lt;li&gt;TLB hit이 실패할 때 - TLB 접근 시간과 메모리 접근 시간 x 5의 합인 520ns&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;결과적으로 주소 변환을 위해서만 28ns가 소요됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;memory-protection&quot;&gt;Memory Protection&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;페이지 테이블의 각 항목에는 주소 변환 정보 외에 메모리 보호를 위한 보호 비트와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유효-무효 비트(Valid (v) / Invalid (i))&lt;/code&gt;가 존재&lt;/li&gt;
  &lt;li&gt;보호 비트는 각 페이지에 대해 읽기-쓰기/읽기 전용 등의 접근 권한을 설정하는 데 사용&lt;/li&gt;
  &lt;li&gt;유효-무효 비트는 해당 페이지의 내용이 유효한지에 대한 내용을 포함
    &lt;ul&gt;
      &lt;li&gt;유효-무효 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유효&lt;/code&gt; 인 경우 - 해당 메모리 프레임에 해당 페이지가 존재. 따라서 접근 허용&lt;/li&gt;
      &lt;li&gt;유효-무효 비트가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무효&lt;/code&gt; 인 경우 - 해당 페이지가 물리적 메모리에 올라와 있지 않고, Backing Store에 존재하여 해당 메모리 프레임에 접근 불가&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157247187-d39a800b-b6e9-4b16-81d0-1588e3a5442f.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;inverted-page-table&quot;&gt;Inverted Page Table&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157246743-5d8f7afb-1854-4f64-8967-adf41c50524d.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157245564-3ebf3ee6-f79e-4dad-9f2a-37bb07d05446.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;shared-page&quot;&gt;Shared Page&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공유 코드(Shared Code)&lt;/code&gt;는 메모리 공간의 효율적인 사용을 위해 여러 프로세스가 공통적으로 사용 할  수 있도록 작성된 코드를 의미
    &lt;ul&gt;
      &lt;li&gt;재진입 가능 코드, 순수 코드라고도 불리며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;읽기 전용(Read Only)&lt;/code&gt;의 특성을 가짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;공유 페이지(Shared Page)&lt;/code&gt;는 공유 코드를 담고 있는 페이지를 의미
    &lt;ul&gt;
      &lt;li&gt;공유 페이지는 여러 프로세스에게 공유되는 페이지이므로 물리적 메모리에 하나만 적재되어 메모리를 효율적으로 사용할 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예를 들어 문서 편집기 프로그램을 공유 페이지를 사용해서 작성한 경우, 이 프로세스를 여러 개 수행하더라도 공유 코드를 담은 페이지는 메모리에 하나만 올라감
    &lt;ul&gt;
      &lt;li&gt;공유 코드는 읽기 전용의 성질을 가져야 하고 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재해야 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사유 페이지는 프로세스들이 공유하지 않고, 프로세스 별로 독자적으로 사용하는 페이지를 의미
    &lt;ul&gt;
      &lt;li&gt;사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어떠한 위치에 있어도 무방&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ed1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ed2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ed3&lt;/code&gt;은 공유 페이지, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data3&lt;/code&gt;은 사유 페이지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157245569-12fb4e81-4df5-4282-b1e5-2d96244ffabf.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;segmentation&quot;&gt;Segmentation&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램은 의미 단위인 여러 개의 세그먼테이션으로 구성
    &lt;ul&gt;
      &lt;li&gt;작게는 프로그램을 구성하는 하나 하나를 세그먼트로 정의&lt;/li&gt;
      &lt;li&gt;크게는 프로그램 전체를 하나의 세그먼트로 정의 가능&lt;/li&gt;
      &lt;li&gt;일반적으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;data&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stack&lt;/code&gt; 부분이 각각 하나의 세그먼트로 정의됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세그먼트는 다음과 같은 logical unit들임
    &lt;ul&gt;
      &lt;li&gt;main()&lt;/li&gt;
      &lt;li&gt;function&lt;/li&gt;
      &lt;li&gt;global variables&lt;/li&gt;
      &lt;li&gt;stack&lt;/li&gt;
      &lt;li&gt;symbol table&lt;/li&gt;
      &lt;li&gt;arrays&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;segmentation-architecture&quot;&gt;Segmentation Architecture&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;논리 주소는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;세그먼트 번호(s), 오프셋(d)&amp;gt;&lt;/code&gt; 두 가지로 구성됨
    &lt;ul&gt;
      &lt;li&gt;s는 해당 논리 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지를 나타냄&lt;/li&gt;
      &lt;li&gt;d는 세그먼트 내에서 얼마만큼 떨어져 있는 지에 대한 정보를 나타냄&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세그먼트 테이블 사용
    &lt;ul&gt;
      &lt;li&gt;기준점(base)과 한계점(limit)을 가진다&lt;/li&gt;
      &lt;li&gt;기준점은 물리 메모리에서 그 세그먼트의 시작 위치를 나타낸다&lt;/li&gt;
      &lt;li&gt;한계점은 물리 메모리에서 그 세그먼트의 길이를 나타낸다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;세그먼트 테이블 기준 레지스터(STBR)와 세그먼트 테이블 길이 레지스터(STLR)을 사용
    &lt;ul&gt;
      &lt;li&gt;STBR은 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작 주소를 담고 있다&lt;/li&gt;
      &lt;li&gt;STLR은 그 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 세그먼트의 개수를 나타낸다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;segmentation-hardware&quot;&gt;Segmentation Hardware&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157245591-7e0bee50-3280-4044-a4c3-8a374dc51a34.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 확인
    &lt;ul&gt;
      &lt;li&gt;요청된 세그먼트 번호(s)가 STLR에 저장된 값보다 작은 값 인지?
        &lt;ul&gt;
          &lt;li&gt;아니라면, 존재하지 않는 세그먼트에 대한 접근 시도이므로 예외 발생&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;논리적 주소의 오프셋(d)이 그 세그먼트의 길이(limit)보다 작은 값 인지?
        &lt;ul&gt;
          &lt;li&gt;아니라면, 세그먼트 길이를 넘어서는 오프셋 위치이므로 예외 발생&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;protection&quot;&gt;Protection&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;각 세그먼트별로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;보호 비트(Protection Bit)&lt;/code&gt;가 있다
    &lt;ul&gt;
      &lt;li&gt;보호 비트는 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한이 있는지를 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;각 세그먼트 별로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유효 비트(Valid Bit)&lt;/code&gt;가 있다
    &lt;ul&gt;
      &lt;li&gt;유효 비트는 각 세그먼트의 주소 변환 정보가 유효한지를 의미&lt;/li&gt;
      &lt;li&gt;즉, 해당 세그먼트가 현재 물리 메모리에 적재되어 있는지를 의미&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;sharing&quot;&gt;Sharing&lt;/h3&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스가 특정 세그먼트를 공유하여 사용하는 개념&lt;/li&gt;
  &lt;li&gt;공유 세그먼트는 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157245601-d6d6dfe8-4a44-44a1-af49-061fb63fa0ef.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;allocation-of-physical-memory-1&quot;&gt;Allocation of Physical Memory&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157251244-dcc3a8dd-230c-47eb-9814-a62ae0d715f5.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;advantages-and-disadvantages-of-segmentation&quot;&gt;Advantages and Disadvantages of Segmentation&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;Advantages
    &lt;ul&gt;
      &lt;li&gt;주소 공간의 일부를 공유하거나 특정 주소 공간에 읽기 전용 등의 접근 권한 제어를 하고자 할 경우, 이는 단순히 크기 단위가 아닌 어떤 의미 단위로 이루어질 때가 많음&lt;/li&gt;
      &lt;li&gt;이 때, 세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Disadvantages
    &lt;ul&gt;
      &lt;li&gt;세그먼테이션 기법에서는 프로그램을 의미 단위로 나누기 때문에 세그먼트의 길이가 균일하지 않음&lt;/li&gt;
      &lt;li&gt;메모리 관리에서 외부 단편화가 발생하게 되며, 연속 할당 메모리 관리의 가변 분할 방식에서의 동일한 문제점이 발생&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;paged-segmentation&quot;&gt;Paged Segmentation&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/157245607-0fbccdb1-fb87-4aea-942a-b41ca5cd5fb9.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;페이지드 세그먼테이션 기법은 프로그램을 의미 단위의 세그먼트로 나누되, 세그먼트가 동일한 크기 페이지의 집합으로 구성 됨
    &lt;ul&gt;
      &lt;li&gt;페이지드 세그먼테이션 기법에서는 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부 조각의 문제를 해결&lt;/li&gt;
      &lt;li&gt;세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 문제를 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용
    &lt;ul&gt;
      &lt;li&gt;하나의 세그먼트가 여러 개의 페이지로 구성되므로 각 세그먼트마다 페이지 테이블을 가지게 됨&lt;/li&gt;
      &lt;li&gt;즉, 2단계 페이지 테이블과 유사한 구조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&amp;lt;세그먼트 번호(s), 오프셋(d)&amp;gt;으로 구성된 논리 주소를 물리 주소로 변환하는 과정
    &lt;ul&gt;
      &lt;li&gt;논리 주소의 상위 비트인 s를 통해 세그먼트 테이블의 해당 항목에 접근
        &lt;ul&gt;
          &lt;li&gt;이 세그먼트 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 포함된다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;d를 세그먼트 내에서의 페이지 번호(p), 페이지 내에서의 변위(d’)로 사용하도록 분리&lt;/li&gt;
      &lt;li&gt;p와 d’를 이용하여 물리 메모리에 접근&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/cs/operating-system/2022-03-10-memory-management/</link>
			<guid isPermaLink="true">/cs/operating-system/2022-03-10-memory-management/</guid>
			
			
			<category>cs</category>
			
			<category>operating-system</category>
			
		</item>
		
		<item>
			<title>GitHub - Pull Request File Tree</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#feature-preview---pull-request-file-tree&quot; id=&quot;markdown-toc-feature-preview---pull-request-file-tree&quot;&gt;Feature preview - Pull Request File Tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;feature-preview---pull-request-file-tree&quot;&gt;Feature preview - Pull Request File Tree&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;깃허브에 새로운 베타 기능이 들어왔다.&lt;/p&gt;

&lt;p&gt;PR을 트리구조로 보여주는 기능인데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Octotree&lt;/code&gt;와 비슷하다.&lt;/p&gt;

&lt;p&gt;베타버전이기 때문에 활성화를 해 주어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;깃허브에 로그인하여 우상단 프로필을 클릭한 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Feature preview&lt;/code&gt;를 클릭한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156880912-d7ba0acc-626a-4c02-93db-771665303586.JPG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pull Request File Tree&lt;/code&gt; - &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Enable&lt;/code&gt;을 클릭해 기능을 활성화 해준다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156880911-9d451693-f6f7-4433-8723-69e677abeeb0.JPG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아무 프로젝트나 들어가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pull Request&lt;/code&gt; 탭을 누른 후 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;File changed&lt;/code&gt; 탭을 클릭하면 좌측에 파일 트리가 나타난다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156881059-6dc001aa-7a11-43a5-845f-feea6ce35ef0.JPG&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-03-05-diary-37/</link>
			<guid isPermaLink="true">/diary/2022-03-05-diary-37/</guid>
			
			
			<category>diary</category>
			
		</item>
		
		<item>
			<title>대체 스레드 종류는 뭐가 이렇게 많나? 😡</title>
			<description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#스레드thread&quot; id=&quot;markdown-toc-스레드thread&quot;&gt;스레드(Thread)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#사전-지식&quot; id=&quot;markdown-toc-사전-지식&quot;&gt;사전 지식&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#하드웨어-스레드hardware-thread&quot; id=&quot;markdown-toc-하드웨어-스레드hardware-thread&quot;&gt;하드웨어 스레드(Hardware Thread)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#커널-스레드kernel-thread&quot; id=&quot;markdown-toc-커널-스레드kernel-thread&quot;&gt;커널 스레드(Kernel Thread)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#유저-스레드user-thread&quot; id=&quot;markdown-toc-유저-스레드user-thread&quot;&gt;유저 스레드(User Thread)&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#그린-스레드green-thread&quot; id=&quot;markdown-toc-그린-스레드green-thread&quot;&gt;그린 스레드(Green Thread)&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#reference&quot; id=&quot;markdown-toc-reference&quot;&gt;Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;스레드thread&quot;&gt;스레드(Thread)&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;이번에 알았지만 컴퓨터 과학에서 스레드라는 용어는 굉장히 범용적으로 사용되고 있었다.&lt;/p&gt;

&lt;p&gt;실제로 스레드는 여러 종류가 존재하기 때문에 글의 문맥에 따라 어떤 스레드를 말하는지를 유추할 수 있어야 하는데, 나 같은(노베이스 비전공자) 사람이 이런 상황을 마주하면 굉장히 힘들어진다.&lt;/p&gt;

&lt;p&gt;자바 고급 서적들(JVM 레벨의…)을 보다보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 스레드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유저 스레드&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;그린 스레드&lt;/code&gt;, 혹은 그냥 접두사 다 떼 놓은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스레드&lt;/code&gt; 같은 용어들이 미친듯이 나오는데, 기본기가 없으니 이게 대체 무슨말들을 하는건지 알아들을수가 있어야지…&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156754691-a85878b2-6eda-430c-a11d-44580aa3b91e.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;비유하자면, 나는 코딩을 처음 시작할 때 API가 뭔지 엄청 헷갈려했었는데, 이것과 굉장히 비슷한 느낌이었다. (API도 굉장히 범용적으로 사용되는 용어이므로…)&lt;/p&gt;

&lt;p&gt;아무튼, 이러한 이유로 이번에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제&lt;/code&gt; 과목을 공부하게 됐는데, 까먹으면 내가 나중에 다시 볼 거기도 하고, 나 같은 분들(노베이스 비전공자)께 조금이나마 도움이 되길 바라기도 하며 나름대로 정리한 내용들을 기록해본다.&lt;/p&gt;

&lt;p&gt;우선 이 글은 스레드가 뭔지 궁금해 한번쯤 검색을 해 사전적인 정의라도 찾아봤다는 가정하에 기록한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사전-지식&quot;&gt;사전 지식&lt;/h2&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로그램(Program)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;코드로 작성된 실행될 수 있는 애플리케이션. 하지만 메모리(RAM)를 할당받지 못하고 하드디스크에 저장돼있는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세스(Process)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램이 운영체제로부터 메모리를 할당받아 실행된 것. 즉, 실행 된 프로그램&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스레드(Thread)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스의 실행 단위. &lt;u&gt;하나의 프로세스는 최소한 하나 이상의 스레드를 포함한다&lt;/u&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;멀티 프로그래밍(Multi Programming)&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;멀티 프로세스(Multi Process)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;메모리에 동시에 여러개의 프로세스가 올라가는 것. MPD(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Multi-Programming Degree&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Degree of Multi programming mpd&lt;/code&gt;) 라는 키워드가 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;멀티 태스킹(Multi Tasking)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU가 여러개의 프로세스를 동시에 처리하는 것. CPU가 프로세스1을 조금 작업하고 정지한 후 프로세스2를 작업하러 가는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시분할(Time Sharing)&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시분할 시스템(TSS, Time Sharing System)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;멀티 태스킹을 위해 각 프로세스가 CPU를 점유할 수 있는 시간을 강제해둔 시스템&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;멀티 프로세싱(Multi Processing)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;프로그램이 여러개의 코어를 활용하는 것. 병렬 프로그래밍이라고도 불린다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;멀티 스레딩(Multi Threading)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세스가 여러개의 스레드를 갖는 것. 멀티스레딩을 활용하면 동시성을 보장할 수 있다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시성(Concurrency)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU가 동 시간대에는 단 하나의 작업을 처리하지만, 여러개의 작업을 조금씩 번갈아가며 처리하면 이 작업이 인간 입장에선 너무 빠르기 때문에 여러개의 작업이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;동시에&lt;/code&gt; 처리되는 것 처럼 느낀다. 이를 동시성이라고 부른다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬성(Parallel)&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU가 동 시간대에 여러개의 작업을 처리하고 있는 것. 즉, 코어 1이 프로세스 1을 처리하고, 코어 2가 프로세스 2를 처리하면 동 시간대에 정확히 두개의 작업을 처리하고 있는 것이다. 이를 병렬성이라고 부른다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156866920-fbed8024-c43b-486b-83e6-0ce9f3a03175.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;동시성과 병렬성의 차이&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156770870-2a963bf6-863c-48d1-8561-2e65ea40a538.png&quot; alt=&quot;image&quot; target=&quot;_blank&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;스레드 개념도&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;하드웨어-스레드hardware-thread&quot;&gt;하드웨어 스레드(Hardware Thread)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;우선 누구라도 듀얼 코어, 4코어 4스레드, 4코어 8스레드 어쩌고 하는 말들을 들어본 적이 있을 것이다.&lt;/p&gt;

&lt;p&gt;여기서 말하는 스레드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하드웨어 스레드&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;누군가는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPU 스레드&lt;/code&gt;라고 부르기도 하는 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;모든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;코드(Instruction Set, 명령어)&lt;/code&gt;는 메모리에서 CPU로 옮겨진 후 실행(연산)되고, 이러한 결과는 다시 메모리에 반영된다.&lt;/p&gt;

&lt;p&gt;하지만 CPU의 연산 속도에 비해 메모리에서 CPU로 코드를 옮겨오거나, CPU에서 메모리로 코드를 옮기는 속도는 상대적으로 매우매우매우 느리다.&lt;/p&gt;

&lt;p&gt;즉, 하드웨어가 발전함에 따라 CPU가 일하는 속도가 너무 빨라졌기 때문에, 역설적으로 CPU가 할 일이 없어 손가락을 빨며 대기하는 상황이 생긴다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156755765-79d56587-a3ba-4110-8142-e82dc7682983.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 그림대로라면, CPU는 코드를 메모리로 옮기거나, 메모리에서 CPU로 가져오는 동안에는 연산 작업을 하지 못하게 된다.&lt;/p&gt;

&lt;p&gt;즉, CPU의 성능을 온전하게 활용하지 못하고 클럭을 낭비하게 되는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156755385-5acf1da0-0abe-4bdd-83f5-fe9eb2c46bae.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;CPU의 상태&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;상황이 이러하니 나온 것이, CPU 내부에서 일을 하는 친구를 하나 더 만들자는 것.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;인텔&lt;/code&gt;에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HT(하이퍼 스레딩)&lt;/code&gt;라 부르고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AMD&lt;/code&gt;에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SMT&lt;/code&gt;라고 부르는 기술이 탄생한다.&lt;/p&gt;

&lt;p&gt;그림으로 보자면 하기와 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156756263-73982a3c-8378-4ef4-9840-e6062998ab60.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여담이지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPU&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로세서&lt;/code&gt;는 대부분 이음동의어로 사용되며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;코어&lt;/code&gt;라는 것은 CPU 내부에 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ALU&lt;/code&gt;와 같은 핵심 부품들을 통틀어 의미한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156765271-6736fc8c-c3b4-4942-936e-39f4282b0fe0.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HT/SMT&lt;/code&gt;는 실제로 물리적인 코어는 하나만 있지만, 운영체제에게는 코어가 두개인 것처럼 속이는 기술이다.&lt;/p&gt;

&lt;p&gt;따로 찾아보면 파이프라이닝이니 뭐니 해서 굉장히 내용이 깊고 심오하니, 한번쯤은 꼭 찾아보길 바란다 !&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156759097-5bc2a3c6-d7f8-467c-89e2-d7aadb276dc8.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커널-스레드kernel-thread&quot;&gt;커널 스레드(Kernel Thread)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;프로그래밍을 제외한 대부분의 매체에서 말하는 스레드는 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 스레드&lt;/code&gt;라고 봐도 무방하다.&lt;/p&gt;

&lt;p&gt;실제로, 프로그래밍 관련 서적에서도 커널 스레드가 가장 많이 나오기도 한다.&lt;/p&gt;

&lt;p&gt;이 커널 스레드가 가장 헷갈렸는데, 커널 스레드를 부르는 다른 이름이 진절머리나게 많았기 때문이다.&lt;/p&gt;

&lt;p&gt;이 커널 스레드를 어떤 이름으로 부르는지, 내가 본 용어들을 정리하자면 다음과 같고, 더 있을수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;네이티브 스레드(Native Thread)&lt;/li&gt;
  &lt;li&gt;운영체제 스레드(OS Thread)&lt;/li&gt;
  &lt;li&gt;커널 레벨 스레드(Kernel Level Thread)&lt;/li&gt;
  &lt;li&gt;운영체제 레벨 스레드(OS Level Thread)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이것들이 모두 같은걸 의미하는 용어라는걸 확신할 수 없는 상황(노베이스 비전공 -ㅅ-)에서 온갖 글들을 보고있으면 머리만 더 아파지는 것이다. (예를 들자면… &lt;u&gt;엥? 이건 또 뭐야?&lt;/u&gt; 같은 느낌?)&lt;/p&gt;

&lt;p&gt;&lt;u&gt;이제와서 나는 대부분의 상황에서 커널 스레드를 위의 용어들과 동일하다고 생각하며 보고 있으며, 실제로 그렇게 봐도 이해하는데 지장이 없었다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156759840-74c59fde-49be-4b0b-bc68-5a4564b53755.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;운영체제도 하나의 프로그램으로서 하드디스크에 저장되어있고, 컴퓨터에 전원을 공급하면 운영체제가 실행되며 메모리(RAM)에 올라가 프로세스가 된다.&lt;/p&gt;

&lt;p&gt;그리고 &lt;u&gt;메모리에 항상 상주하는, 운영체제의 핵심적인 부분(코드)들이 바로 커널&lt;/u&gt;이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널&lt;/code&gt;은 일반적으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제&lt;/code&gt;의 이음동의어다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;운영체제도 일단 프로그램이기 때문에, 내부적으로 최소한 한개 이상의 스레드를 가진다.&lt;/p&gt;

&lt;p&gt;운영체제가 프로그램으로서 갖는 스레드를 바로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 스레드(혹은 위에 나열한 용어들...)&lt;/code&gt;라고 부르며, 운영체제 코드에 작성 된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CPU 스케쥴링&lt;/code&gt;같은 코드들에 직접적으로 영향을 받아 하드웨어 스레드를 점유하거나 여타 하드웨어들을 제어하는 것이 바로 이 커널 스레드이다.&lt;/p&gt;

&lt;p&gt;&lt;u&gt;즉, 4코어 8스레드 컴퓨터에서는 동시간대에 정확히 8개의 커널 스레드가 동작할 수 있는 것이다.&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;따라서 멀티코어 파워를 온전히 활용해야 하는 병렬 프로그래밍에 있어 매우 중요한 개념이라고 볼 수 있겠다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;유저-스레드user-thread&quot;&gt;유저 스레드(User Thread)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;유저 스레드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;사용자 스레드&lt;/code&gt;, 혹은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유저 레벨 스레드(User Level Thread)&lt;/code&gt;라고 불리기도 하며, 이는 프로그래밍 언어에서 제공하는 스레드를 의미한다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어로 프로그램을 개발하면, 내부적으로 최소한 한개 이상의 스레드를 갖게 되는데, 이렇게 추가적인 스레드를 만들고 제어하는 것들을 대부분의 프로그래밍 언어에서 지원하고 있다.&lt;/p&gt;

&lt;p&gt;그리고 기본적으로 커널에서는 이 유저 스레드들의 존재를 모르며, 오직 프로세스를 대상으로 일련의 작업들을 진행한다. (커널은 프로세스인 줄 알았지만, 그게 실제로는 유저 스레드인 셈…)&lt;/p&gt;

&lt;p&gt;그러니까 실제적으로 유저 스레드가 작업을 하려면 커널 스레드와 반드시 매핑이 되어야만 하며(하드웨어 스레드가 커널 스레드를 바라보므로), 커널 스레드와 매핑되지 않은 유저 스레드는 아무런 작업도 할 수 없는 상태가 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;여기서 약간 의문이 생겼고, 나름의 답을 내렸는데 이게 정답인지는 나도 잘 모르겠다.&lt;/p&gt;

&lt;p&gt;위에서는 운영체제도 프로그램이라 하였다.&lt;/p&gt;

&lt;p&gt;그리고, 현재 대부분의 운영체제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C언어&lt;/code&gt;로 작성돼있다.&lt;/p&gt;

&lt;p&gt;즉, 위에서 말한 커널 스레드도 C언어에서 제공하는 스레드 관련 코드로 작성됐을 것이라는 생각이 들었는데, 그렇다면 &lt;u&gt;커널 스레드도 유저 스레드의 일종이라고 볼 수 있지 않을까?&lt;/u&gt; 라는 의문이 들었었다.&lt;/p&gt;

&lt;p&gt;내 결론은 커널 스레드도 유저 스레드의 일종이며, 운영체제도 프로그램이긴 하지만, 아주 특별한 프로그램이기 때문에 마찬가지로 운영체제의 유저 스레드에 커널 스레드라는 특별한 이름을 붙여 부르게 된 것이 아닐까 싶다. (정확히 아시는분은 알려주세요 😭)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;잡담이 길었는데, 내가 사용하는 자바에도 물론 유저 스레드를 지원하기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread&lt;/code&gt;라는 클래스와, 이에 관련 된 여러가지 클래스들이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...이하 생략&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threadStatus&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IllegalThreadStateException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;start0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;started&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;finally&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;started&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;threadStartFailed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ignore&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cm&quot;&gt;/* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;native&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;start0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  
  &lt;span class=&quot;c1&quot;&gt;// ...이하 생략&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;모던 자바의 스레드는 특이한데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Thread.start()&lt;/code&gt;가 호출되면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start0()&lt;/code&gt; 이라는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JNI(Java Native Interface)&lt;/code&gt;를 통해 운영체제의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시스템 콜(System Call)&lt;/code&gt;을 호출하고, 이는 결과적으로 커널 스레드를 직접적으로 생성하여 유저 스레드(여기선 자바 스레드)와 매핑하게 된다.&lt;/p&gt;

&lt;p&gt;즉, 모던 자바의 모든 유저 스레드는 커널을 직접 만들어 다이렉트로 연결되므로, 하나도 남김없이 커널의 CPU 스케쥴링에 직접적으로 영향을 받게 된다.&lt;/p&gt;

&lt;p&gt;또한, 하나의 커널 스레드가 여러개의 유저 스레드를 관리하고, 하나의 유저 스레드가 여러개의 커널 스레드의 관리를 받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Many-To-Many&lt;/code&gt; 모델을 채택해 멀티코어 파워를 온전히 활용할 수 있게 됐다.&lt;/p&gt;

&lt;p&gt;정리하자면 모던 자바는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;병렬 프로그래밍&lt;/code&gt;에 많은 최적화가 되어있는 셈이다. (모든 코어를 균등하게 잘 갈굴 수 있다…!)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156762801-c88e498e-9211-41ab-b89e-48f803e47f32.png&quot; alt=&quot;image&quot; class=&quot;lead&quot; width=&quot;800&quot; height=&quot;400&quot; loading=&quot;lazy&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;모던 자바의 Thread 모델&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;그린-스레드green-thread&quot;&gt;그린 스레드(Green Thread)&lt;/h2&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156762117-a3fe8e79-74d8-429a-b747-7b1d61e5e0f1.JPG&quot; alt=&quot;스레드_인용&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;자바 최적화 中&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;극 초창기 자바인 버전 1.2이전의 자바 스레드를 의미한다.&lt;/p&gt;

&lt;p&gt;극 초창기의 자바는 위와 다르게, 하나의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;커널 스레드&lt;/code&gt;에 여러개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;유저 스레드&lt;/code&gt;가 매핑되는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Many-To-One&lt;/code&gt; 모델이었다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/71188307/156762257-d14b362a-2eb6-4613-b481-cdcf491d0a32.png&quot; alt=&quot;image&quot; class=&quot;lead&quot; width=&quot;800&quot; height=&quot;400&quot; loading=&quot;lazy&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;자바 1.2 이전의 Thread 모델 -&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, 동시성은 지원하지만, 병렬성은 지원 할 수 없는 모델이었기 때문에 멀티코어 파워를 온전히 활용 할 수 없었고, 이로 인한 성능 이슈로 인해 자바 커뮤니티에서 굉장히 많은 비판을 받았던 것 같다.&lt;/p&gt;

&lt;p&gt;아무튼 모던 자바에서는 사용되지 않고 있는 것 같지만, 자바 고급 서적들에서는 의외로 자주 나오는 용어이기 때문에 추가하였다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;reference&quot;&gt;Reference&lt;/h1&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&amp;amp;ejkGb=KOR&amp;amp;barcode=9791185475578&quot; target=&quot;_blank&quot;&gt;📕 운영체제 10판&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791162241776&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; target=&quot;_blank&quot;&gt;📕 자바 최적화&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791186697139&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; target=&quot;_blank&quot;&gt;📕 자바 성능 튜닝&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9788960770485&amp;amp;orderClick=LEa&amp;amp;Kc=&quot; target=&quot;_blank&quot;&gt;📕 자바 병렬 프로그래밍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&amp;amp;mallGb=KOR&amp;amp;barcode=9791188427024&amp;amp;orderClick=LAG&amp;amp;Kc=&quot; target=&quot;_blank&quot;&gt;📕 JVM Performance Optimizing 및 성능분석 사례&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/cd/E19455-01/806-3461/6jck06gqe/index.html&quot; target=&quot;_blank&quot;&gt;📜 Oracle Docs - 멀티스레딩&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.geeksforgeeks.org/difference-between-java-threads-and-os-threads/?ref=rp&quot; target=&quot;_blank&quot;&gt;📜 자바 스레드와 OS 스레드의 차이점&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lass.cs.umass.edu/~shenoy/courses/fall00/homeworks/hw2soln.html&quot; target=&quot;_blank&quot;&gt;📜 LASS - 스레드, 스케줄링 및 동기화&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://genesis8.tistory.com/242&quot; target=&quot;_blank&quot;&gt;📜 유저 레벨 스레드 / 커널 레벨 스레드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/46619223/difference-between-cpu-threads-kernel&quot; target=&quot;_blank&quot;&gt;📜 Stackoverflow - CPU 스레드, 커널 스레드, OS 스레드, 유저 스레드의 차이점&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/2653458/understanding-javas-native-threads-and-the&quot; target=&quot;_blank&quot;&gt;📜 Stackoverflow - 자바의 네이티브 스레드와 JVM 이해하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/questions/18278425/are-java-threads-created-in-user-space-or&quot; target=&quot;_blank&quot;&gt;📜 Stackoverflow - 자바 스레드는 유저 또는 커널 공간에서 생성되나요?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://namu.wiki/w/SMT&quot; target=&quot;_blank&quot;&gt;📜 나무위키 - SMT/HT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
</description>
			<pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate>
			<link>https://shirohoo.github.io/diary/2022-03-04-diary-36/</link>
			<guid isPermaLink="true">/diary/2022-03-04-diary-36/</guid>
			
			
			<category>diary</category>
			
		</item>
		
	</channel>
</rss>
